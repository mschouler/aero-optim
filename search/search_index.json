{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to AERO-Optim AERO-Optim is a simple aerodynamic shape optimization framework coupling FreeForm Deformation (FFD), automatic meshing with gmsh and any CFD solver execution in the frame of an optimization algorithm based on inspyred or pymoo . It is composed of the following core components: Deform : which defines classes to perform FFD-based deformation of any 2D geometry, Mesh : which defines multiple classes to generate automatic meshes, Simulator : which defines a class to orchestrate CFD simulations including pre- and post-processing steps as well as progress monitoring, Optimizer and Evolution : which define multiple classes to coordinate the optimization procedures with inspyred or pymoo The overall structure of the framework is illustrated on the Figure below: In an optimization, classes are created from left to right based on the execution command and the configuration file. All components can be inherited and customized to meet any need and the righmost classes can be loaded and tested separately. Quick Installation AERO-Optim requires Python 3.10 or newer and comes with a few dependencies listed in requirements.txt and recalled below: gmsh # to design and visualize meshes (MESH) inspyred # optimization toolbox (OPTIM) numpy # to manipulate geometries as arrays (FFD) matplotlib # to visualize the generated deformed profiles (FFD) pandas # to load simulation results (OPTIM) pymoo # optimization toolbox (OPTIM) scipy # to use quasi monte carlo samplers (FFD) From the user's working directory, they can all be installed at once in a virtual environment with the following commands: git clone https://github.com/mschouler/aero-optim.git cd aero-optim python3 -m venv .venv source .venv/bin/activate pip install -r requirements.txt pip install -e . Warning The virtual environment must be sourced every time a new terminal is launched! Note So far, the framework was only installed and tested on MacOS and Linux platforms. First Execution The framework was designed to automate aerodynamic optimization which, in this case, consists in: 1) deforming a baseline geometry, 2) generating its associated mesh, 3) performing a CFD computation, as many times as required to obtain a geometry maximizing/minimizing certain quantities of interest (QoIs). Although the chaining of these steps is performed under the supervision of main_optim.py , the three subscripts presented below were introduced to facilitate each step's individual evaluation: First FFD: auto_ffd.py This script performs one or multiple FFD of the geometry passed as its input argument. For instance: # from aero-optim to naca_base cd examples/NACA12/naca_base ffd -f ../data/naca12.dat -nc 2 -d \"0. 0. 1. 1.\" will yield the figure below: where the deformation vector is $$[D_{10}, D_{20}, D_{11}, D_{21}] = [0., 0., 1., 1.]$$ in lattice unit (see FFD ). First Mesh: auto_gmsh.py This script generates a simple mesh parameterized according to its associated configuration file. For instance: # from aero-optim to naca_base cd examples/NACA12/naca_base mesh --config = naca_base.json # left figure cd ../naca_block mesh --config = naca_block.json # right figure will generate the figures below: First Simulation: auto_simulator.py This script performs a single simulation according to its associated configuration file and mesh. For instance: # from aero-optim to naca_base cd examples/NACA12/naca_base mesh -c naca_base.json simulator -c naca_base.json -f output/naca_base.mesh will run a Wolf simulation provided that the user has access to the solver and that they have properly specified the path to the executable: INFO:aero_optim.simulator.simulator:g0, c0 converged in 533 it. INFO:aero_optim.simulator.simulator:last values: ResTot CD CL ResCD ResCL x y Cp 1 .799346e-08 0 .152689 0 .358267 7 .271155e-16 2 .169212e-15 NaN NaN NaN >> simulation finished after 5 .0141987800598145 seconds The printed quantities correspond to the last row of the dataframe built by post-processing the simulation outputs as indicated in the \"post_process\" entry of the configuration file. The NaNs correspond to missing values due to the varying size of the extracted data. Warning In order for the command to pass, don't forget to fix the exec_cmd executable path in naca_base.json . A zoomed view of the solution mach field plotted with vizir4 and the following command is given below: # from naca_base /path/to/vizir -in output/WOLF/wolf_g0_c0/naca_base.mesh -sol output/WOLF/wolf_g0_c0/mach.solb Note As of 2024, Wolf is not open-source and may not be available to the user. Customization guidelines on how to adapt any part of the framework such as the Simulator are given in the Customization tab. First Optimization: main_optim.py This script orchestrates an optimization execution given the configuration parameters. For instance, naca_base.json and the command below executes a single iteration of the Particle Swarm Optimization algorithm of inspyred with 5 candidates and 8 variables of design sampled in [-0.5, 0.5] (in lattice units): # from aero-optim to naca_base cd examples / NACA12 / naca_base optim - c naca_base . json -- inspyred Warning Although inspyred considers the first generation as the 0th and allows to use max_generations=0 , pymoo does not and max_generations cannot be less than 1. Tip In the configuration file, the budget entry corresponds to the number of simulation executed concurrently. It should hence be adapted to the amount of resources available to the user.","title":"Getting Started"},{"location":"#welcome-to-aero-optim","text":"AERO-Optim is a simple aerodynamic shape optimization framework coupling FreeForm Deformation (FFD), automatic meshing with gmsh and any CFD solver execution in the frame of an optimization algorithm based on inspyred or pymoo . It is composed of the following core components: Deform : which defines classes to perform FFD-based deformation of any 2D geometry, Mesh : which defines multiple classes to generate automatic meshes, Simulator : which defines a class to orchestrate CFD simulations including pre- and post-processing steps as well as progress monitoring, Optimizer and Evolution : which define multiple classes to coordinate the optimization procedures with inspyred or pymoo The overall structure of the framework is illustrated on the Figure below: In an optimization, classes are created from left to right based on the execution command and the configuration file. All components can be inherited and customized to meet any need and the righmost classes can be loaded and tested separately.","title":"Welcome to AERO-Optim"},{"location":"#quick-installation","text":"AERO-Optim requires Python 3.10 or newer and comes with a few dependencies listed in requirements.txt and recalled below: gmsh # to design and visualize meshes (MESH) inspyred # optimization toolbox (OPTIM) numpy # to manipulate geometries as arrays (FFD) matplotlib # to visualize the generated deformed profiles (FFD) pandas # to load simulation results (OPTIM) pymoo # optimization toolbox (OPTIM) scipy # to use quasi monte carlo samplers (FFD) From the user's working directory, they can all be installed at once in a virtual environment with the following commands: git clone https://github.com/mschouler/aero-optim.git cd aero-optim python3 -m venv .venv source .venv/bin/activate pip install -r requirements.txt pip install -e . Warning The virtual environment must be sourced every time a new terminal is launched! Note So far, the framework was only installed and tested on MacOS and Linux platforms.","title":"Quick Installation"},{"location":"#first-execution","text":"The framework was designed to automate aerodynamic optimization which, in this case, consists in: 1) deforming a baseline geometry, 2) generating its associated mesh, 3) performing a CFD computation, as many times as required to obtain a geometry maximizing/minimizing certain quantities of interest (QoIs). Although the chaining of these steps is performed under the supervision of main_optim.py , the three subscripts presented below were introduced to facilitate each step's individual evaluation:","title":"First Execution"},{"location":"#first-ffd-auto_ffdpy","text":"This script performs one or multiple FFD of the geometry passed as its input argument. For instance: # from aero-optim to naca_base cd examples/NACA12/naca_base ffd -f ../data/naca12.dat -nc 2 -d \"0. 0. 1. 1.\" will yield the figure below: where the deformation vector is $$[D_{10}, D_{20}, D_{11}, D_{21}] = [0., 0., 1., 1.]$$ in lattice unit (see FFD ).","title":"First FFD: auto_ffd.py"},{"location":"#first-mesh-auto_gmshpy","text":"This script generates a simple mesh parameterized according to its associated configuration file. For instance: # from aero-optim to naca_base cd examples/NACA12/naca_base mesh --config = naca_base.json # left figure cd ../naca_block mesh --config = naca_block.json # right figure will generate the figures below:","title":"First Mesh: auto_gmsh.py"},{"location":"#first-simulation-auto_simulatorpy","text":"This script performs a single simulation according to its associated configuration file and mesh. For instance: # from aero-optim to naca_base cd examples/NACA12/naca_base mesh -c naca_base.json simulator -c naca_base.json -f output/naca_base.mesh will run a Wolf simulation provided that the user has access to the solver and that they have properly specified the path to the executable: INFO:aero_optim.simulator.simulator:g0, c0 converged in 533 it. INFO:aero_optim.simulator.simulator:last values: ResTot CD CL ResCD ResCL x y Cp 1 .799346e-08 0 .152689 0 .358267 7 .271155e-16 2 .169212e-15 NaN NaN NaN >> simulation finished after 5 .0141987800598145 seconds The printed quantities correspond to the last row of the dataframe built by post-processing the simulation outputs as indicated in the \"post_process\" entry of the configuration file. The NaNs correspond to missing values due to the varying size of the extracted data. Warning In order for the command to pass, don't forget to fix the exec_cmd executable path in naca_base.json . A zoomed view of the solution mach field plotted with vizir4 and the following command is given below: # from naca_base /path/to/vizir -in output/WOLF/wolf_g0_c0/naca_base.mesh -sol output/WOLF/wolf_g0_c0/mach.solb Note As of 2024, Wolf is not open-source and may not be available to the user. Customization guidelines on how to adapt any part of the framework such as the Simulator are given in the Customization tab.","title":"First Simulation: auto_simulator.py"},{"location":"#first-optimization-main_optimpy","text":"This script orchestrates an optimization execution given the configuration parameters. For instance, naca_base.json and the command below executes a single iteration of the Particle Swarm Optimization algorithm of inspyred with 5 candidates and 8 variables of design sampled in [-0.5, 0.5] (in lattice units): # from aero-optim to naca_base cd examples / NACA12 / naca_base optim - c naca_base . json -- inspyred Warning Although inspyred considers the first generation as the 0th and allows to use max_generations=0 , pymoo does not and max_generations cannot be less than 1. Tip In the configuration file, the budget entry corresponds to the number of simulation executed concurrently. It should hence be adapted to the amount of resources available to the user.","title":"First Optimization: main_optim.py"},{"location":"coverage/","text":"Coverage Report ============================= test session starts ============================== platform linux -- Python 3 .13.3, pytest-8.3.5, pluggy-1.5.0 rootdir: /home/runner/work/aero-optim/aero-optim configfile: pyproject.toml plugins: cov-6.1.1 collected 12 items tests/test_ffd.py .... [ 33 % ] tests/test_generator.py .. [ 50 % ] tests/test_inspyred_optimizer.py . [ 58 % ] tests/test_mesh.py .. [ 75 % ] tests/test_pymoo_optimizer.py . [ 83 % ] tests/test_simulator.py .. [ 100 % ] =============================== warnings summary =============================== tests/test_pymoo_optimizer.py::test_pymoo_optimizer tests/test_pymoo_optimizer.py::test_pymoo_optimizer tests/test_pymoo_optimizer.py::test_pymoo_optimizer tests/test_pymoo_optimizer.py::test_pymoo_optimizer tests/test_pymoo_optimizer.py::test_pymoo_optimizer tests/test_pymoo_optimizer.py::test_pymoo_optimizer tests/test_pymoo_optimizer.py::test_pymoo_optimizer tests/test_pymoo_optimizer.py::test_pymoo_optimizer /opt/hostedtoolcache/Python/3.13.3/x64/lib/python3.13/site-packages/pymoo/core/individual.py:616: DeprecationWarning: The `` feasible `` property for `` pymoo.core.individual.Individual `` is deprecated if hasattr ( self, key ) : tests/test_pymoo_optimizer.py::test_pymoo_optimizer tests/test_pymoo_optimizer.py::test_pymoo_optimizer tests/test_pymoo_optimizer.py::test_pymoo_optimizer tests/test_pymoo_optimizer.py::test_pymoo_optimizer tests/test_pymoo_optimizer.py::test_pymoo_optimizer tests/test_pymoo_optimizer.py::test_pymoo_optimizer tests/test_pymoo_optimizer.py::test_pymoo_optimizer tests/test_pymoo_optimizer.py::test_pymoo_optimizer /opt/hostedtoolcache/Python/3.13.3/x64/lib/python3.13/site-packages/pymoo/core/individual.py:617: DeprecationWarning: The `` feasible `` property for `` pymoo.core.individual.Individual `` is deprecated v = getattr ( self, key ) -- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html ================================ tests coverage ================================ _______________ coverage: platform linux, python 3 .13.3-final-0 ________________ Name Stmts Miss Cover ------------------------------------------------------------ aero_optim/__init__.py 0 0 100 % aero_optim/ffd/ffd.py 106 42 60 % aero_optim/geom.py 146 127 13 % aero_optim/mesh/cascade_mesh.py 209 195 7 % aero_optim/mesh/mesh.py 331 206 38 % aero_optim/mesh/naca_base_mesh.py 90 15 83 % aero_optim/mesh/naca_block_mesh.py 86 0 100 % aero_optim/optim/generator.py 24 1 96 % aero_optim/optim/inspyred_optimizer.py 66 34 48 % aero_optim/optim/optimizer.py 360 198 45 % aero_optim/optim/pymoo_optimizer.py 107 62 42 % aero_optim/simulator/simulator.py 161 37 77 % aero_optim/utils.py 196 132 33 % ------------------------------------------------------------ TOTAL 1882 1049 44 % ======================= 12 passed, 16 warnings in 13 .35s =======================","title":"Coverage Report"},{"location":"coverage/#coverage-report","text":"============================= test session starts ============================== platform linux -- Python 3 .13.3, pytest-8.3.5, pluggy-1.5.0 rootdir: /home/runner/work/aero-optim/aero-optim configfile: pyproject.toml plugins: cov-6.1.1 collected 12 items tests/test_ffd.py .... [ 33 % ] tests/test_generator.py .. [ 50 % ] tests/test_inspyred_optimizer.py . [ 58 % ] tests/test_mesh.py .. [ 75 % ] tests/test_pymoo_optimizer.py . [ 83 % ] tests/test_simulator.py .. [ 100 % ] =============================== warnings summary =============================== tests/test_pymoo_optimizer.py::test_pymoo_optimizer tests/test_pymoo_optimizer.py::test_pymoo_optimizer tests/test_pymoo_optimizer.py::test_pymoo_optimizer tests/test_pymoo_optimizer.py::test_pymoo_optimizer tests/test_pymoo_optimizer.py::test_pymoo_optimizer tests/test_pymoo_optimizer.py::test_pymoo_optimizer tests/test_pymoo_optimizer.py::test_pymoo_optimizer tests/test_pymoo_optimizer.py::test_pymoo_optimizer /opt/hostedtoolcache/Python/3.13.3/x64/lib/python3.13/site-packages/pymoo/core/individual.py:616: DeprecationWarning: The `` feasible `` property for `` pymoo.core.individual.Individual `` is deprecated if hasattr ( self, key ) : tests/test_pymoo_optimizer.py::test_pymoo_optimizer tests/test_pymoo_optimizer.py::test_pymoo_optimizer tests/test_pymoo_optimizer.py::test_pymoo_optimizer tests/test_pymoo_optimizer.py::test_pymoo_optimizer tests/test_pymoo_optimizer.py::test_pymoo_optimizer tests/test_pymoo_optimizer.py::test_pymoo_optimizer tests/test_pymoo_optimizer.py::test_pymoo_optimizer tests/test_pymoo_optimizer.py::test_pymoo_optimizer /opt/hostedtoolcache/Python/3.13.3/x64/lib/python3.13/site-packages/pymoo/core/individual.py:617: DeprecationWarning: The `` feasible `` property for `` pymoo.core.individual.Individual `` is deprecated v = getattr ( self, key ) -- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html ================================ tests coverage ================================ _______________ coverage: platform linux, python 3 .13.3-final-0 ________________ Name Stmts Miss Cover ------------------------------------------------------------ aero_optim/__init__.py 0 0 100 % aero_optim/ffd/ffd.py 106 42 60 % aero_optim/geom.py 146 127 13 % aero_optim/mesh/cascade_mesh.py 209 195 7 % aero_optim/mesh/mesh.py 331 206 38 % aero_optim/mesh/naca_base_mesh.py 90 15 83 % aero_optim/mesh/naca_block_mesh.py 86 0 100 % aero_optim/optim/generator.py 24 1 96 % aero_optim/optim/inspyred_optimizer.py 66 34 48 % aero_optim/optim/optimizer.py 360 198 45 % aero_optim/optim/pymoo_optimizer.py 107 62 42 % aero_optim/simulator/simulator.py 161 37 77 % aero_optim/utils.py 196 132 33 % ------------------------------------------------------------ TOTAL 1882 1049 44 % ======================= 12 passed, 16 warnings in 13 .35s =======================","title":"Coverage Report"},{"location":"dev_ffd/","text":"FFD Source Code ffd.ffd.Deform Bases: ABC This class implements an abstract Deform class. Source code in aero_optim/ffd/ffd.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 class Deform ( ABC ): \"\"\" This class implements an abstract Deform class. \"\"\" def __init__ ( self , dat_file : str , ncontrol : int , header : int = 2 , scale : float = 1 , ** kwargs ): \"\"\" Instantiates the abstract Deform object. **Input** - dat_file (str): path to input_geometry.dat. - ncontrol (int): the number of control points. - header (int): the number of header lines in dat_file. - scale (float): the geometry scaling factor **Inner** - pts (np.ndarray): the geometry coordinates in the original referential. pts = [[x0, y0, z0], [x1, y1, z1], ..., [xN, yN, zN]] where N is the number of points describing the geometry and (z0, ..., zN) are null or identical. \"\"\" self . dat_file : str = dat_file self . pts : np . ndarray = np . array ( from_dat ( self . dat_file , header , scale )) self . ncontrol = ncontrol def write_ffd ( self , profile : np . ndarray , Delta : np . ndarray , outdir : str , gid : int = 0 , cid : int = 0 ) -> str : \"\"\" **Writes** the deformed geometry to file and **returns** /path/to/outdir/outfile. - profile (np.ndarray): the deformed geometry coordinates to be written to outfile. - Delta (np.ndarray): the deformation vector. - outdir (str): the output directory (it is to be combined with outfile). \"\"\" outfile = f \" { self . dat_file . split ( '/' )[ - 1 ][: - 4 ] } _g { gid } _c { cid } .dat\" check_dir ( outdir ) logger . info ( f \"write profile g { gid } c { cid } as { outfile } to { outdir } \" ) np . savetxt ( os . path . join ( outdir , outfile ), profile , header = f \"Deformed profile { outfile } \\n Delta= { [ d for d in Delta ] } \" ) return os . path . join ( outdir , outfile ) @abstractmethod def apply_ffd ( self , Delta : np . ndarray ) -> np . ndarray : \"\"\" Returns a deformed profile. \"\"\" __init__ ( dat_file : str , ncontrol : int , header : int = 2 , scale : float = 1 , ** kwargs ) Instantiates the abstract Deform object. Input dat_file (str): path to input_geometry.dat. ncontrol (int): the number of control points. header (int): the number of header lines in dat_file. scale (float): the geometry scaling factor Inner pts (np.ndarray): the geometry coordinates in the original referential. pts = [[x0, y0, z0], [x1, y1, z1], ..., [xN, yN, zN]] where N is the number of points describing the geometry and (z0, ..., zN) are null or identical. Source code in aero_optim/ffd/ffd.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def __init__ ( self , dat_file : str , ncontrol : int , header : int = 2 , scale : float = 1 , ** kwargs ): \"\"\" Instantiates the abstract Deform object. **Input** - dat_file (str): path to input_geometry.dat. - ncontrol (int): the number of control points. - header (int): the number of header lines in dat_file. - scale (float): the geometry scaling factor **Inner** - pts (np.ndarray): the geometry coordinates in the original referential. pts = [[x0, y0, z0], [x1, y1, z1], ..., [xN, yN, zN]] where N is the number of points describing the geometry and (z0, ..., zN) are null or identical. \"\"\" self . dat_file : str = dat_file self . pts : np . ndarray = np . array ( from_dat ( self . dat_file , header , scale )) self . ncontrol = ncontrol apply_ffd ( Delta : np . ndarray ) -> np . ndarray abstractmethod Returns a deformed profile. Source code in aero_optim/ffd/ffd.py 64 65 66 67 68 @abstractmethod def apply_ffd ( self , Delta : np . ndarray ) -> np . ndarray : \"\"\" Returns a deformed profile. \"\"\" write_ffd ( profile : np . ndarray , Delta : np . ndarray , outdir : str , gid : int = 0 , cid : int = 0 ) -> str Writes the deformed geometry to file and returns /path/to/outdir/outfile. profile (np.ndarray): the deformed geometry coordinates to be written to outfile. Delta (np.ndarray): the deformation vector. outdir (str): the output directory (it is to be combined with outfile). Source code in aero_optim/ffd/ffd.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def write_ffd ( self , profile : np . ndarray , Delta : np . ndarray , outdir : str , gid : int = 0 , cid : int = 0 ) -> str : \"\"\" **Writes** the deformed geometry to file and **returns** /path/to/outdir/outfile. - profile (np.ndarray): the deformed geometry coordinates to be written to outfile. - Delta (np.ndarray): the deformation vector. - outdir (str): the output directory (it is to be combined with outfile). \"\"\" outfile = f \" { self . dat_file . split ( '/' )[ - 1 ][: - 4 ] } _g { gid } _c { cid } .dat\" check_dir ( outdir ) logger . info ( f \"write profile g { gid } c { cid } as { outfile } to { outdir } \" ) np . savetxt ( os . path . join ( outdir , outfile ), profile , header = f \"Deformed profile { outfile } \\n Delta= { [ d for d in Delta ] } \" ) return os . path . join ( outdir , outfile ) ffd.ffd.FFD_2D Bases: Deform This class implements a simple 2D FFD algorithm with deformation /y only. For ncontrol = 2 i.e. 2 control points per side, the unperturbed lattice is: P01 ----- P11 ---- P21 ---- P31 | | | *************** | | **** profile **** | | *************** | | | P00 ----- P10 ---- P20 ---- P30 with (P00, P30, P01, P31) fixed if pad = (1, 1). Source code in aero_optim/ffd/ffd.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 class FFD_2D ( Deform ): \"\"\" This class implements a simple 2D FFD algorithm with deformation /y only. For ncontrol = 2 i.e. 2 control points per side, the unperturbed lattice is: P01 ----- P11 ---- P21 ---- P31 | | | *************** | | **** profile **** | | *************** | | | P00 ----- P10 ---- P20 ---- P30 with (P00, P30, P01, P31) fixed if pad = (1, 1). \"\"\" def __init__ ( self , dat_file : str , ncontrol : int , pad : tuple [ int , int ] = ( 1 , 1 ), ** kwargs ): \"\"\" Instantiates the FFD_2D object. **Input** - dat_file (str): path to input_geometry.dat. - ncontrol (int): the number of control points on each side of the lattice. - pad (tuple[int, int]): padding around the displacement vector. **Inner** - pts (np.ndarray): the geometry coordinates in the original referential. pts = [[x0, y0, z0], [x1, y1, z1], ..., [xN, yN, zN]] where N is the number of points describing the geometry and (z0, ..., zN) are null or identical. - L (int): the number of control points in the x direction of each side of the lattice. - M (int): the number of control points in the y direction of each side of the lattice. - lat_pts (np.ndarray): the geometry coordinates in the lattice referential. \"\"\" super () . __init__ ( dat_file , ncontrol , ** kwargs ) assert pad in [( 0 , 0 ), ( 1 , 1 ), ( 0 , 1 ), ( 1 , 0 )], f \"wrong padding: { pad } \" self . pad : tuple [ int , int ] = pad self . L : int = ncontrol - 1 + sum ( pad ) self . M : int = 1 self . build_lattice () self . lat_pts : np . ndarray = self . to_lat ( self . pts ) def build_lattice ( self ): \"\"\" **Builds** a rectangle lattice with x1 as its origin. \"\"\" epsilon = 0. self . min_x = np . min ( self . pts , axis = 0 )[ 0 ] - epsilon self . max_x = np . max ( self . pts , axis = 0 )[ 0 ] + epsilon self . min_y = np . min ( self . pts , axis = 0 )[ 1 ] - epsilon self . max_y = np . max ( self . pts , axis = 0 )[ 1 ] + epsilon self . x1 = np . array ([ self . min_x , self . min_y ]) def to_lat ( self , pts : np . ndarray ) -> np . ndarray : \"\"\" **Returns** the coordinates projected in the lattices referential. - pts (np.ndarray): the geometry coordinates in the original referential. \"\"\" if len ( pts . shape ) == 1 : return np . array ([( pts [ 0 ] - self . min_x ) / ( self . max_x - self . min_x ), ( pts [ 1 ] - self . min_y ) / ( self . max_y - self . min_y )]) return np . column_stack ((( pts [:, 0 ] - self . min_x ) / ( self . max_x - self . min_x ), ( pts [:, 1 ] - self . min_y ) / ( self . max_y - self . min_y ))) def from_lat ( self , pts : np . ndarray ) -> np . ndarray : \"\"\" **Returns** lattice coordinates back in the original referential. \"\"\" if len ( pts . shape ) == 1 : return np . array ([ pts [ 0 ] * ( self . max_x - self . min_x ) + self . min_x , pts [ 1 ] * ( self . max_y - self . min_y ) + self . min_y ]) return np . column_stack (( pts [:, 0 ] * ( self . max_x - self . min_x ) + self . min_x , pts [:, 1 ] * ( self . max_y - self . min_y ) + self . min_y )) def dPij ( self , i : int , j : int , Delta : np . ndarray ) -> np . ndarray : \"\"\" **Returns** y-oriented displacement coordinates dPij from a 1D array Delta. \"\"\" return np . array ([ 0. , Delta [ i + j * ( self . L + 1 )]]) def pad_Delta ( self , Delta : np . ndarray ) -> np . ndarray : \"\"\" **Returns** padded Delta = [0, dP10, dP20, ..., dP{nc}0, 0, 0, dP11, dP21, ..., dP{nc}1, 0] with nc = ncontrol. - Delta (np.ndarray): the non-padded deformation vector. \"\"\" return np . concatenate (( np . pad ( Delta [: self . ncontrol ], self . pad ), np . pad ( Delta [ self . ncontrol :], self . pad ))) def apply_ffd ( self , Delta : np . ndarray ) -> np . ndarray : \"\"\" **Returns** a new profile resulting from a perturbation Delta in the original referential. - Delta (np.ndarray): the deformation vector.</br> Delta = [dP10, dP20, ..., dP{nc}0, dP11, dP21, ..., dP{nc}1] with nc = ncontrol. \"\"\" assert len ( Delta ) == 2 * self . ncontrol , f \"len(Delta) { len ( Delta ) } != { 2 * self . ncontrol } \" Delta = self . pad_Delta ( Delta ) new_profile = [] for x in self . lat_pts : x_new = x . copy () for ll in range ( self . L + 1 ): for m in range ( self . M + 1 ): x_new += ( math . comb ( self . L , ll ) * ( 1 - x [ 0 ]) ** ( self . L - ll ) * math . comb ( self . M , m ) * ( 1 - x [ 1 ]) ** ( self . M - m ) * x [ 0 ] ** ll * x [ 1 ] ** m * self . dPij ( ll , m , Delta )) new_profile . append ([ x_new ]) return self . from_lat ( np . reshape ( new_profile , ( - 1 , 2 ))) __init__ ( dat_file : str , ncontrol : int , pad : tuple [ int , int ] = ( 1 , 1 ), ** kwargs ) Instantiates the FFD_2D object. Input dat_file (str): path to input_geometry.dat. ncontrol (int): the number of control points on each side of the lattice. pad (tuple[int, int]): padding around the displacement vector. Inner pts (np.ndarray): the geometry coordinates in the original referential. pts = [[x0, y0, z0], [x1, y1, z1], ..., [xN, yN, zN]] where N is the number of points describing the geometry and (z0, ..., zN) are null or identical. L (int): the number of control points in the x direction of each side of the lattice. M (int): the number of control points in the y direction of each side of the lattice. lat_pts (np.ndarray): the geometry coordinates in the lattice referential. Source code in aero_optim/ffd/ffd.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 def __init__ ( self , dat_file : str , ncontrol : int , pad : tuple [ int , int ] = ( 1 , 1 ), ** kwargs ): \"\"\" Instantiates the FFD_2D object. **Input** - dat_file (str): path to input_geometry.dat. - ncontrol (int): the number of control points on each side of the lattice. - pad (tuple[int, int]): padding around the displacement vector. **Inner** - pts (np.ndarray): the geometry coordinates in the original referential. pts = [[x0, y0, z0], [x1, y1, z1], ..., [xN, yN, zN]] where N is the number of points describing the geometry and (z0, ..., zN) are null or identical. - L (int): the number of control points in the x direction of each side of the lattice. - M (int): the number of control points in the y direction of each side of the lattice. - lat_pts (np.ndarray): the geometry coordinates in the lattice referential. \"\"\" super () . __init__ ( dat_file , ncontrol , ** kwargs ) assert pad in [( 0 , 0 ), ( 1 , 1 ), ( 0 , 1 ), ( 1 , 0 )], f \"wrong padding: { pad } \" self . pad : tuple [ int , int ] = pad self . L : int = ncontrol - 1 + sum ( pad ) self . M : int = 1 self . build_lattice () self . lat_pts : np . ndarray = self . to_lat ( self . pts ) apply_ffd ( Delta : np . ndarray ) -> np . ndarray Returns a new profile resulting from a perturbation Delta in the original referential. Delta (np.ndarray): the deformation vector. Delta = [dP10, dP20, ..., dP{nc}0, dP11, dP21, ..., dP{nc}1] with nc = ncontrol. Source code in aero_optim/ffd/ffd.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 def apply_ffd ( self , Delta : np . ndarray ) -> np . ndarray : \"\"\" **Returns** a new profile resulting from a perturbation Delta in the original referential. - Delta (np.ndarray): the deformation vector.</br> Delta = [dP10, dP20, ..., dP{nc}0, dP11, dP21, ..., dP{nc}1] with nc = ncontrol. \"\"\" assert len ( Delta ) == 2 * self . ncontrol , f \"len(Delta) { len ( Delta ) } != { 2 * self . ncontrol } \" Delta = self . pad_Delta ( Delta ) new_profile = [] for x in self . lat_pts : x_new = x . copy () for ll in range ( self . L + 1 ): for m in range ( self . M + 1 ): x_new += ( math . comb ( self . L , ll ) * ( 1 - x [ 0 ]) ** ( self . L - ll ) * math . comb ( self . M , m ) * ( 1 - x [ 1 ]) ** ( self . M - m ) * x [ 0 ] ** ll * x [ 1 ] ** m * self . dPij ( ll , m , Delta )) new_profile . append ([ x_new ]) return self . from_lat ( np . reshape ( new_profile , ( - 1 , 2 ))) build_lattice () Builds a rectangle lattice with x1 as its origin. Source code in aero_optim/ffd/ffd.py 120 121 122 123 124 125 126 127 128 129 def build_lattice ( self ): \"\"\" **Builds** a rectangle lattice with x1 as its origin. \"\"\" epsilon = 0. self . min_x = np . min ( self . pts , axis = 0 )[ 0 ] - epsilon self . max_x = np . max ( self . pts , axis = 0 )[ 0 ] + epsilon self . min_y = np . min ( self . pts , axis = 0 )[ 1 ] - epsilon self . max_y = np . max ( self . pts , axis = 0 )[ 1 ] + epsilon self . x1 = np . array ([ self . min_x , self . min_y ]) dPij ( i : int , j : int , Delta : np . ndarray ) -> np . ndarray Returns y-oriented displacement coordinates dPij from a 1D array Delta. Source code in aero_optim/ffd/ffd.py 153 154 155 156 157 def dPij ( self , i : int , j : int , Delta : np . ndarray ) -> np . ndarray : \"\"\" **Returns** y-oriented displacement coordinates dPij from a 1D array Delta. \"\"\" return np . array ([ 0. , Delta [ i + j * ( self . L + 1 )]]) from_lat ( pts : np . ndarray ) -> np . ndarray Returns lattice coordinates back in the original referential. Source code in aero_optim/ffd/ffd.py 143 144 145 146 147 148 149 150 151 def from_lat ( self , pts : np . ndarray ) -> np . ndarray : \"\"\" **Returns** lattice coordinates back in the original referential. \"\"\" if len ( pts . shape ) == 1 : return np . array ([ pts [ 0 ] * ( self . max_x - self . min_x ) + self . min_x , pts [ 1 ] * ( self . max_y - self . min_y ) + self . min_y ]) return np . column_stack (( pts [:, 0 ] * ( self . max_x - self . min_x ) + self . min_x , pts [:, 1 ] * ( self . max_y - self . min_y ) + self . min_y )) pad_Delta ( Delta : np . ndarray ) -> np . ndarray Returns padded Delta = [0, dP10, dP20, ..., dP{nc}0, 0, 0, dP11, dP21, ..., dP{nc}1, 0] with nc = ncontrol. Delta (np.ndarray): the non-padded deformation vector. Source code in aero_optim/ffd/ffd.py 159 160 161 162 163 164 165 166 167 def pad_Delta ( self , Delta : np . ndarray ) -> np . ndarray : \"\"\" **Returns** padded Delta = [0, dP10, dP20, ..., dP{nc}0, 0, 0, dP11, dP21, ..., dP{nc}1, 0] with nc = ncontrol. - Delta (np.ndarray): the non-padded deformation vector. \"\"\" return np . concatenate (( np . pad ( Delta [: self . ncontrol ], self . pad ), np . pad ( Delta [ self . ncontrol :], self . pad ))) to_lat ( pts : np . ndarray ) -> np . ndarray Returns the coordinates projected in the lattices referential. pts (np.ndarray): the geometry coordinates in the original referential. Source code in aero_optim/ffd/ffd.py 131 132 133 134 135 136 137 138 139 140 141 def to_lat ( self , pts : np . ndarray ) -> np . ndarray : \"\"\" **Returns** the coordinates projected in the lattices referential. - pts (np.ndarray): the geometry coordinates in the original referential. \"\"\" if len ( pts . shape ) == 1 : return np . array ([( pts [ 0 ] - self . min_x ) / ( self . max_x - self . min_x ), ( pts [ 1 ] - self . min_y ) / ( self . max_y - self . min_y )]) return np . column_stack ((( pts [:, 0 ] - self . min_x ) / ( self . max_x - self . min_x ), ( pts [:, 1 ] - self . min_y ) / ( self . max_y - self . min_y ))) ffd.ffd.FFD_POD_2D Bases: Deform This class implements a 2D FFD-POD coupled class. Source code in aero_optim/ffd/ffd.py 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 class FFD_POD_2D ( Deform ): \"\"\" This class implements a 2D FFD-POD coupled class. \"\"\" def __init__ ( self , dat_file : str , pod_ncontrol : int , ffd_ncontrol : int , ffd_dataset_size : int , ffd_bound : tuple [ Any ], seed : int = 123 , ** kwargs ): \"\"\" Instantiates the FFD_POD_2D object. **Input** - dat_file (str): path to input_geometry.dat. - pod_ncontrol (int): the number of POD control points. - ffd_ncontrol (int): the number of FFD control points. - ffd_dataset_size (int): the number of ffd profiles in the POD dataset. - ffd_bound (tuple[Any]): the ffd dataset deformation boundaries. - seed (int): seed for the POD dataset sampling. - kwargs (dict): additional options to be passed to the FFD_2D inner object. **Inner** - pts (np.ndarray): the geometry coordinates in the original referential. pts = [[x0, y0, z0], [x1, y1, z1], ..., [xN, yN, zN]] where N is the number of points describing the geometry and (z0, ..., zN) are null or identical. - ffd (FFD_2D): the ffd object used to build the POD dataset. \"\"\" super () . __init__ ( dat_file , ffd_ncontrol , ** kwargs ) self . pod_ncontrol = pod_ncontrol self . ffd_ncontrol = ffd_ncontrol self . ffd_dataset_size = ffd_dataset_size self . ffd = FFD_2D ( dat_file , ffd_ncontrol // 2 , ** kwargs ) self . ffd_bound = ffd_bound self . seed = seed self . build_pod_dataset () def build_pod_dataset ( self ): sampler = qmc . LatinHypercube ( d = self . ffd_ncontrol , seed = self . seed ) sample = sampler . random ( n = self . ffd_dataset_size ) scaled_sample = qmc . scale ( sample , * self . ffd_bound ) profiles = [] for Delta in scaled_sample : profiles . append ( self . ffd . apply_ffd ( Delta )) self . S = np . stack ([ p [:, - 1 ] for p in profiles ] , axis = 1 ) self . S_mean = 1 / len ( profiles ) * np . sum ( self . S , axis = 1 ) self . F = self . S [:, :] - self . S_mean [:, None ] self . C = np . matmul ( np . transpose ( self . F ), self . F ) self . eigenvalues , self . eigenvectors = np . linalg . eigh ( self . C ) self . phi = np . matmul ( self . F , self . eigenvectors ) nmode = self . pod_ncontrol self . phi_tilde = self . phi [:, - nmode :] self . V_tilde_inv = np . linalg . inv ( self . eigenvectors )[ - nmode :, :] self . D_tilde = self . S_mean [:, None ] + np . matmul ( self . phi_tilde , self . V_tilde_inv ) def apply_ffd ( self , Delta : np . ndarray ) -> np . ndarray : return np . column_stack ( ( self . ffd . pts [:, 0 ], self . S_mean + np . sum ( self . phi_tilde * Delta , axis = 1 )) ) def get_bound ( self ) -> tuple [ list [ float ], list [ float ]]: l_bound = [ min ( v ) for v in self . V_tilde_inv ] u_bound = [ max ( v ) for v in self . V_tilde_inv ] return l_bound , u_bound __init__ ( dat_file : str , pod_ncontrol : int , ffd_ncontrol : int , ffd_dataset_size : int , ffd_bound : tuple [ Any ], seed : int = 123 , ** kwargs ) Instantiates the FFD_POD_2D object. Input dat_file (str): path to input_geometry.dat. pod_ncontrol (int): the number of POD control points. ffd_ncontrol (int): the number of FFD control points. ffd_dataset_size (int): the number of ffd profiles in the POD dataset. ffd_bound (tuple[Any]): the ffd dataset deformation boundaries. seed (int): seed for the POD dataset sampling. kwargs (dict): additional options to be passed to the FFD_2D inner object. Inner pts (np.ndarray): the geometry coordinates in the original referential. pts = [[x0, y0, z0], [x1, y1, z1], ..., [xN, yN, zN]] where N is the number of points describing the geometry and (z0, ..., zN) are null or identical. ffd (FFD_2D): the ffd object used to build the POD dataset. Source code in aero_optim/ffd/ffd.py 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def __init__ ( self , dat_file : str , pod_ncontrol : int , ffd_ncontrol : int , ffd_dataset_size : int , ffd_bound : tuple [ Any ], seed : int = 123 , ** kwargs ): \"\"\" Instantiates the FFD_POD_2D object. **Input** - dat_file (str): path to input_geometry.dat. - pod_ncontrol (int): the number of POD control points. - ffd_ncontrol (int): the number of FFD control points. - ffd_dataset_size (int): the number of ffd profiles in the POD dataset. - ffd_bound (tuple[Any]): the ffd dataset deformation boundaries. - seed (int): seed for the POD dataset sampling. - kwargs (dict): additional options to be passed to the FFD_2D inner object. **Inner** - pts (np.ndarray): the geometry coordinates in the original referential. pts = [[x0, y0, z0], [x1, y1, z1], ..., [xN, yN, zN]] where N is the number of points describing the geometry and (z0, ..., zN) are null or identical. - ffd (FFD_2D): the ffd object used to build the POD dataset. \"\"\" super () . __init__ ( dat_file , ffd_ncontrol , ** kwargs ) self . pod_ncontrol = pod_ncontrol self . ffd_ncontrol = ffd_ncontrol self . ffd_dataset_size = ffd_dataset_size self . ffd = FFD_2D ( dat_file , ffd_ncontrol // 2 , ** kwargs ) self . ffd_bound = ffd_bound self . seed = seed self . build_pod_dataset ()","title":"FFD Module"},{"location":"dev_ffd/#ffd-source-code","text":"","title":"FFD Source Code"},{"location":"dev_ffd/#ffd.ffd.Deform","text":"Bases: ABC This class implements an abstract Deform class. Source code in aero_optim/ffd/ffd.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 class Deform ( ABC ): \"\"\" This class implements an abstract Deform class. \"\"\" def __init__ ( self , dat_file : str , ncontrol : int , header : int = 2 , scale : float = 1 , ** kwargs ): \"\"\" Instantiates the abstract Deform object. **Input** - dat_file (str): path to input_geometry.dat. - ncontrol (int): the number of control points. - header (int): the number of header lines in dat_file. - scale (float): the geometry scaling factor **Inner** - pts (np.ndarray): the geometry coordinates in the original referential. pts = [[x0, y0, z0], [x1, y1, z1], ..., [xN, yN, zN]] where N is the number of points describing the geometry and (z0, ..., zN) are null or identical. \"\"\" self . dat_file : str = dat_file self . pts : np . ndarray = np . array ( from_dat ( self . dat_file , header , scale )) self . ncontrol = ncontrol def write_ffd ( self , profile : np . ndarray , Delta : np . ndarray , outdir : str , gid : int = 0 , cid : int = 0 ) -> str : \"\"\" **Writes** the deformed geometry to file and **returns** /path/to/outdir/outfile. - profile (np.ndarray): the deformed geometry coordinates to be written to outfile. - Delta (np.ndarray): the deformation vector. - outdir (str): the output directory (it is to be combined with outfile). \"\"\" outfile = f \" { self . dat_file . split ( '/' )[ - 1 ][: - 4 ] } _g { gid } _c { cid } .dat\" check_dir ( outdir ) logger . info ( f \"write profile g { gid } c { cid } as { outfile } to { outdir } \" ) np . savetxt ( os . path . join ( outdir , outfile ), profile , header = f \"Deformed profile { outfile } \\n Delta= { [ d for d in Delta ] } \" ) return os . path . join ( outdir , outfile ) @abstractmethod def apply_ffd ( self , Delta : np . ndarray ) -> np . ndarray : \"\"\" Returns a deformed profile. \"\"\"","title":"Deform"},{"location":"dev_ffd/#ffd.ffd.Deform.__init__","text":"Instantiates the abstract Deform object. Input dat_file (str): path to input_geometry.dat. ncontrol (int): the number of control points. header (int): the number of header lines in dat_file. scale (float): the geometry scaling factor Inner pts (np.ndarray): the geometry coordinates in the original referential. pts = [[x0, y0, z0], [x1, y1, z1], ..., [xN, yN, zN]] where N is the number of points describing the geometry and (z0, ..., zN) are null or identical. Source code in aero_optim/ffd/ffd.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def __init__ ( self , dat_file : str , ncontrol : int , header : int = 2 , scale : float = 1 , ** kwargs ): \"\"\" Instantiates the abstract Deform object. **Input** - dat_file (str): path to input_geometry.dat. - ncontrol (int): the number of control points. - header (int): the number of header lines in dat_file. - scale (float): the geometry scaling factor **Inner** - pts (np.ndarray): the geometry coordinates in the original referential. pts = [[x0, y0, z0], [x1, y1, z1], ..., [xN, yN, zN]] where N is the number of points describing the geometry and (z0, ..., zN) are null or identical. \"\"\" self . dat_file : str = dat_file self . pts : np . ndarray = np . array ( from_dat ( self . dat_file , header , scale )) self . ncontrol = ncontrol","title":"__init__"},{"location":"dev_ffd/#ffd.ffd.Deform.apply_ffd","text":"Returns a deformed profile. Source code in aero_optim/ffd/ffd.py 64 65 66 67 68 @abstractmethod def apply_ffd ( self , Delta : np . ndarray ) -> np . ndarray : \"\"\" Returns a deformed profile. \"\"\"","title":"apply_ffd"},{"location":"dev_ffd/#ffd.ffd.Deform.write_ffd","text":"Writes the deformed geometry to file and returns /path/to/outdir/outfile. profile (np.ndarray): the deformed geometry coordinates to be written to outfile. Delta (np.ndarray): the deformation vector. outdir (str): the output directory (it is to be combined with outfile). Source code in aero_optim/ffd/ffd.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def write_ffd ( self , profile : np . ndarray , Delta : np . ndarray , outdir : str , gid : int = 0 , cid : int = 0 ) -> str : \"\"\" **Writes** the deformed geometry to file and **returns** /path/to/outdir/outfile. - profile (np.ndarray): the deformed geometry coordinates to be written to outfile. - Delta (np.ndarray): the deformation vector. - outdir (str): the output directory (it is to be combined with outfile). \"\"\" outfile = f \" { self . dat_file . split ( '/' )[ - 1 ][: - 4 ] } _g { gid } _c { cid } .dat\" check_dir ( outdir ) logger . info ( f \"write profile g { gid } c { cid } as { outfile } to { outdir } \" ) np . savetxt ( os . path . join ( outdir , outfile ), profile , header = f \"Deformed profile { outfile } \\n Delta= { [ d for d in Delta ] } \" ) return os . path . join ( outdir , outfile )","title":"write_ffd"},{"location":"dev_ffd/#ffd.ffd.FFD_2D","text":"Bases: Deform This class implements a simple 2D FFD algorithm with deformation /y only. For ncontrol = 2 i.e. 2 control points per side, the unperturbed lattice is: P01 ----- P11 ---- P21 ---- P31 | | | *************** | | **** profile **** | | *************** | | | P00 ----- P10 ---- P20 ---- P30 with (P00, P30, P01, P31) fixed if pad = (1, 1). Source code in aero_optim/ffd/ffd.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 class FFD_2D ( Deform ): \"\"\" This class implements a simple 2D FFD algorithm with deformation /y only. For ncontrol = 2 i.e. 2 control points per side, the unperturbed lattice is: P01 ----- P11 ---- P21 ---- P31 | | | *************** | | **** profile **** | | *************** | | | P00 ----- P10 ---- P20 ---- P30 with (P00, P30, P01, P31) fixed if pad = (1, 1). \"\"\" def __init__ ( self , dat_file : str , ncontrol : int , pad : tuple [ int , int ] = ( 1 , 1 ), ** kwargs ): \"\"\" Instantiates the FFD_2D object. **Input** - dat_file (str): path to input_geometry.dat. - ncontrol (int): the number of control points on each side of the lattice. - pad (tuple[int, int]): padding around the displacement vector. **Inner** - pts (np.ndarray): the geometry coordinates in the original referential. pts = [[x0, y0, z0], [x1, y1, z1], ..., [xN, yN, zN]] where N is the number of points describing the geometry and (z0, ..., zN) are null or identical. - L (int): the number of control points in the x direction of each side of the lattice. - M (int): the number of control points in the y direction of each side of the lattice. - lat_pts (np.ndarray): the geometry coordinates in the lattice referential. \"\"\" super () . __init__ ( dat_file , ncontrol , ** kwargs ) assert pad in [( 0 , 0 ), ( 1 , 1 ), ( 0 , 1 ), ( 1 , 0 )], f \"wrong padding: { pad } \" self . pad : tuple [ int , int ] = pad self . L : int = ncontrol - 1 + sum ( pad ) self . M : int = 1 self . build_lattice () self . lat_pts : np . ndarray = self . to_lat ( self . pts ) def build_lattice ( self ): \"\"\" **Builds** a rectangle lattice with x1 as its origin. \"\"\" epsilon = 0. self . min_x = np . min ( self . pts , axis = 0 )[ 0 ] - epsilon self . max_x = np . max ( self . pts , axis = 0 )[ 0 ] + epsilon self . min_y = np . min ( self . pts , axis = 0 )[ 1 ] - epsilon self . max_y = np . max ( self . pts , axis = 0 )[ 1 ] + epsilon self . x1 = np . array ([ self . min_x , self . min_y ]) def to_lat ( self , pts : np . ndarray ) -> np . ndarray : \"\"\" **Returns** the coordinates projected in the lattices referential. - pts (np.ndarray): the geometry coordinates in the original referential. \"\"\" if len ( pts . shape ) == 1 : return np . array ([( pts [ 0 ] - self . min_x ) / ( self . max_x - self . min_x ), ( pts [ 1 ] - self . min_y ) / ( self . max_y - self . min_y )]) return np . column_stack ((( pts [:, 0 ] - self . min_x ) / ( self . max_x - self . min_x ), ( pts [:, 1 ] - self . min_y ) / ( self . max_y - self . min_y ))) def from_lat ( self , pts : np . ndarray ) -> np . ndarray : \"\"\" **Returns** lattice coordinates back in the original referential. \"\"\" if len ( pts . shape ) == 1 : return np . array ([ pts [ 0 ] * ( self . max_x - self . min_x ) + self . min_x , pts [ 1 ] * ( self . max_y - self . min_y ) + self . min_y ]) return np . column_stack (( pts [:, 0 ] * ( self . max_x - self . min_x ) + self . min_x , pts [:, 1 ] * ( self . max_y - self . min_y ) + self . min_y )) def dPij ( self , i : int , j : int , Delta : np . ndarray ) -> np . ndarray : \"\"\" **Returns** y-oriented displacement coordinates dPij from a 1D array Delta. \"\"\" return np . array ([ 0. , Delta [ i + j * ( self . L + 1 )]]) def pad_Delta ( self , Delta : np . ndarray ) -> np . ndarray : \"\"\" **Returns** padded Delta = [0, dP10, dP20, ..., dP{nc}0, 0, 0, dP11, dP21, ..., dP{nc}1, 0] with nc = ncontrol. - Delta (np.ndarray): the non-padded deformation vector. \"\"\" return np . concatenate (( np . pad ( Delta [: self . ncontrol ], self . pad ), np . pad ( Delta [ self . ncontrol :], self . pad ))) def apply_ffd ( self , Delta : np . ndarray ) -> np . ndarray : \"\"\" **Returns** a new profile resulting from a perturbation Delta in the original referential. - Delta (np.ndarray): the deformation vector.</br> Delta = [dP10, dP20, ..., dP{nc}0, dP11, dP21, ..., dP{nc}1] with nc = ncontrol. \"\"\" assert len ( Delta ) == 2 * self . ncontrol , f \"len(Delta) { len ( Delta ) } != { 2 * self . ncontrol } \" Delta = self . pad_Delta ( Delta ) new_profile = [] for x in self . lat_pts : x_new = x . copy () for ll in range ( self . L + 1 ): for m in range ( self . M + 1 ): x_new += ( math . comb ( self . L , ll ) * ( 1 - x [ 0 ]) ** ( self . L - ll ) * math . comb ( self . M , m ) * ( 1 - x [ 1 ]) ** ( self . M - m ) * x [ 0 ] ** ll * x [ 1 ] ** m * self . dPij ( ll , m , Delta )) new_profile . append ([ x_new ]) return self . from_lat ( np . reshape ( new_profile , ( - 1 , 2 )))","title":"FFD_2D"},{"location":"dev_ffd/#ffd.ffd.FFD_2D.__init__","text":"Instantiates the FFD_2D object. Input dat_file (str): path to input_geometry.dat. ncontrol (int): the number of control points on each side of the lattice. pad (tuple[int, int]): padding around the displacement vector. Inner pts (np.ndarray): the geometry coordinates in the original referential. pts = [[x0, y0, z0], [x1, y1, z1], ..., [xN, yN, zN]] where N is the number of points describing the geometry and (z0, ..., zN) are null or identical. L (int): the number of control points in the x direction of each side of the lattice. M (int): the number of control points in the y direction of each side of the lattice. lat_pts (np.ndarray): the geometry coordinates in the lattice referential. Source code in aero_optim/ffd/ffd.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 def __init__ ( self , dat_file : str , ncontrol : int , pad : tuple [ int , int ] = ( 1 , 1 ), ** kwargs ): \"\"\" Instantiates the FFD_2D object. **Input** - dat_file (str): path to input_geometry.dat. - ncontrol (int): the number of control points on each side of the lattice. - pad (tuple[int, int]): padding around the displacement vector. **Inner** - pts (np.ndarray): the geometry coordinates in the original referential. pts = [[x0, y0, z0], [x1, y1, z1], ..., [xN, yN, zN]] where N is the number of points describing the geometry and (z0, ..., zN) are null or identical. - L (int): the number of control points in the x direction of each side of the lattice. - M (int): the number of control points in the y direction of each side of the lattice. - lat_pts (np.ndarray): the geometry coordinates in the lattice referential. \"\"\" super () . __init__ ( dat_file , ncontrol , ** kwargs ) assert pad in [( 0 , 0 ), ( 1 , 1 ), ( 0 , 1 ), ( 1 , 0 )], f \"wrong padding: { pad } \" self . pad : tuple [ int , int ] = pad self . L : int = ncontrol - 1 + sum ( pad ) self . M : int = 1 self . build_lattice () self . lat_pts : np . ndarray = self . to_lat ( self . pts )","title":"__init__"},{"location":"dev_ffd/#ffd.ffd.FFD_2D.apply_ffd","text":"Returns a new profile resulting from a perturbation Delta in the original referential. Delta (np.ndarray): the deformation vector. Delta = [dP10, dP20, ..., dP{nc}0, dP11, dP21, ..., dP{nc}1] with nc = ncontrol. Source code in aero_optim/ffd/ffd.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 def apply_ffd ( self , Delta : np . ndarray ) -> np . ndarray : \"\"\" **Returns** a new profile resulting from a perturbation Delta in the original referential. - Delta (np.ndarray): the deformation vector.</br> Delta = [dP10, dP20, ..., dP{nc}0, dP11, dP21, ..., dP{nc}1] with nc = ncontrol. \"\"\" assert len ( Delta ) == 2 * self . ncontrol , f \"len(Delta) { len ( Delta ) } != { 2 * self . ncontrol } \" Delta = self . pad_Delta ( Delta ) new_profile = [] for x in self . lat_pts : x_new = x . copy () for ll in range ( self . L + 1 ): for m in range ( self . M + 1 ): x_new += ( math . comb ( self . L , ll ) * ( 1 - x [ 0 ]) ** ( self . L - ll ) * math . comb ( self . M , m ) * ( 1 - x [ 1 ]) ** ( self . M - m ) * x [ 0 ] ** ll * x [ 1 ] ** m * self . dPij ( ll , m , Delta )) new_profile . append ([ x_new ]) return self . from_lat ( np . reshape ( new_profile , ( - 1 , 2 )))","title":"apply_ffd"},{"location":"dev_ffd/#ffd.ffd.FFD_2D.build_lattice","text":"Builds a rectangle lattice with x1 as its origin. Source code in aero_optim/ffd/ffd.py 120 121 122 123 124 125 126 127 128 129 def build_lattice ( self ): \"\"\" **Builds** a rectangle lattice with x1 as its origin. \"\"\" epsilon = 0. self . min_x = np . min ( self . pts , axis = 0 )[ 0 ] - epsilon self . max_x = np . max ( self . pts , axis = 0 )[ 0 ] + epsilon self . min_y = np . min ( self . pts , axis = 0 )[ 1 ] - epsilon self . max_y = np . max ( self . pts , axis = 0 )[ 1 ] + epsilon self . x1 = np . array ([ self . min_x , self . min_y ])","title":"build_lattice"},{"location":"dev_ffd/#ffd.ffd.FFD_2D.dPij","text":"Returns y-oriented displacement coordinates dPij from a 1D array Delta. Source code in aero_optim/ffd/ffd.py 153 154 155 156 157 def dPij ( self , i : int , j : int , Delta : np . ndarray ) -> np . ndarray : \"\"\" **Returns** y-oriented displacement coordinates dPij from a 1D array Delta. \"\"\" return np . array ([ 0. , Delta [ i + j * ( self . L + 1 )]])","title":"dPij"},{"location":"dev_ffd/#ffd.ffd.FFD_2D.from_lat","text":"Returns lattice coordinates back in the original referential. Source code in aero_optim/ffd/ffd.py 143 144 145 146 147 148 149 150 151 def from_lat ( self , pts : np . ndarray ) -> np . ndarray : \"\"\" **Returns** lattice coordinates back in the original referential. \"\"\" if len ( pts . shape ) == 1 : return np . array ([ pts [ 0 ] * ( self . max_x - self . min_x ) + self . min_x , pts [ 1 ] * ( self . max_y - self . min_y ) + self . min_y ]) return np . column_stack (( pts [:, 0 ] * ( self . max_x - self . min_x ) + self . min_x , pts [:, 1 ] * ( self . max_y - self . min_y ) + self . min_y ))","title":"from_lat"},{"location":"dev_ffd/#ffd.ffd.FFD_2D.pad_Delta","text":"Returns padded Delta = [0, dP10, dP20, ..., dP{nc}0, 0, 0, dP11, dP21, ..., dP{nc}1, 0] with nc = ncontrol. Delta (np.ndarray): the non-padded deformation vector. Source code in aero_optim/ffd/ffd.py 159 160 161 162 163 164 165 166 167 def pad_Delta ( self , Delta : np . ndarray ) -> np . ndarray : \"\"\" **Returns** padded Delta = [0, dP10, dP20, ..., dP{nc}0, 0, 0, dP11, dP21, ..., dP{nc}1, 0] with nc = ncontrol. - Delta (np.ndarray): the non-padded deformation vector. \"\"\" return np . concatenate (( np . pad ( Delta [: self . ncontrol ], self . pad ), np . pad ( Delta [ self . ncontrol :], self . pad )))","title":"pad_Delta"},{"location":"dev_ffd/#ffd.ffd.FFD_2D.to_lat","text":"Returns the coordinates projected in the lattices referential. pts (np.ndarray): the geometry coordinates in the original referential. Source code in aero_optim/ffd/ffd.py 131 132 133 134 135 136 137 138 139 140 141 def to_lat ( self , pts : np . ndarray ) -> np . ndarray : \"\"\" **Returns** the coordinates projected in the lattices referential. - pts (np.ndarray): the geometry coordinates in the original referential. \"\"\" if len ( pts . shape ) == 1 : return np . array ([( pts [ 0 ] - self . min_x ) / ( self . max_x - self . min_x ), ( pts [ 1 ] - self . min_y ) / ( self . max_y - self . min_y )]) return np . column_stack ((( pts [:, 0 ] - self . min_x ) / ( self . max_x - self . min_x ), ( pts [:, 1 ] - self . min_y ) / ( self . max_y - self . min_y )))","title":"to_lat"},{"location":"dev_ffd/#ffd.ffd.FFD_POD_2D","text":"Bases: Deform This class implements a 2D FFD-POD coupled class. Source code in aero_optim/ffd/ffd.py 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 class FFD_POD_2D ( Deform ): \"\"\" This class implements a 2D FFD-POD coupled class. \"\"\" def __init__ ( self , dat_file : str , pod_ncontrol : int , ffd_ncontrol : int , ffd_dataset_size : int , ffd_bound : tuple [ Any ], seed : int = 123 , ** kwargs ): \"\"\" Instantiates the FFD_POD_2D object. **Input** - dat_file (str): path to input_geometry.dat. - pod_ncontrol (int): the number of POD control points. - ffd_ncontrol (int): the number of FFD control points. - ffd_dataset_size (int): the number of ffd profiles in the POD dataset. - ffd_bound (tuple[Any]): the ffd dataset deformation boundaries. - seed (int): seed for the POD dataset sampling. - kwargs (dict): additional options to be passed to the FFD_2D inner object. **Inner** - pts (np.ndarray): the geometry coordinates in the original referential. pts = [[x0, y0, z0], [x1, y1, z1], ..., [xN, yN, zN]] where N is the number of points describing the geometry and (z0, ..., zN) are null or identical. - ffd (FFD_2D): the ffd object used to build the POD dataset. \"\"\" super () . __init__ ( dat_file , ffd_ncontrol , ** kwargs ) self . pod_ncontrol = pod_ncontrol self . ffd_ncontrol = ffd_ncontrol self . ffd_dataset_size = ffd_dataset_size self . ffd = FFD_2D ( dat_file , ffd_ncontrol // 2 , ** kwargs ) self . ffd_bound = ffd_bound self . seed = seed self . build_pod_dataset () def build_pod_dataset ( self ): sampler = qmc . LatinHypercube ( d = self . ffd_ncontrol , seed = self . seed ) sample = sampler . random ( n = self . ffd_dataset_size ) scaled_sample = qmc . scale ( sample , * self . ffd_bound ) profiles = [] for Delta in scaled_sample : profiles . append ( self . ffd . apply_ffd ( Delta )) self . S = np . stack ([ p [:, - 1 ] for p in profiles ] , axis = 1 ) self . S_mean = 1 / len ( profiles ) * np . sum ( self . S , axis = 1 ) self . F = self . S [:, :] - self . S_mean [:, None ] self . C = np . matmul ( np . transpose ( self . F ), self . F ) self . eigenvalues , self . eigenvectors = np . linalg . eigh ( self . C ) self . phi = np . matmul ( self . F , self . eigenvectors ) nmode = self . pod_ncontrol self . phi_tilde = self . phi [:, - nmode :] self . V_tilde_inv = np . linalg . inv ( self . eigenvectors )[ - nmode :, :] self . D_tilde = self . S_mean [:, None ] + np . matmul ( self . phi_tilde , self . V_tilde_inv ) def apply_ffd ( self , Delta : np . ndarray ) -> np . ndarray : return np . column_stack ( ( self . ffd . pts [:, 0 ], self . S_mean + np . sum ( self . phi_tilde * Delta , axis = 1 )) ) def get_bound ( self ) -> tuple [ list [ float ], list [ float ]]: l_bound = [ min ( v ) for v in self . V_tilde_inv ] u_bound = [ max ( v ) for v in self . V_tilde_inv ] return l_bound , u_bound","title":"FFD_POD_2D"},{"location":"dev_ffd/#ffd.ffd.FFD_POD_2D.__init__","text":"Instantiates the FFD_POD_2D object. Input dat_file (str): path to input_geometry.dat. pod_ncontrol (int): the number of POD control points. ffd_ncontrol (int): the number of FFD control points. ffd_dataset_size (int): the number of ffd profiles in the POD dataset. ffd_bound (tuple[Any]): the ffd dataset deformation boundaries. seed (int): seed for the POD dataset sampling. kwargs (dict): additional options to be passed to the FFD_2D inner object. Inner pts (np.ndarray): the geometry coordinates in the original referential. pts = [[x0, y0, z0], [x1, y1, z1], ..., [xN, yN, zN]] where N is the number of points describing the geometry and (z0, ..., zN) are null or identical. ffd (FFD_2D): the ffd object used to build the POD dataset. Source code in aero_optim/ffd/ffd.py 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def __init__ ( self , dat_file : str , pod_ncontrol : int , ffd_ncontrol : int , ffd_dataset_size : int , ffd_bound : tuple [ Any ], seed : int = 123 , ** kwargs ): \"\"\" Instantiates the FFD_POD_2D object. **Input** - dat_file (str): path to input_geometry.dat. - pod_ncontrol (int): the number of POD control points. - ffd_ncontrol (int): the number of FFD control points. - ffd_dataset_size (int): the number of ffd profiles in the POD dataset. - ffd_bound (tuple[Any]): the ffd dataset deformation boundaries. - seed (int): seed for the POD dataset sampling. - kwargs (dict): additional options to be passed to the FFD_2D inner object. **Inner** - pts (np.ndarray): the geometry coordinates in the original referential. pts = [[x0, y0, z0], [x1, y1, z1], ..., [xN, yN, zN]] where N is the number of points describing the geometry and (z0, ..., zN) are null or identical. - ffd (FFD_2D): the ffd object used to build the POD dataset. \"\"\" super () . __init__ ( dat_file , ffd_ncontrol , ** kwargs ) self . pod_ncontrol = pod_ncontrol self . ffd_ncontrol = ffd_ncontrol self . ffd_dataset_size = ffd_dataset_size self . ffd = FFD_2D ( dat_file , ffd_ncontrol // 2 , ** kwargs ) self . ffd_bound = ffd_bound self . seed = seed self . build_pod_dataset ()","title":"__init__"},{"location":"dev_mesh/","text":"Mesh Source Code mesh.mesh.Mesh Bases: ABC This class implements an abstract meshing class. Source code in aero_optim/mesh/mesh.py 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 class Mesh ( ABC ): \"\"\" This class implements an abstract meshing class. \"\"\" def __init__ ( self , config : dict , datfile : str = \"\" ): \"\"\" Instantiates the abstract Mesh object. **Input** - config (dict): the config file dictionary. - dat_file (str): path to input_geometry.dat. **Inner** - outdir (str): path/to/outputdirectory - outfile (str): the core name of all outputed files e.g. outfile.log, outfile.mesh, etc. - header (int): the number of header lines in dat_file. - geom_scale (float): geometry scaling factor. - mesh_format (str): the mesh format (mesh or cgns). - bl (bool): whether to mesh the boundary layer (True) or not (False). - bl_thickness (float): the BL meshing cumulated thickness. - bl_ratio (float): the BL meshing growth ratio. - bl_size (float): the BL first element size. - bl_fan_elements (int): the number of BL fan elements. - mesh_order (int): the order of the mesh. - structured (bool): whether to recombine triangles (True) or not (False). - extrusion_layers (int): the number of extrusion layers when generating a 3D mesh. - extrusion_size (float): the total size of the extruded layers. - GUI (bool): whether to launch gmsh GUI (True) or not (False). - nview (int): the number of sub-windows in gmsh GUI. - quality (bool): whether to display quality metrics in gmsh GUI (True) or not (False). - pts (list[list[float]]): the geometry coordinates. - surf_tag (list[int]): flow-field elements tags used to recombine the mesh if structured. - non_corner_tags (list[int]): non-corner physical entity tags used to define 'Corners'. - lower_tag (list[int]): lower periodic tags to be identified as one. - lower_tag (list[int]): upper periodic tags to be identified as one. \"\"\" self . config = config self . process_config () # study params self . dat_file : str = datfile if datfile else config [ \"study\" ][ \"file\" ] self . outdir : str = config [ \"study\" ][ \"outdir\" ] self . outfile = self . config [ \"study\" ] . get ( \"outfile\" , self . dat_file . split ( \"/\" )[ - 1 ][: - 4 ]) # mesh params (geom, format & boundary layer) self . header : int = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"header\" , 2 ) self . geom_scale : int = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"scale\" , 1 ) self . mesh_format : str = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"mesh_format\" , \"mesh\" ) . lower () self . bl : bool = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"bl\" , False ) self . bl_thickness : float = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"bl_thickness\" , 1e-3 ) self . bl_ratio : float = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"bl_ratio\" , 1.1 ) self . bl_size : float = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"bl_size\" , 1e-5 ) self . bl_fan_elements : int = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"bl_fan_elements\" , 10 ) self . mesh_order : int = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"order\" , 0 ) # mesh params (3d extrusion) self . structured : bool = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"structured\" , False ) self . extrusion_layers : int = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"extrusion_layers\" , 0 ) self . extrusion_size : int = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"extrusion_size\" , 0.001 ) # gui options self . GUI : bool = config [ \"gmsh\" ][ \"view\" ] . get ( \"GUI\" , True ) self . nview : int = config [ \"gmsh\" ][ \"view\" ] . get ( \"nview\" , 1 ) self . quality : bool = config [ \"gmsh\" ][ \"view\" ] . get ( \"quality\" , False ) # geometry coordinates loading self . pts : list [ list [ float ]] = from_dat ( self . dat_file , self . header , self . geom_scale ) # flow-field and non-corner tags (for recombination and corners definition) self . surf_tag : list [ int ] = [] self . non_corner_tags : list [ int ] = [] self . bottom_tags : list [ int ] = [] self . top_tags : list [ int ] = [] def get_nlayer ( self ) -> int : \"\"\" **Returns** the number of layers required to reach bl_thickness given the growth bl_ratio and the first element size bl_size. \"\"\" return math . ceil ( math . log ( 1 - self . bl_thickness * ( 1 - self . bl_ratio ) / self . bl_size ) / math . log ( self . bl_ratio ) - 1 ) def build_mesh ( self ): \"\"\" **Defines** the gmsh routine. \"\"\" gmsh . initialize () gmsh . option . setNumber ( 'General.Terminal' , 0 ) gmsh . logger . start () gmsh . model . add ( \"model\" ) self . build_2dmesh () self . build_3dmesh () if self . extrusion_layers > 0 else 0 if self . structured : [ gmsh . model . geo . mesh . setRecombine ( 2 , abs ( id )) for id in self . surf_tag ] gmsh . model . geo . synchronize () gmsh . model . mesh . generate ( 3 ) if self . extrusion_layers > 0 else gmsh . model . mesh . generate ( 2 ) if self . mesh_order : gmsh . model . mesh . setOrder ( self . mesh_order ) # visualization if self . quality : plot_quality () elt_type = \"Mesh.Triangles\" if not self . structured else \"Mesh.Quadrangles\" color = [ ( \"General.BackgroundGradient\" , 255 , 255 , 255 ), ( elt_type , 255 , 0 , 0 ) ] number = [ ( \"Geometry.Points\" , 0 ), ( \"Geometry.Curves\" , 0 ), ( \"Mesh.ColorCarousel\" , 0 ), ] if not self . quality : number . append (( \"Mesh.SurfaceFaces\" , 1 )) set_display ( color , number ) split_view ( self . nview ) if self . nview > 1 else 0 # output if self . GUI : gmsh . fltk . run () def write_mesh ( self , mesh_dir : str = \"\" ) -> str : \"\"\" **Writes** all output files: <file>.geo_unrolled, <file>.log, <file>.mesh and returns the mesh filename. - mesh_dir: the name of the directory where all gmsh generated files are saved. - format: whether to perform medit formatting (True) or not (False) of the mesh. - self.outfile: the core name of the outputed files e.g. outfile.log, outfile.mesh, etc. \"\"\" mesh_dir = self . outdir if not mesh_dir else mesh_dir check_dir ( mesh_dir ) # .geo logger . info ( f \"writing { self . outfile } .geo_unrolled to { mesh_dir } \" ) gmsh . write ( os . path . join ( mesh_dir , self . outfile + \".geo_unrolled\" )) # .mesh logger . info ( f \"writing { self . outfile } . { self . mesh_format } to { mesh_dir } \" ) gmsh . write ( os . path . join ( mesh_dir , self . outfile + f \". { self . mesh_format } \" )) # medit formatting if self . mesh_format == \"mesh\" : logger . info ( f \"medit formatting of { self . outfile } .mesh\" ) mesh_file = os . path . join ( mesh_dir , self . outfile + \".mesh\" ) mesh = open ( mesh_file , \"r\" ) . read () . splitlines () if self . extrusion_layers == 0 : mesh = self . reformat_2d ( mesh ) if self . non_corner_tags : mesh = self . add_corners ( mesh ) if self . bottom_tags and self . top_tags : mesh = self . merge_refs ( mesh ) with open ( mesh_file , 'w' ) as ftw : ftw . write ( \" \\n \" . join ( mesh )) # .log log = gmsh . logger . get () log_file = open ( os . path . join ( mesh_dir , self . outfile + \".log\" ), \"w\" ) logger . info ( f \"writing { self . outfile } .log to { mesh_dir } \" ) log_file . write ( \" \\n \" . join ( log )) # print summary summary = [ line for line in log if \"nodes\" in line and \"elements\" in line ][ - 1 ][ 6 :] logger . info ( f \"GMSH summary: { summary } \" ) # close gmsh gmsh . logger . stop () gmsh . finalize () return self . get_meshfile ( mesh_dir ) def reformat_2d ( self , mesh : list [ str ]) -> list [ str ]: \"\"\" **Fix** gmsh default .mesh format in 2D. \"\"\" idx = get_mesh_kwd ( mesh , \"Dimension\" ) mesh [ idx ] = \" Dimension 2\" del mesh [ idx + 1 ] vert_idx = get_mesh_kwd ( mesh , \"Vertices\" ) n_vert = int ( mesh [ vert_idx + 1 ]) for id in range ( vert_idx + 2 , vert_idx + 2 + n_vert ): line_data = list ( map ( float , mesh [ id ] . split ())) mesh [ id ] = \" \" * 4 + f \" { line_data [ 0 ] : >20 } \" + \\ \" \" * 4 + f \" { line_data [ 1 ] : >20 } \" + \\ \" \" * 4 + f \" { int ( line_data [ - 1 ]) : >20 } \" return mesh def add_corners ( self , mesh : list [ str ]) -> list [ str ]: \"\"\" **Adds** Corners at the end of the mesh file. \"\"\" c_vert : list [ int ] = [] logger . debug ( f \"non-corner tags: { self . non_corner_tags } \" ) vert_idx = get_mesh_kwd ( mesh , \"Vertices\" ) n_vert = int ( mesh [ vert_idx + 1 ]) for v_id , id in enumerate ( range ( vert_idx + 2 , vert_idx + 2 + n_vert )): line_data = list ( map ( float , mesh [ id ] . split ())) if int ( line_data [ - 1 ]) not in self . non_corner_tags : c_vert . append ( v_id + 1 ) mesh = mesh [: - 1 ] + [ \"Corners\" , str ( len ( c_vert ))] + [ str ( v ) for v in c_vert ] + [ \"End\" ] return mesh def merge_refs ( self , mesh : list [ str ]) -> list [ str ]: \"\"\" **Merges** the periodic boundaries references on each side of the domain. \"\"\" logger . debug ( f \"top tags: { self . top_tags } merged in ref: { max ( self . top_tags ) } \" ) logger . debug ( f \"bottom tags: { self . bottom_tags } merged in ref: { min ( self . bottom_tags ) } \" ) vert_idx = get_mesh_kwd ( mesh , \"Vertices\" ) n_vert = int ( mesh [ vert_idx + 1 ]) for id in range ( vert_idx + 2 , vert_idx + 2 + n_vert ): line_data = list ( map ( float , mesh [ id ] . split ())) if int ( line_data [ - 1 ]) in self . bottom_tags : line_data [ - 1 ] = min ( self . bottom_tags ) elif int ( line_data [ - 1 ]) in self . top_tags : line_data [ - 1 ] = max ( self . top_tags ) mesh [ id ] = \" \" * 4 + f \" { line_data [ 0 ] : >20 } \" + \\ \" \" * 4 + f \" { line_data [ 1 ] : >20 } \" + \\ \" \" * 4 + f \" { int ( line_data [ - 1 ]) : >20 } \" edge_idx = get_mesh_kwd ( mesh , \"Edges\" ) n_edges = int ( mesh [ edge_idx + 1 ]) for id in range ( edge_idx + 2 , edge_idx + 2 + n_edges ): line_data = list ( map ( int , mesh [ id ] . split ())) if line_data [ 2 ] in self . bottom_tags : line_data [ 2 ] = min ( self . bottom_tags ) elif line_data [ 2 ] in self . top_tags : line_data [ 2 ] = max ( self . top_tags ) mesh [ id ] = \" \" + f \" { line_data [ 0 ] } \" + \" \" + f \" { line_data [ 1 ] } \" + \" \" + f \" { line_data [ 2 ] } \" return mesh def get_meshfile ( self , mesh_dir : str ) -> str : \"\"\" **Returns** the path to the generated mesh. \"\"\" return os . path . join ( mesh_dir , self . outfile + f \". { self . mesh_format } \" ) @abstractmethod def process_config ( self ): \"\"\" Makes sure the config file contains the required information. \"\"\" @abstractmethod def build_2dmesh ( self ): \"\"\" Builds the surface mesh of the computational domain. \"\"\" def build_3dmesh ( self ): \"\"\" Builds a 3D mesh by extrusion \"\"\" raise Exception ( \"build_3dmesh method not implemented\" ) __init__ ( config : dict , datfile : str = '' ) Instantiates the abstract Mesh object. Input config (dict): the config file dictionary. dat_file (str): path to input_geometry.dat. Inner outdir (str): path/to/outputdirectory outfile (str): the core name of all outputed files e.g. outfile.log, outfile.mesh, etc. header (int): the number of header lines in dat_file. geom_scale (float): geometry scaling factor. mesh_format (str): the mesh format (mesh or cgns). bl (bool): whether to mesh the boundary layer (True) or not (False). bl_thickness (float): the BL meshing cumulated thickness. bl_ratio (float): the BL meshing growth ratio. bl_size (float): the BL first element size. bl_fan_elements (int): the number of BL fan elements. mesh_order (int): the order of the mesh. structured (bool): whether to recombine triangles (True) or not (False). extrusion_layers (int): the number of extrusion layers when generating a 3D mesh. extrusion_size (float): the total size of the extruded layers. GUI (bool): whether to launch gmsh GUI (True) or not (False). nview (int): the number of sub-windows in gmsh GUI. quality (bool): whether to display quality metrics in gmsh GUI (True) or not (False). pts (list[list[float]]): the geometry coordinates. surf_tag (list[int]): flow-field elements tags used to recombine the mesh if structured. non_corner_tags (list[int]): non-corner physical entity tags used to define 'Corners'. lower_tag (list[int]): lower periodic tags to be identified as one. lower_tag (list[int]): upper periodic tags to be identified as one. Source code in aero_optim/mesh/mesh.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 def __init__ ( self , config : dict , datfile : str = \"\" ): \"\"\" Instantiates the abstract Mesh object. **Input** - config (dict): the config file dictionary. - dat_file (str): path to input_geometry.dat. **Inner** - outdir (str): path/to/outputdirectory - outfile (str): the core name of all outputed files e.g. outfile.log, outfile.mesh, etc. - header (int): the number of header lines in dat_file. - geom_scale (float): geometry scaling factor. - mesh_format (str): the mesh format (mesh or cgns). - bl (bool): whether to mesh the boundary layer (True) or not (False). - bl_thickness (float): the BL meshing cumulated thickness. - bl_ratio (float): the BL meshing growth ratio. - bl_size (float): the BL first element size. - bl_fan_elements (int): the number of BL fan elements. - mesh_order (int): the order of the mesh. - structured (bool): whether to recombine triangles (True) or not (False). - extrusion_layers (int): the number of extrusion layers when generating a 3D mesh. - extrusion_size (float): the total size of the extruded layers. - GUI (bool): whether to launch gmsh GUI (True) or not (False). - nview (int): the number of sub-windows in gmsh GUI. - quality (bool): whether to display quality metrics in gmsh GUI (True) or not (False). - pts (list[list[float]]): the geometry coordinates. - surf_tag (list[int]): flow-field elements tags used to recombine the mesh if structured. - non_corner_tags (list[int]): non-corner physical entity tags used to define 'Corners'. - lower_tag (list[int]): lower periodic tags to be identified as one. - lower_tag (list[int]): upper periodic tags to be identified as one. \"\"\" self . config = config self . process_config () # study params self . dat_file : str = datfile if datfile else config [ \"study\" ][ \"file\" ] self . outdir : str = config [ \"study\" ][ \"outdir\" ] self . outfile = self . config [ \"study\" ] . get ( \"outfile\" , self . dat_file . split ( \"/\" )[ - 1 ][: - 4 ]) # mesh params (geom, format & boundary layer) self . header : int = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"header\" , 2 ) self . geom_scale : int = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"scale\" , 1 ) self . mesh_format : str = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"mesh_format\" , \"mesh\" ) . lower () self . bl : bool = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"bl\" , False ) self . bl_thickness : float = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"bl_thickness\" , 1e-3 ) self . bl_ratio : float = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"bl_ratio\" , 1.1 ) self . bl_size : float = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"bl_size\" , 1e-5 ) self . bl_fan_elements : int = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"bl_fan_elements\" , 10 ) self . mesh_order : int = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"order\" , 0 ) # mesh params (3d extrusion) self . structured : bool = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"structured\" , False ) self . extrusion_layers : int = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"extrusion_layers\" , 0 ) self . extrusion_size : int = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"extrusion_size\" , 0.001 ) # gui options self . GUI : bool = config [ \"gmsh\" ][ \"view\" ] . get ( \"GUI\" , True ) self . nview : int = config [ \"gmsh\" ][ \"view\" ] . get ( \"nview\" , 1 ) self . quality : bool = config [ \"gmsh\" ][ \"view\" ] . get ( \"quality\" , False ) # geometry coordinates loading self . pts : list [ list [ float ]] = from_dat ( self . dat_file , self . header , self . geom_scale ) # flow-field and non-corner tags (for recombination and corners definition) self . surf_tag : list [ int ] = [] self . non_corner_tags : list [ int ] = [] self . bottom_tags : list [ int ] = [] self . top_tags : list [ int ] = [] add_corners ( mesh : list [ str ]) -> list [ str ] Adds Corners at the end of the mesh file. Source code in aero_optim/mesh/mesh.py 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 def add_corners ( self , mesh : list [ str ]) -> list [ str ]: \"\"\" **Adds** Corners at the end of the mesh file. \"\"\" c_vert : list [ int ] = [] logger . debug ( f \"non-corner tags: { self . non_corner_tags } \" ) vert_idx = get_mesh_kwd ( mesh , \"Vertices\" ) n_vert = int ( mesh [ vert_idx + 1 ]) for v_id , id in enumerate ( range ( vert_idx + 2 , vert_idx + 2 + n_vert )): line_data = list ( map ( float , mesh [ id ] . split ())) if int ( line_data [ - 1 ]) not in self . non_corner_tags : c_vert . append ( v_id + 1 ) mesh = mesh [: - 1 ] + [ \"Corners\" , str ( len ( c_vert ))] + [ str ( v ) for v in c_vert ] + [ \"End\" ] return mesh build_2dmesh () abstractmethod Builds the surface mesh of the computational domain. Source code in aero_optim/mesh/mesh.py 390 391 392 393 394 @abstractmethod def build_2dmesh ( self ): \"\"\" Builds the surface mesh of the computational domain. \"\"\" build_3dmesh () Builds a 3D mesh by extrusion Source code in aero_optim/mesh/mesh.py 396 397 398 399 400 def build_3dmesh ( self ): \"\"\" Builds a 3D mesh by extrusion \"\"\" raise Exception ( \"build_3dmesh method not implemented\" ) build_mesh () Defines the gmsh routine. Source code in aero_optim/mesh/mesh.py 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 def build_mesh ( self ): \"\"\" **Defines** the gmsh routine. \"\"\" gmsh . initialize () gmsh . option . setNumber ( 'General.Terminal' , 0 ) gmsh . logger . start () gmsh . model . add ( \"model\" ) self . build_2dmesh () self . build_3dmesh () if self . extrusion_layers > 0 else 0 if self . structured : [ gmsh . model . geo . mesh . setRecombine ( 2 , abs ( id )) for id in self . surf_tag ] gmsh . model . geo . synchronize () gmsh . model . mesh . generate ( 3 ) if self . extrusion_layers > 0 else gmsh . model . mesh . generate ( 2 ) if self . mesh_order : gmsh . model . mesh . setOrder ( self . mesh_order ) # visualization if self . quality : plot_quality () elt_type = \"Mesh.Triangles\" if not self . structured else \"Mesh.Quadrangles\" color = [ ( \"General.BackgroundGradient\" , 255 , 255 , 255 ), ( elt_type , 255 , 0 , 0 ) ] number = [ ( \"Geometry.Points\" , 0 ), ( \"Geometry.Curves\" , 0 ), ( \"Mesh.ColorCarousel\" , 0 ), ] if not self . quality : number . append (( \"Mesh.SurfaceFaces\" , 1 )) set_display ( color , number ) split_view ( self . nview ) if self . nview > 1 else 0 # output if self . GUI : gmsh . fltk . run () get_meshfile ( mesh_dir : str ) -> str Returns the path to the generated mesh. Source code in aero_optim/mesh/mesh.py 378 379 380 381 382 def get_meshfile ( self , mesh_dir : str ) -> str : \"\"\" **Returns** the path to the generated mesh. \"\"\" return os . path . join ( mesh_dir , self . outfile + f \". { self . mesh_format } \" ) get_nlayer () -> int Returns the number of layers required to reach bl_thickness given the growth bl_ratio and the first element size bl_size. Source code in aero_optim/mesh/mesh.py 219 220 221 222 223 224 225 226 227 def get_nlayer ( self ) -> int : \"\"\" **Returns** the number of layers required to reach bl_thickness given the growth bl_ratio and the first element size bl_size. \"\"\" return math . ceil ( math . log ( 1 - self . bl_thickness * ( 1 - self . bl_ratio ) / self . bl_size ) / math . log ( self . bl_ratio ) - 1 ) merge_refs ( mesh : list [ str ]) -> list [ str ] Merges the periodic boundaries references on each side of the domain. Source code in aero_optim/mesh/mesh.py 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 def merge_refs ( self , mesh : list [ str ]) -> list [ str ]: \"\"\" **Merges** the periodic boundaries references on each side of the domain. \"\"\" logger . debug ( f \"top tags: { self . top_tags } merged in ref: { max ( self . top_tags ) } \" ) logger . debug ( f \"bottom tags: { self . bottom_tags } merged in ref: { min ( self . bottom_tags ) } \" ) vert_idx = get_mesh_kwd ( mesh , \"Vertices\" ) n_vert = int ( mesh [ vert_idx + 1 ]) for id in range ( vert_idx + 2 , vert_idx + 2 + n_vert ): line_data = list ( map ( float , mesh [ id ] . split ())) if int ( line_data [ - 1 ]) in self . bottom_tags : line_data [ - 1 ] = min ( self . bottom_tags ) elif int ( line_data [ - 1 ]) in self . top_tags : line_data [ - 1 ] = max ( self . top_tags ) mesh [ id ] = \" \" * 4 + f \" { line_data [ 0 ] : >20 } \" + \\ \" \" * 4 + f \" { line_data [ 1 ] : >20 } \" + \\ \" \" * 4 + f \" { int ( line_data [ - 1 ]) : >20 } \" edge_idx = get_mesh_kwd ( mesh , \"Edges\" ) n_edges = int ( mesh [ edge_idx + 1 ]) for id in range ( edge_idx + 2 , edge_idx + 2 + n_edges ): line_data = list ( map ( int , mesh [ id ] . split ())) if line_data [ 2 ] in self . bottom_tags : line_data [ 2 ] = min ( self . bottom_tags ) elif line_data [ 2 ] in self . top_tags : line_data [ 2 ] = max ( self . top_tags ) mesh [ id ] = \" \" + f \" { line_data [ 0 ] } \" + \" \" + f \" { line_data [ 1 ] } \" + \" \" + f \" { line_data [ 2 ] } \" return mesh process_config () abstractmethod Makes sure the config file contains the required information. Source code in aero_optim/mesh/mesh.py 384 385 386 387 388 @abstractmethod def process_config ( self ): \"\"\" Makes sure the config file contains the required information. \"\"\" reformat_2d ( mesh : list [ str ]) -> list [ str ] Fix gmsh default .mesh format in 2D. Source code in aero_optim/mesh/mesh.py 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 def reformat_2d ( self , mesh : list [ str ]) -> list [ str ]: \"\"\" **Fix** gmsh default .mesh format in 2D. \"\"\" idx = get_mesh_kwd ( mesh , \"Dimension\" ) mesh [ idx ] = \" Dimension 2\" del mesh [ idx + 1 ] vert_idx = get_mesh_kwd ( mesh , \"Vertices\" ) n_vert = int ( mesh [ vert_idx + 1 ]) for id in range ( vert_idx + 2 , vert_idx + 2 + n_vert ): line_data = list ( map ( float , mesh [ id ] . split ())) mesh [ id ] = \" \" * 4 + f \" { line_data [ 0 ] : >20 } \" + \\ \" \" * 4 + f \" { line_data [ 1 ] : >20 } \" + \\ \" \" * 4 + f \" { int ( line_data [ - 1 ]) : >20 } \" return mesh write_mesh ( mesh_dir : str = '' ) -> str Writes all output files: .geo_unrolled, .log, .mesh and returns the mesh filename. mesh_dir: the name of the directory where all gmsh generated files are saved. format: whether to perform medit formatting (True) or not (False) of the mesh. self.outfile: the core name of the outputed files e.g. outfile.log, outfile.mesh, etc. Source code in aero_optim/mesh/mesh.py 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 def write_mesh ( self , mesh_dir : str = \"\" ) -> str : \"\"\" **Writes** all output files: <file>.geo_unrolled, <file>.log, <file>.mesh and returns the mesh filename. - mesh_dir: the name of the directory where all gmsh generated files are saved. - format: whether to perform medit formatting (True) or not (False) of the mesh. - self.outfile: the core name of the outputed files e.g. outfile.log, outfile.mesh, etc. \"\"\" mesh_dir = self . outdir if not mesh_dir else mesh_dir check_dir ( mesh_dir ) # .geo logger . info ( f \"writing { self . outfile } .geo_unrolled to { mesh_dir } \" ) gmsh . write ( os . path . join ( mesh_dir , self . outfile + \".geo_unrolled\" )) # .mesh logger . info ( f \"writing { self . outfile } . { self . mesh_format } to { mesh_dir } \" ) gmsh . write ( os . path . join ( mesh_dir , self . outfile + f \". { self . mesh_format } \" )) # medit formatting if self . mesh_format == \"mesh\" : logger . info ( f \"medit formatting of { self . outfile } .mesh\" ) mesh_file = os . path . join ( mesh_dir , self . outfile + \".mesh\" ) mesh = open ( mesh_file , \"r\" ) . read () . splitlines () if self . extrusion_layers == 0 : mesh = self . reformat_2d ( mesh ) if self . non_corner_tags : mesh = self . add_corners ( mesh ) if self . bottom_tags and self . top_tags : mesh = self . merge_refs ( mesh ) with open ( mesh_file , 'w' ) as ftw : ftw . write ( \" \\n \" . join ( mesh )) # .log log = gmsh . logger . get () log_file = open ( os . path . join ( mesh_dir , self . outfile + \".log\" ), \"w\" ) logger . info ( f \"writing { self . outfile } .log to { mesh_dir } \" ) log_file . write ( \" \\n \" . join ( log )) # print summary summary = [ line for line in log if \"nodes\" in line and \"elements\" in line ][ - 1 ][ 6 :] logger . info ( f \"GMSH summary: { summary } \" ) # close gmsh gmsh . logger . stop () gmsh . finalize () return self . get_meshfile ( mesh_dir ) mesh.naca_base_mesh.NACABaseMesh Bases: Mesh This class implements a meshing routine for a naca profile. The computational domain has the following structure: pt_hi_inlet ! top_side ! ! * * ------------- * pt_hi_outlet * * * | * * | * | * * | * | * <- arc_inlet | <- outlet * | * * | * | * * | * * * | * * ------------- * pt_low_outlet ! ! ! bottom_side pt_low_inlet Source code in aero_optim/mesh/naca_base_mesh.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 class NACABaseMesh ( Mesh ): \"\"\" This class implements a meshing routine for a naca profile. The computational domain has the following structure: pt_hi_inlet ! top_side ! ! * * ------------- * pt_hi_outlet * * * | * * | * | * * | * | * <- arc_inlet | <- outlet * | * * | * | * * | * * * | * * ------------- * pt_low_outlet ! ! ! bottom_side pt_low_inlet \"\"\" def __init__ ( self , config : dict , datfile : str = \"\" ): \"\"\" Instantiates the NACABaseMesh object. **Input** - config (dict): the config file dictionary. - dat_file (str): path to input_geometry.dat. **Inner** - dinlet (float): the radius of the inlet semi-circle. - doutlet (float): the distance between the airfoil trailing edge and the outlet. - offset (int): the leading edge portion defined in number of points from the leading edge. - nodes_inlet (int): the number of nodes to mesh the inlet. - nodes_outlet (int): the number of nodes to mesh the outlet. - snodes (int): the number of nodes to mesh the top and bottom sides. - le (int): the number of nodes to mesh the airfoil leading edge portion. - low (int): the number of nodes to mesh the airfoil trailing edge lower portion. - up (int): the number of nodes to mesh the airfoil trailing edge upper portion. \"\"\" super () . __init__ ( config , datfile ) self . dinlet : float = self . config [ \"gmsh\" ][ \"domain\" ] . get ( \"inlet\" , 2 ) self . doutlet : float = self . config [ \"gmsh\" ][ \"domain\" ] . get ( \"outlet\" , 10 ) self . offset : int = self . config [ \"gmsh\" ][ \"domain\" ] . get ( \"le_offset\" , 10 ) self . nodes_inlet : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_inlet\" , 100 ) self . nodes_outlet : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_outlet\" , 100 ) self . snodes : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"side_nodes\" , 100 ) self . le : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"le\" , 20 ) self . low : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"low\" , 70 ) self . up : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"up\" , 70 ) def process_config ( self ): logger . debug ( \"processing config..\" ) if \"domain\" not in self . config [ \"gmsh\" ]: logger . debug ( f \"no <domain> entry in { self . config [ 'gmsh' ] } , empty entry added\" ) self . config [ \"gmsh\" ][ \"domain\" ] = {} if \"inlet\" not in self . config [ \"gmsh\" ][ \"domain\" ]: logger . debug ( f \"no <inlet> entry in { self . config [ 'gmsh' ][ 'domain' ] } \" ) if \"outlet\" not in self . config [ \"gmsh\" ][ \"domain\" ]: logger . debug ( f \"no <outlet> entry in { self . config [ 'gmsh' ][ 'domain' ] } \" ) def split_naca ( self ) -> tuple [ list [ list [ float ]], list [ list [ float ]]]: \"\"\" **Returns** the upper and lower parts of the airfoil as ordered lists (wrt the x axis). Note: the trailing and leading edges are voluntarily excluded from both parts since the geometry is closed and these points must each have a unique tag. \"\"\" start : int = min ( self . idx_le , self . idx_te ) end : int = max ( self . idx_le , self . idx_te ) if ( max ([ p [ 1 ] for p in self . pts [ start : end + 1 ]]) > max ([ p [ 1 ] for p in self . pts [: start + 1 ] + self . pts [ end :]]) ): upper = [[ p [ 0 ], p [ 1 ], p [ 2 ]] for p in self . pts [ start + 1 : end ]] lower = [[ p [ 0 ], p [ 1 ], p [ 2 ]] for p in self . pts [: start ] + self . pts [ end + 1 :]] else : lower = [[ p [ 0 ], p [ 1 ], p [ 2 ]] for p in self . pts [ start + 1 : end ]] upper = [[ p [ 0 ], p [ 1 ], p [ 2 ]] for p in self . pts [: start ] + self . pts [ end + 1 :]] upper = sorted ( upper , key = lambda x : ( x [ 0 ]), reverse = True ) lower = sorted ( lower , key = lambda x : ( x [ 0 ])) return upper , lower def build_bl ( self , naca_tag : list [ int ], te_tag : int ): \"\"\" **Builds** the boundary layer around the airfoil. \"\"\" self . f = gmsh . model . mesh . field . add ( 'BoundaryLayer' ) gmsh . model . mesh . field . setNumbers ( self . f , 'CurvesList' , naca_tag ) gmsh . model . mesh . field . setNumber ( self . f , 'Size' , self . bl_size ) gmsh . model . mesh . field . setNumber ( self . f , 'Ratio' , self . bl_ratio ) gmsh . model . mesh . field . setNumber ( self . f , 'Quads' , int ( self . structured )) gmsh . model . mesh . field . setNumber ( self . f , 'Thickness' , self . bl_thickness ) gmsh . option . setNumber ( 'Mesh.BoundaryLayerFanElements' , self . bl_fan_elements ) gmsh . model . mesh . field . setNumbers ( self . f , 'FanPointsList' , [ te_tag ]) gmsh . model . mesh . field . setAsBoundaryLayer ( self . f ) def build_2dmesh ( self ): \"\"\" **Builds** the surface mesh of the computational domain. \"\"\" _ , self . idx_le = min (( p [ 0 ], idx ) for ( idx , p ) in enumerate ( self . pts )) _ , self . idx_te = max (( p [ 0 ], idx ) for ( idx , p ) in enumerate ( self . pts )) u_side , l_side = self . split_naca () # add points and lines for the naca lower and upper parts x_le , y_le = self . pts [ self . idx_le ][: 2 ] x_te , y_te = self . pts [ self . idx_te ][: 2 ] te_tag = gmsh . model . geo . addPoint ( x_te , y_te , 0. ) le_tag = gmsh . model . geo . addPoint ( x_le , y_le , 0. ) pt_u = [ te_tag ] + [ gmsh . model . geo . addPoint ( p [ 0 ], p [ 1 ], p [ 2 ]) for p in u_side ] pt_l = [ le_tag ] + \\ [ gmsh . model . geo . addPoint ( p [ 0 ], p [ 1 ], p [ 2 ]) for p in l_side ] + [ te_tag ] # airfoil boundary spline_low = gmsh . model . geo . addSpline ( pt_l [ self . offset :], tag = 1 ) spline_le = gmsh . model . geo . addSpline ( pt_u [ - self . offset :] + pt_l [: self . offset + 1 ], tag = 2 ) spline_up = gmsh . model . geo . addSpline ( pt_u [: - self . offset + 1 ], tag = 3 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spline_low , self . low , \"Progression\" , 1 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spline_le , self . le , \"Bump\" , 2. ) gmsh . model . geo . mesh . setTransfiniteCurve ( spline_up , self . up , \"Progression\" , 1 ) naca_loop = gmsh . model . geo . addCurveLoop ([ spline_low , spline_le , spline_up ]) # boundary layer self . build_bl ([ spline_low , spline_le , spline_up ], te_tag ) if self . bl else 0 # construction points pt_hi_inlet = gmsh . model . geo . addPoint ( x_te , y_te + self . dinlet , 0. ) pt_low_inlet = gmsh . model . geo . addPoint ( x_te , y_te - self . dinlet , 0. ) pt_hi_outlet = gmsh . model . geo . addPoint ( x_te + self . doutlet , y_te + self . dinlet , 0. ) pt_low_outlet = gmsh . model . geo . addPoint ( x_te + self . doutlet , y_te - self . dinlet , 0. ) # non-blade boundary lines arc_inlet = gmsh . model . geo . addCircleArc ( pt_hi_inlet , te_tag , pt_low_inlet ) top_side = gmsh . model . geo . addLine ( pt_hi_inlet , pt_hi_outlet ) bottom_side = gmsh . model . geo . addLine ( pt_low_outlet , pt_low_inlet ) outlet = gmsh . model . geo . addLine ( pt_hi_outlet , pt_low_outlet ) # transfinite curves on non-blade boundaries gmsh . model . geo . mesh . setTransfiniteCurve ( arc_inlet , self . nodes_inlet , \"Progression\" , 1 ) gmsh . model . geo . mesh . setTransfiniteCurve ( top_side , self . snodes , \"Progression\" , 1 ) gmsh . model . geo . mesh . setTransfiniteCurve ( bottom_side , self . snodes , \"Progression\" , 1 ) gmsh . model . geo . mesh . setTransfiniteCurve ( outlet , self . nodes_outlet , \"Progression\" , 1 ) # closed curve loop and computational domain surface definition cloop = [ - arc_inlet , top_side , outlet , bottom_side ] boundary_loop = gmsh . model . geo . addCurveLoop ( cloop ) self . surf_tag = [ gmsh . model . geo . addPlaneSurface ([ - boundary_loop , - naca_loop ], tag = 1000 )] # define physical groups for boundary conditions gmsh . model . geo . addPhysicalGroup ( 1 , [ spline_low , spline_le , spline_up ], tag = 100 ) logger . debug ( f \"BC: Wall tags are { [ spline_low , spline_le , spline_up ] } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , [ arc_inlet ], tag = 200 ) logger . debug ( f \"BC: Inlet tags are { [ arc_inlet ] } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , [ outlet ], tag = 300 ) logger . debug ( f \"BC: Outlet tags are { [ outlet ] } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , [ top_side ], tag = 400 ) logger . debug ( f \"BC: Top tags are { [ top_side ] } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , [ bottom_side ], tag = 500 ) logger . debug ( f \"BC: Bottom tags are { [ bottom_side ] } \" ) gmsh . model . geo . addPhysicalGroup ( 2 , self . surf_tag , tag = 600 ) __init__ ( config : dict , datfile : str = '' ) Instantiates the NACABaseMesh object. Input config (dict): the config file dictionary. dat_file (str): path to input_geometry.dat. Inner dinlet (float): the radius of the inlet semi-circle. doutlet (float): the distance between the airfoil trailing edge and the outlet. offset (int): the leading edge portion defined in number of points from the leading edge. nodes_inlet (int): the number of nodes to mesh the inlet. nodes_outlet (int): the number of nodes to mesh the outlet. snodes (int): the number of nodes to mesh the top and bottom sides. le (int): the number of nodes to mesh the airfoil leading edge portion. low (int): the number of nodes to mesh the airfoil trailing edge lower portion. up (int): the number of nodes to mesh the airfoil trailing edge upper portion. Source code in aero_optim/mesh/naca_base_mesh.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def __init__ ( self , config : dict , datfile : str = \"\" ): \"\"\" Instantiates the NACABaseMesh object. **Input** - config (dict): the config file dictionary. - dat_file (str): path to input_geometry.dat. **Inner** - dinlet (float): the radius of the inlet semi-circle. - doutlet (float): the distance between the airfoil trailing edge and the outlet. - offset (int): the leading edge portion defined in number of points from the leading edge. - nodes_inlet (int): the number of nodes to mesh the inlet. - nodes_outlet (int): the number of nodes to mesh the outlet. - snodes (int): the number of nodes to mesh the top and bottom sides. - le (int): the number of nodes to mesh the airfoil leading edge portion. - low (int): the number of nodes to mesh the airfoil trailing edge lower portion. - up (int): the number of nodes to mesh the airfoil trailing edge upper portion. \"\"\" super () . __init__ ( config , datfile ) self . dinlet : float = self . config [ \"gmsh\" ][ \"domain\" ] . get ( \"inlet\" , 2 ) self . doutlet : float = self . config [ \"gmsh\" ][ \"domain\" ] . get ( \"outlet\" , 10 ) self . offset : int = self . config [ \"gmsh\" ][ \"domain\" ] . get ( \"le_offset\" , 10 ) self . nodes_inlet : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_inlet\" , 100 ) self . nodes_outlet : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_outlet\" , 100 ) self . snodes : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"side_nodes\" , 100 ) self . le : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"le\" , 20 ) self . low : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"low\" , 70 ) self . up : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"up\" , 70 ) build_2dmesh () Builds the surface mesh of the computational domain. Source code in aero_optim/mesh/naca_base_mesh.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 def build_2dmesh ( self ): \"\"\" **Builds** the surface mesh of the computational domain. \"\"\" _ , self . idx_le = min (( p [ 0 ], idx ) for ( idx , p ) in enumerate ( self . pts )) _ , self . idx_te = max (( p [ 0 ], idx ) for ( idx , p ) in enumerate ( self . pts )) u_side , l_side = self . split_naca () # add points and lines for the naca lower and upper parts x_le , y_le = self . pts [ self . idx_le ][: 2 ] x_te , y_te = self . pts [ self . idx_te ][: 2 ] te_tag = gmsh . model . geo . addPoint ( x_te , y_te , 0. ) le_tag = gmsh . model . geo . addPoint ( x_le , y_le , 0. ) pt_u = [ te_tag ] + [ gmsh . model . geo . addPoint ( p [ 0 ], p [ 1 ], p [ 2 ]) for p in u_side ] pt_l = [ le_tag ] + \\ [ gmsh . model . geo . addPoint ( p [ 0 ], p [ 1 ], p [ 2 ]) for p in l_side ] + [ te_tag ] # airfoil boundary spline_low = gmsh . model . geo . addSpline ( pt_l [ self . offset :], tag = 1 ) spline_le = gmsh . model . geo . addSpline ( pt_u [ - self . offset :] + pt_l [: self . offset + 1 ], tag = 2 ) spline_up = gmsh . model . geo . addSpline ( pt_u [: - self . offset + 1 ], tag = 3 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spline_low , self . low , \"Progression\" , 1 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spline_le , self . le , \"Bump\" , 2. ) gmsh . model . geo . mesh . setTransfiniteCurve ( spline_up , self . up , \"Progression\" , 1 ) naca_loop = gmsh . model . geo . addCurveLoop ([ spline_low , spline_le , spline_up ]) # boundary layer self . build_bl ([ spline_low , spline_le , spline_up ], te_tag ) if self . bl else 0 # construction points pt_hi_inlet = gmsh . model . geo . addPoint ( x_te , y_te + self . dinlet , 0. ) pt_low_inlet = gmsh . model . geo . addPoint ( x_te , y_te - self . dinlet , 0. ) pt_hi_outlet = gmsh . model . geo . addPoint ( x_te + self . doutlet , y_te + self . dinlet , 0. ) pt_low_outlet = gmsh . model . geo . addPoint ( x_te + self . doutlet , y_te - self . dinlet , 0. ) # non-blade boundary lines arc_inlet = gmsh . model . geo . addCircleArc ( pt_hi_inlet , te_tag , pt_low_inlet ) top_side = gmsh . model . geo . addLine ( pt_hi_inlet , pt_hi_outlet ) bottom_side = gmsh . model . geo . addLine ( pt_low_outlet , pt_low_inlet ) outlet = gmsh . model . geo . addLine ( pt_hi_outlet , pt_low_outlet ) # transfinite curves on non-blade boundaries gmsh . model . geo . mesh . setTransfiniteCurve ( arc_inlet , self . nodes_inlet , \"Progression\" , 1 ) gmsh . model . geo . mesh . setTransfiniteCurve ( top_side , self . snodes , \"Progression\" , 1 ) gmsh . model . geo . mesh . setTransfiniteCurve ( bottom_side , self . snodes , \"Progression\" , 1 ) gmsh . model . geo . mesh . setTransfiniteCurve ( outlet , self . nodes_outlet , \"Progression\" , 1 ) # closed curve loop and computational domain surface definition cloop = [ - arc_inlet , top_side , outlet , bottom_side ] boundary_loop = gmsh . model . geo . addCurveLoop ( cloop ) self . surf_tag = [ gmsh . model . geo . addPlaneSurface ([ - boundary_loop , - naca_loop ], tag = 1000 )] # define physical groups for boundary conditions gmsh . model . geo . addPhysicalGroup ( 1 , [ spline_low , spline_le , spline_up ], tag = 100 ) logger . debug ( f \"BC: Wall tags are { [ spline_low , spline_le , spline_up ] } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , [ arc_inlet ], tag = 200 ) logger . debug ( f \"BC: Inlet tags are { [ arc_inlet ] } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , [ outlet ], tag = 300 ) logger . debug ( f \"BC: Outlet tags are { [ outlet ] } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , [ top_side ], tag = 400 ) logger . debug ( f \"BC: Top tags are { [ top_side ] } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , [ bottom_side ], tag = 500 ) logger . debug ( f \"BC: Bottom tags are { [ bottom_side ] } \" ) gmsh . model . geo . addPhysicalGroup ( 2 , self . surf_tag , tag = 600 ) build_bl ( naca_tag : list [ int ], te_tag : int ) Builds the boundary layer around the airfoil. Source code in aero_optim/mesh/naca_base_mesh.py 101 102 103 104 105 106 107 108 109 110 111 112 113 def build_bl ( self , naca_tag : list [ int ], te_tag : int ): \"\"\" **Builds** the boundary layer around the airfoil. \"\"\" self . f = gmsh . model . mesh . field . add ( 'BoundaryLayer' ) gmsh . model . mesh . field . setNumbers ( self . f , 'CurvesList' , naca_tag ) gmsh . model . mesh . field . setNumber ( self . f , 'Size' , self . bl_size ) gmsh . model . mesh . field . setNumber ( self . f , 'Ratio' , self . bl_ratio ) gmsh . model . mesh . field . setNumber ( self . f , 'Quads' , int ( self . structured )) gmsh . model . mesh . field . setNumber ( self . f , 'Thickness' , self . bl_thickness ) gmsh . option . setNumber ( 'Mesh.BoundaryLayerFanElements' , self . bl_fan_elements ) gmsh . model . mesh . field . setNumbers ( self . f , 'FanPointsList' , [ te_tag ]) gmsh . model . mesh . field . setAsBoundaryLayer ( self . f ) split_naca () -> tuple [ list [ list [ float ]], list [ list [ float ]]] Returns the upper and lower parts of the airfoil as ordered lists (wrt the x axis). Note the trailing and leading edges are voluntarily excluded from both parts since the geometry is closed and these points must each have a unique tag. Source code in aero_optim/mesh/naca_base_mesh.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def split_naca ( self ) -> tuple [ list [ list [ float ]], list [ list [ float ]]]: \"\"\" **Returns** the upper and lower parts of the airfoil as ordered lists (wrt the x axis). Note: the trailing and leading edges are voluntarily excluded from both parts since the geometry is closed and these points must each have a unique tag. \"\"\" start : int = min ( self . idx_le , self . idx_te ) end : int = max ( self . idx_le , self . idx_te ) if ( max ([ p [ 1 ] for p in self . pts [ start : end + 1 ]]) > max ([ p [ 1 ] for p in self . pts [: start + 1 ] + self . pts [ end :]]) ): upper = [[ p [ 0 ], p [ 1 ], p [ 2 ]] for p in self . pts [ start + 1 : end ]] lower = [[ p [ 0 ], p [ 1 ], p [ 2 ]] for p in self . pts [: start ] + self . pts [ end + 1 :]] else : lower = [[ p [ 0 ], p [ 1 ], p [ 2 ]] for p in self . pts [ start + 1 : end ]] upper = [[ p [ 0 ], p [ 1 ], p [ 2 ]] for p in self . pts [: start ] + self . pts [ end + 1 :]] upper = sorted ( upper , key = lambda x : ( x [ 0 ]), reverse = True ) lower = sorted ( lower , key = lambda x : ( x [ 0 ])) return upper , lower mesh.naca_block_mesh.NACABlockMesh Bases: NACABaseMesh This class implements a blocking mesh routine for a naca profile based on: https://github.com/ComputationalDomain/CMesh_rae69ck-il Source code in aero_optim/mesh/naca_block_mesh.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 class NACABlockMesh ( NACABaseMesh ): \"\"\" This class implements a blocking mesh routine for a naca profile based on:</br> https://github.com/ComputationalDomain/CMesh_rae69ck-il \"\"\" def __init__ ( self , config : dict , datfile : str = \"\" ): \"\"\" Instantiates the BlockMesh object. **Input** - config (dict): the config file dictionary. - dat_file (str): path to input_geometry.dat. \"\"\" super () . __init__ ( config , datfile ) def build_2dmesh ( self ): \"\"\" **Builds** the surface mesh of the computational domain. **Inner** - R (float): radius of the outer circle. - d_out (float): distance to the outlet. - offset (int): offset from leading edge. - b_width (float): block_width. - n_inlet (int): nbr of lead edge & inlet nodes. - r_inlet (float): bump ratio of lead edge & inlet nodes. - n_vertical (int) : nbr of out & verti nodes. - r_vertical (float): out & vert growth. - n_airfoil (int): nbr of nodes on each sides. - r_airfoil (float): airfoil sides growth. - n_wake (int): nbr of nodes in the wake dir. - r_wake (float): wake growth. \"\"\" R = self . dinlet d_out = self . doutlet offset = self . config [ \"gmsh\" ][ \"domain\" ] . get ( \"le_offset\" , 10 ) b_width = self . config [ \"gmsh\" ][ \"domain\" ] . get ( \"block_width\" , 10 ) n_inlet = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"n_inlet\" , 60 ) r_inlet = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"r_inlet\" , 1. ) n_vertical = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"n_vertical\" , 90 ) r_vertical = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"r_vertical\" , 1 / 0.95 ) n_airfoil = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"n_airfoil\" , 50 ) r_airfoil = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"r_airfoil\" , 1 ) n_wake = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"n_wake\" , 100 ) r_wake = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"r_wake\" , 1 / 0.95 ) _ , self . idx_le = min (( p [ 0 ], idx ) for ( idx , p ) in enumerate ( self . pts )) _ , self . idx_te = max (( p [ 0 ], idx ) for ( idx , p ) in enumerate ( self . pts )) u_side , l_side = self . split_naca () # add points and lines for the naca lower and upper parts x_le , y_le = self . pts [ self . idx_le ][: 2 ] x_te , y_te = self . pts [ self . idx_te ][: 2 ] te_tag = gmsh . model . geo . addPoint ( x_te , y_te , 0. ) le_tag = gmsh . model . geo . addPoint ( x_le , y_le , 0. ) pt_u = [ te_tag ] + [ gmsh . model . geo . addPoint ( p [ 0 ], p [ 1 ], p [ 2 ]) for p in u_side ] pt_l = [ le_tag ] + \\ [ gmsh . model . geo . addPoint ( p [ 0 ], p [ 1 ], p [ 2 ]) for p in l_side ] + [ te_tag ] # airfoil boundary spline_low = gmsh . model . geo . addSpline ( pt_l [ offset :], tag = 1 ) spline_le = gmsh . model . geo . addSpline ( pt_u [ - offset :] + pt_l [: offset + 1 ], tag = 2 ) spline_up = gmsh . model . geo . addSpline ( pt_u [: - offset + 1 ], tag = 3 ) # domain and block construction points pt_229 = gmsh . model . geo . addPoint ( x_te - b_width , R , 0. , tag = 229 ) pt_230 = gmsh . model . geo . addPoint ( x_te - b_width , - R , 0. , tag = 230 ) pt_231 = gmsh . model . geo . addPoint ( x_te , R , 0. , tag = 231 ) pt_232 = gmsh . model . geo . addPoint ( x_te , - R , 0. , tag = 232 ) pt_233 = gmsh . model . geo . addPoint ( d_out , R , 0. , tag = 233 ) pt_234 = gmsh . model . geo . addPoint ( d_out , - R , 0. , tag = 234 ) pt_235 = gmsh . model . geo . addPoint ( d_out , 0 , 0. , tag = 235 ) # domain and block lines circle_4 = gmsh . model . geo . addCircleArc ( pt_230 , te_tag , pt_229 ) line_5 = gmsh . model . geo . addLine ( pt_u [ - offset ], pt_229 ) line_6 = gmsh . model . geo . addLine ( pt_l [ offset ], pt_230 ) line_7 = gmsh . model . geo . addLine ( pt_229 , pt_231 ) line_8 = gmsh . model . geo . addLine ( pt_230 , pt_232 ) line_9 = gmsh . model . geo . addLine ( pt_231 , pt_233 ) line_10 = gmsh . model . geo . addLine ( pt_232 , pt_234 ) line_11 = gmsh . model . geo . addLine ( pt_235 , pt_234 ) line_12 = gmsh . model . geo . addLine ( pt_235 , pt_233 ) line_13 = gmsh . model . geo . addLine ( te_tag , pt_231 ) line_14 = gmsh . model . geo . addLine ( te_tag , pt_232 ) line_15 = gmsh . model . geo . addLine ( te_tag , pt_235 ) # meshing parameters gmsh . model . geo . mesh . setTransfiniteCurve ( circle_4 , n_inlet , \"Bump\" , r_inlet ) gmsh . model . geo . mesh . setTransfiniteCurve ( spline_le , n_inlet , \"Bump\" , r_inlet ) _ = [ gmsh . model . geo . mesh . setTransfiniteCurve ( lid , n_vertical , \"Progression\" , r_vertical ) for lid in [ line_5 , line_6 , line_11 , line_12 , line_13 , line_14 ]] gmsh . model . geo . mesh . setTransfiniteCurve ( spline_low , n_airfoil , \"Bump\" , r_airfoil ) gmsh . model . geo . mesh . setTransfiniteCurve ( spline_up , n_airfoil , \"Bump\" , r_airfoil ) gmsh . model . geo . mesh . setTransfiniteCurve ( line_7 , n_airfoil , \"Bump\" , r_airfoil ) gmsh . model . geo . mesh . setTransfiniteCurve ( line_8 , n_airfoil , \"Bump\" , r_airfoil ) gmsh . model . geo . mesh . setTransfiniteCurve ( line_15 , n_wake , \"Progression\" , r_wake ) gmsh . model . geo . mesh . setTransfiniteCurve ( line_9 , n_wake , \"Progression\" , r_wake ) gmsh . model . geo . mesh . setTransfiniteCurve ( line_10 , n_wake , \"Progression\" , r_wake ) # domain and block surfaces cloop_1 = gmsh . model . geo . addCurveLoop ([ circle_4 , - line_5 , spline_le , line_6 ]) surf_1 = gmsh . model . geo . addPlaneSurface ([ - cloop_1 ], tag = 1001 ) gmsh . model . geo . mesh . setTransfiniteSurface ( surf_1 ) cloop_2 = gmsh . model . geo . addCurveLoop ([ line_5 , line_7 , - line_13 , spline_up ]) surf_2 = gmsh . model . geo . addPlaneSurface ([ - cloop_2 ], tag = 1002 ) gmsh . model . geo . mesh . setTransfiniteSurface ( surf_2 ) cloop_3 = gmsh . model . geo . addCurveLoop ([ line_13 , line_9 , - line_12 , - line_15 ]) surf_3 = gmsh . model . geo . addPlaneSurface ([ - cloop_3 ], tag = 1003 ) gmsh . model . geo . mesh . setTransfiniteSurface ( surf_3 ) cloop_4 = gmsh . model . geo . addCurveLoop ([ line_6 , line_8 , - line_14 , - spline_low ]) surf_4 = gmsh . model . geo . addPlaneSurface ([ - cloop_4 ], tag = 1004 ) gmsh . model . geo . mesh . setTransfiniteSurface ( surf_4 ) cloop_5 = gmsh . model . geo . addCurveLoop ([ line_14 , line_10 , - line_11 , - line_15 ]) surf_5 = gmsh . model . geo . addPlaneSurface ([ - cloop_5 ], tag = 1005 ) gmsh . model . geo . mesh . setTransfiniteSurface ( surf_5 ) # physical groups self . surf_tag = [ surf_1 , surf_2 , surf_3 , - surf_5 , - surf_4 ] gmsh . model . geo . addPhysicalGroup ( 2 , self . surf_tag , tag = 100 ) gmsh . model . geo . addPhysicalGroup ( 1 , [ circle_4 , line_7 , line_8 ], tag = 10 ) logger . debug ( f \"BC: Inlet tags are { [ circle_4 , line_7 , line_8 ] } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , [ line_11 , line_12 ], tag = 20 ) logger . debug ( f \"BC: Outlet tags are { [ line_11 , line_12 ] } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , [ line_9 , line_10 ], tag = 40 ) logger . debug ( f \"BC: Side tags are { [ line_9 , line_10 ] } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , [ spline_up , spline_le , spline_low ], tag = 30 ) logger . debug ( f \"BC: Wall tags are { [ spline_up , spline_le , spline_low ] } \" ) __init__ ( config : dict , datfile : str = '' ) Instantiates the BlockMesh object. Input config (dict): the config file dictionary. dat_file (str): path to input_geometry.dat. Source code in aero_optim/mesh/naca_block_mesh.py 14 15 16 17 18 19 20 21 22 23 def __init__ ( self , config : dict , datfile : str = \"\" ): \"\"\" Instantiates the BlockMesh object. **Input** - config (dict): the config file dictionary. - dat_file (str): path to input_geometry.dat. \"\"\" super () . __init__ ( config , datfile ) build_2dmesh () Builds the surface mesh of the computational domain. Inner R (float): radius of the outer circle. d_out (float): distance to the outlet. offset (int): offset from leading edge. b_width (float): block_width. n_inlet (int): nbr of lead edge & inlet nodes. r_inlet (float): bump ratio of lead edge & inlet nodes. n_vertical (int) : nbr of out & verti nodes. r_vertical (float): out & vert growth. n_airfoil (int): nbr of nodes on each sides. r_airfoil (float): airfoil sides growth. n_wake (int): nbr of nodes in the wake dir. r_wake (float): wake growth. Source code in aero_optim/mesh/naca_block_mesh.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def build_2dmesh ( self ): \"\"\" **Builds** the surface mesh of the computational domain. **Inner** - R (float): radius of the outer circle. - d_out (float): distance to the outlet. - offset (int): offset from leading edge. - b_width (float): block_width. - n_inlet (int): nbr of lead edge & inlet nodes. - r_inlet (float): bump ratio of lead edge & inlet nodes. - n_vertical (int) : nbr of out & verti nodes. - r_vertical (float): out & vert growth. - n_airfoil (int): nbr of nodes on each sides. - r_airfoil (float): airfoil sides growth. - n_wake (int): nbr of nodes in the wake dir. - r_wake (float): wake growth. \"\"\" R = self . dinlet d_out = self . doutlet offset = self . config [ \"gmsh\" ][ \"domain\" ] . get ( \"le_offset\" , 10 ) b_width = self . config [ \"gmsh\" ][ \"domain\" ] . get ( \"block_width\" , 10 ) n_inlet = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"n_inlet\" , 60 ) r_inlet = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"r_inlet\" , 1. ) n_vertical = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"n_vertical\" , 90 ) r_vertical = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"r_vertical\" , 1 / 0.95 ) n_airfoil = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"n_airfoil\" , 50 ) r_airfoil = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"r_airfoil\" , 1 ) n_wake = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"n_wake\" , 100 ) r_wake = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"r_wake\" , 1 / 0.95 ) _ , self . idx_le = min (( p [ 0 ], idx ) for ( idx , p ) in enumerate ( self . pts )) _ , self . idx_te = max (( p [ 0 ], idx ) for ( idx , p ) in enumerate ( self . pts )) u_side , l_side = self . split_naca () # add points and lines for the naca lower and upper parts x_le , y_le = self . pts [ self . idx_le ][: 2 ] x_te , y_te = self . pts [ self . idx_te ][: 2 ] te_tag = gmsh . model . geo . addPoint ( x_te , y_te , 0. ) le_tag = gmsh . model . geo . addPoint ( x_le , y_le , 0. ) pt_u = [ te_tag ] + [ gmsh . model . geo . addPoint ( p [ 0 ], p [ 1 ], p [ 2 ]) for p in u_side ] pt_l = [ le_tag ] + \\ [ gmsh . model . geo . addPoint ( p [ 0 ], p [ 1 ], p [ 2 ]) for p in l_side ] + [ te_tag ] # airfoil boundary spline_low = gmsh . model . geo . addSpline ( pt_l [ offset :], tag = 1 ) spline_le = gmsh . model . geo . addSpline ( pt_u [ - offset :] + pt_l [: offset + 1 ], tag = 2 ) spline_up = gmsh . model . geo . addSpline ( pt_u [: - offset + 1 ], tag = 3 ) # domain and block construction points pt_229 = gmsh . model . geo . addPoint ( x_te - b_width , R , 0. , tag = 229 ) pt_230 = gmsh . model . geo . addPoint ( x_te - b_width , - R , 0. , tag = 230 ) pt_231 = gmsh . model . geo . addPoint ( x_te , R , 0. , tag = 231 ) pt_232 = gmsh . model . geo . addPoint ( x_te , - R , 0. , tag = 232 ) pt_233 = gmsh . model . geo . addPoint ( d_out , R , 0. , tag = 233 ) pt_234 = gmsh . model . geo . addPoint ( d_out , - R , 0. , tag = 234 ) pt_235 = gmsh . model . geo . addPoint ( d_out , 0 , 0. , tag = 235 ) # domain and block lines circle_4 = gmsh . model . geo . addCircleArc ( pt_230 , te_tag , pt_229 ) line_5 = gmsh . model . geo . addLine ( pt_u [ - offset ], pt_229 ) line_6 = gmsh . model . geo . addLine ( pt_l [ offset ], pt_230 ) line_7 = gmsh . model . geo . addLine ( pt_229 , pt_231 ) line_8 = gmsh . model . geo . addLine ( pt_230 , pt_232 ) line_9 = gmsh . model . geo . addLine ( pt_231 , pt_233 ) line_10 = gmsh . model . geo . addLine ( pt_232 , pt_234 ) line_11 = gmsh . model . geo . addLine ( pt_235 , pt_234 ) line_12 = gmsh . model . geo . addLine ( pt_235 , pt_233 ) line_13 = gmsh . model . geo . addLine ( te_tag , pt_231 ) line_14 = gmsh . model . geo . addLine ( te_tag , pt_232 ) line_15 = gmsh . model . geo . addLine ( te_tag , pt_235 ) # meshing parameters gmsh . model . geo . mesh . setTransfiniteCurve ( circle_4 , n_inlet , \"Bump\" , r_inlet ) gmsh . model . geo . mesh . setTransfiniteCurve ( spline_le , n_inlet , \"Bump\" , r_inlet ) _ = [ gmsh . model . geo . mesh . setTransfiniteCurve ( lid , n_vertical , \"Progression\" , r_vertical ) for lid in [ line_5 , line_6 , line_11 , line_12 , line_13 , line_14 ]] gmsh . model . geo . mesh . setTransfiniteCurve ( spline_low , n_airfoil , \"Bump\" , r_airfoil ) gmsh . model . geo . mesh . setTransfiniteCurve ( spline_up , n_airfoil , \"Bump\" , r_airfoil ) gmsh . model . geo . mesh . setTransfiniteCurve ( line_7 , n_airfoil , \"Bump\" , r_airfoil ) gmsh . model . geo . mesh . setTransfiniteCurve ( line_8 , n_airfoil , \"Bump\" , r_airfoil ) gmsh . model . geo . mesh . setTransfiniteCurve ( line_15 , n_wake , \"Progression\" , r_wake ) gmsh . model . geo . mesh . setTransfiniteCurve ( line_9 , n_wake , \"Progression\" , r_wake ) gmsh . model . geo . mesh . setTransfiniteCurve ( line_10 , n_wake , \"Progression\" , r_wake ) # domain and block surfaces cloop_1 = gmsh . model . geo . addCurveLoop ([ circle_4 , - line_5 , spline_le , line_6 ]) surf_1 = gmsh . model . geo . addPlaneSurface ([ - cloop_1 ], tag = 1001 ) gmsh . model . geo . mesh . setTransfiniteSurface ( surf_1 ) cloop_2 = gmsh . model . geo . addCurveLoop ([ line_5 , line_7 , - line_13 , spline_up ]) surf_2 = gmsh . model . geo . addPlaneSurface ([ - cloop_2 ], tag = 1002 ) gmsh . model . geo . mesh . setTransfiniteSurface ( surf_2 ) cloop_3 = gmsh . model . geo . addCurveLoop ([ line_13 , line_9 , - line_12 , - line_15 ]) surf_3 = gmsh . model . geo . addPlaneSurface ([ - cloop_3 ], tag = 1003 ) gmsh . model . geo . mesh . setTransfiniteSurface ( surf_3 ) cloop_4 = gmsh . model . geo . addCurveLoop ([ line_6 , line_8 , - line_14 , - spline_low ]) surf_4 = gmsh . model . geo . addPlaneSurface ([ - cloop_4 ], tag = 1004 ) gmsh . model . geo . mesh . setTransfiniteSurface ( surf_4 ) cloop_5 = gmsh . model . geo . addCurveLoop ([ line_14 , line_10 , - line_11 , - line_15 ]) surf_5 = gmsh . model . geo . addPlaneSurface ([ - cloop_5 ], tag = 1005 ) gmsh . model . geo . mesh . setTransfiniteSurface ( surf_5 ) # physical groups self . surf_tag = [ surf_1 , surf_2 , surf_3 , - surf_5 , - surf_4 ] gmsh . model . geo . addPhysicalGroup ( 2 , self . surf_tag , tag = 100 ) gmsh . model . geo . addPhysicalGroup ( 1 , [ circle_4 , line_7 , line_8 ], tag = 10 ) logger . debug ( f \"BC: Inlet tags are { [ circle_4 , line_7 , line_8 ] } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , [ line_11 , line_12 ], tag = 20 ) logger . debug ( f \"BC: Outlet tags are { [ line_11 , line_12 ] } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , [ line_9 , line_10 ], tag = 40 ) logger . debug ( f \"BC: Side tags are { [ line_9 , line_10 ] } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , [ spline_up , spline_le , spline_low ], tag = 30 ) logger . debug ( f \"BC: Wall tags are { [ spline_up , spline_le , spline_low ] } \" ) mesh.cascade_mesh.CascadeMesh Bases: Mesh This class implements a mesh routine for a compressor cascade geometry. Source code in aero_optim/mesh/cascade_mesh.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 class CascadeMesh ( Mesh ): \"\"\" This class implements a mesh routine for a compressor cascade geometry. \"\"\" def __init__ ( self , config : dict , datfile : str = \"\" ): \"\"\" Instantiates the CascadeMesh object. **Input** - config (dict): the config file dictionary. - dat_file (str): path to input_geometry.dat. **Inner** - doutlet (float): outlet distance to the blade trailing edge. - dlr_mesh (bool): builds the DLR provided mesh (True) or a simpler for adaptation (False). - bl_sizefar (float): boundary layer mesh size far from the curves. - nodes_inlet (int): the number of nodes to mesh the inlet. - nodes_outlet (int): the number of nodes to mesh the outlet. - snodes_inlet (int): the number of nodes to mesh the inlet top and bottom sides. - snodes_outlet (int): the number of nodes to mesh the outlet top and bottom sides. - c_snodes (int): the number of nodes to mesh the inner sides. - le (int): the number of nodes to mesh the blade leading edge portion. - te (int): the number of nodes to mesh the blade trailing edge lower portion. - nodes_sp2 (int): the number of nodes to mesh the 1st section of the blade suction side. - nodes_sp3 (int): the number of nodes to mesh the 2nd section of the blade suction side. - nodes_sp4 (int): the number of nodes to mesh the 3rd section of the blade suction side. - nodes_sp7 (int): the number of nodes to mesh the 1st section of the blade pressure side. - nodes_sp8 (int): the number of nodes to mesh the 2nd section of the blade pressure side. - nodes_ss (int): the number of nodes to mesh the suction side (dlr_mesh set to False). - nodes_ps (int): the number of nodes to mesh the pressure side (dlr_mesh set to False). - cyl_vin (float): cylinder field parameter Vin. - cyl_vout (float): cylinder field parameter Vout. - cyl_xaxis (float): cylinder field parameter Xaxis. - cyl_xcenter (float): cylinder field parameter Xcenter. Note: for the DLR configuration, the blade is split into 9 splines (clockwise from the tip): * 2 splines (1 and 9) for the leading edge parameterized with **le** i.e. each spline has **le**/2 nodes, * 2 splines (5 and 6) for the trailing edge parameterized with **te** i.e. each spline has **te**/2 nodes, * 3 splines for the suction side (2, 3, 4) of lengths 0.027, 0.038 and 0.061 m, and parameterized with **nodes_sp2**, **nodes_sp3** and **nodes_sp4**, * 2 splines for the pressure side (7, 8) of lengths 0.0526 and 0.0167 m, and parameterized with **nodes_sp7**, **nodes_sp8** \"\"\" super () . __init__ ( config , datfile ) self . doutlet : float = self . config [ \"gmsh\" ][ \"domain\" ] . get ( \"outlet\" , 6.3e-2 ) self . dlr_mesh : bool = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"DLR_mesh\" , False ) self . bl_sizefar : float = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"bl_sizefar\" , 1e-5 ) self . nodes_inlet : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_inlet\" , 25 ) self . nodes_outlet : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_outlet\" , 17 ) self . snodes_inlet : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"side_nodes_inlet\" , 31 ) self . snodes_outlet : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"side_nodes_outlet\" , 31 ) self . c_snodes : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"curved_side_nodes\" , 7 ) self . le : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"le\" , 16 ) self . te : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"te\" , 16 ) self . nodes_sp2 : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_sp2\" , 42 ) self . nodes_sp3 : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_sp3\" , 42 ) self . nodes_sp4 : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_sp4\" , 14 ) self . nodes_sp7 : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_sp7\" , 57 ) self . nodes_sp8 : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_sp8\" , 32 ) self . nodes_ss : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_ss\" , 400 ) self . nodes_ps : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_ps\" , 400 ) self . cyl_vin : float = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"cyl_vin\" , 8e-4 ) self . cyl_vout : float = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"cyl_vout\" , 5e-3 ) self . cyl_xaxis : float = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"cyl_xaxis\" , 1.675e-2 ) self . cyl_xcenter : float = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"cyl_xcenter\" , 8.364e-2 ) def process_config ( self ): logger . debug ( \"processing config..\" ) if \"domain\" not in self . config [ \"gmsh\" ]: logger . debug ( f \"no <domain> entry in { self . config [ 'gmsh' ] } , empty entry added\" ) self . config [ \"gmsh\" ][ \"domain\" ] = {} def reorder_blade ( self ) -> list [ list [ float ]]: \"\"\" **Returns** the blade profile after reordering. \"\"\" d = np . sqrt ([ x ** 2 + y ** 2 for x , y , _ in self . pts ]) start = np . argmin ( d ) if self . pts [ start + 1 ][ 1 ] > self . pts [ start ][ 1 ]: return [[ p [ 0 ], p [ 1 ], p [ 2 ]] for p in self . pts [ start :] + self . pts [: start ]] else : return [[ p [ 0 ], p [ 1 ], p [ 2 ]] for p in self . pts [: start ] + self . pts [ start :]] def build_bl ( self , blade_tag : list [ int ]): \"\"\" **Builds** the boundary layer around the blade. \"\"\" f_bl = gmsh . model . mesh . field . add ( 'BoundaryLayer' ) gmsh . model . mesh . field . setNumbers ( f_bl , 'CurvesList' , blade_tag ) gmsh . model . mesh . field . setNumber ( f_bl , 'Size' , self . bl_size ) gmsh . model . mesh . field . setNumber ( f_bl , 'Ratio' , self . bl_ratio ) gmsh . model . mesh . field . setNumber ( f_bl , 'Quads' , int ( self . structured )) gmsh . model . mesh . field . setNumber ( f_bl , 'Thickness' , self . bl_thickness ) gmsh . model . mesh . field . setNumber ( f_bl , 'SizeFar' , self . bl_sizefar ) gmsh . model . mesh . field . setAsBoundaryLayer ( f_bl ) def build_cylinder_field ( self , radius : float , VIn : float , VOut : float , XAxis : float , XCenter : float , YAxis : float , YCenter : float , ZAxis : float = 0. ) -> int : \"\"\" **Builds** a cylinder field in the computational domain. \"\"\" f_cyl = gmsh . model . mesh . field . add ( 'Cylinder' ) gmsh . model . mesh . field . setNumber ( f_cyl , 'Radius' , radius ) gmsh . model . mesh . field . setNumber ( f_cyl , 'VIn' , VIn ) gmsh . model . mesh . field . setNumber ( f_cyl , 'VOut' , VOut ) gmsh . model . mesh . field . setNumber ( f_cyl , 'XAxis' , XAxis ) gmsh . model . mesh . field . setNumber ( f_cyl , 'XCenter' , XCenter ) gmsh . model . mesh . field . setNumber ( f_cyl , 'YAxis' , YAxis ) gmsh . model . mesh . field . setNumber ( f_cyl , 'YCenter' , YCenter ) gmsh . model . mesh . field . setNumber ( f_cyl , 'ZAxis' , ZAxis ) gmsh . model . mesh . field . setAsBackgroundMesh ( f_cyl ) return f_cyl def build_minaniso_field ( self , tag : list [ int ]): \"\"\" **Builds** a MinAniso field in the computational domain. \"\"\" f_minaniso = gmsh . model . mesh . field . add ( 'MinAniso' ) gmsh . model . mesh . field . setNumbers ( f_minaniso , 'FieldsList' , tag ) gmsh . model . mesh . field . setAsBackgroundMesh ( f_minaniso ) def build_2dmesh ( self ): \"\"\" **Builds** the surface mesh of the computational domain. \"\"\" wall = self . reorder_blade () pt_wall = [ gmsh . model . geo . addPoint ( p [ 0 ], p [ 1 ], p [ 2 ]) for p in wall ] # blade splines and transfinite curves if self . dlr_mesh : spl_1 = gmsh . model . geo . addSpline ( pt_wall [: 35 ]) spl_2 = gmsh . model . geo . addSpline ( pt_wall [ 35 - 1 : 88 ]) spl_3 = gmsh . model . geo . addSpline ( pt_wall [ 88 - 1 : 129 ]) spl_4 = gmsh . model . geo . addSpline ( pt_wall [ 129 - 1 : 157 ]) spl_5 = gmsh . model . geo . addSpline ( pt_wall [ 157 - 1 : 168 ]) spl_6 = gmsh . model . geo . addSpline ( pt_wall [ 168 - 1 : 179 ]) spl_7 = gmsh . model . geo . addSpline ( pt_wall [ 179 - 1 : 245 ]) spl_8 = gmsh . model . geo . addSpline ( pt_wall [ 245 - 1 : 287 ]) spl_9 = gmsh . model . geo . addSpline ( pt_wall [ 287 - 1 : 322 ] + [ pt_wall [ 0 ]]) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_1 , self . le // 2 , \"Progression\" , 1.02 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_2 , self . nodes_sp2 , \"Progression\" , 1.03 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_3 , self . nodes_sp3 , \"Progression\" , 1 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_4 , self . nodes_sp4 , \"Progression\" , 0.94 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_5 , self . te // 2 , \"Progression\" , 0.97 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_6 , self . te // 2 , \"Progression\" , 1.025 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_7 , self . nodes_sp7 , \"Progression\" , 1.015 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_8 , self . nodes_sp8 , \"Progression\" , 0.955 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_9 , self . le // 2 , \"Progression\" , 0.9 ) spl_list = [ spl_1 , spl_2 , spl_3 , spl_4 , spl_5 , spl_6 , spl_7 , spl_8 , spl_9 ] else : spl_le = gmsh . model . geo . addSpline ( pt_wall [ 287 - 1 : 322 ] + [ pt_wall [ 0 ]] + pt_wall [: 35 ]) spl_ss = gmsh . model . geo . addSpline ( pt_wall [ 35 - 1 : 88 ] + pt_wall [ 88 - 1 : 129 ] + pt_wall [ 129 - 1 : 157 ] ) spl_te = gmsh . model . geo . addSpline ( pt_wall [ 157 - 1 : 168 ] + pt_wall [ 168 - 1 : 179 ]) spl_ps = gmsh . model . geo . addSpline ( pt_wall [ 179 - 1 : 245 ] + pt_wall [ 245 - 1 : 287 ]) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_le , self . le , \"Progression\" , 1.0 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_ss , self . nodes_ss , \"Progression\" , 1.0 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_te , self . te , \"Progression\" , 1 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_ps , self . nodes_ps , \"Progression\" , 1.0 ) spl_list = [ spl_le , spl_ss , spl_te , spl_ps ] blade_loop = gmsh . model . geo . addCurveLoop ( spl_list ) # domain construction points pt_323 = gmsh . model . geo . addPoint ( - 6e-2 , - 5e-2 , 0. ) pt_324 = gmsh . model . geo . addPoint ( - 1.5e-2 , - 2.5e-2 , 0. ) pt_325 = gmsh . model . geo . addPoint ( 0. , - 1.7e-2 , 0. ) pt_326 = gmsh . model . geo . addPoint ( 1.270973e-02 , - 1.164466e-02 , 0. ) pt_327 = gmsh . model . geo . addPoint ( 2.585445e-02 , - 7.360298e-03 , 0. ) pt_328 = gmsh . model . geo . addPoint ( 3.934429e-02 , - 4.053609e-03 , 0. ) pt_329 = gmsh . model . geo . addPoint ( 5.308943e-02 , - 1.631280e-03 , 0. ) pt_330 = gmsh . model . geo . addPoint ( 6.7e-2 , 0. , 0. ) pt_331 = gmsh . model . geo . addPoint ( 6.7e-2 + self . doutlet , 0. , 0. ) pt_332 = gmsh . model . geo . addPoint ( 6.7e-2 + self . doutlet , 4.039e-2 , 0. ) pt_333 = gmsh . model . geo . addPoint ( 6.7e-2 , 4.039e-2 , 0. ) pt_334 = gmsh . model . geo . addPoint ( 5.308943e-02 , 3.875872e-02 , 0. ) pt_335 = gmsh . model . geo . addPoint ( 3.934429e-02 , 3.633639e-02 , 0. ) pt_336 = gmsh . model . geo . addPoint ( 2.585445e-02 , 3.302970e-02 , 0. ) pt_337 = gmsh . model . geo . addPoint ( 1.270973e-02 , 2.874534e-02 , 0. ) pt_338 = gmsh . model . geo . addPoint ( 0. , 2.339e-2 , 0. ) pt_339 = gmsh . model . geo . addPoint ( - 1.5e-2 , 1.539e-2 , 0. ) pt_340 = gmsh . model . geo . addPoint ( - 6e-2 , - 9.61e-3 , 0. ) # domain construction lines l_10 = gmsh . model . geo . addLine ( pt_340 , pt_323 , tag = 10 ) l_11 = gmsh . model . geo . addLine ( pt_323 , pt_324 , tag = 11 ) l_12 = gmsh . model . geo . addLine ( pt_339 , pt_340 , tag = 12 ) if self . dlr_mesh : l_13 = gmsh . model . geo . addLine ( pt_324 , pt_339 , tag = 13 ) l_14 = gmsh . model . geo . addLine ( pt_324 , pt_325 , tag = 14 ) l_15 = gmsh . model . geo . addLine ( pt_325 , pt_326 , tag = 15 ) l_16 = gmsh . model . geo . addLine ( pt_326 , pt_327 , tag = 16 ) l_17 = gmsh . model . geo . addLine ( pt_327 , pt_328 , tag = 17 ) l_18 = gmsh . model . geo . addLine ( pt_328 , pt_329 , tag = 18 ) l_19 = gmsh . model . geo . addLine ( pt_329 , pt_330 , tag = 19 ) l_20 = gmsh . model . geo . addLine ( pt_330 , pt_331 , tag = 20 ) l_21 = gmsh . model . geo . addLine ( pt_331 , pt_332 , tag = 21 ) l_22 = gmsh . model . geo . addLine ( pt_332 , pt_333 , tag = 22 ) l_23 = gmsh . model . geo . addLine ( pt_333 , pt_334 , tag = 23 ) l_24 = gmsh . model . geo . addLine ( pt_334 , pt_335 , tag = 24 ) l_25 = gmsh . model . geo . addLine ( pt_335 , pt_336 , tag = 25 ) l_26 = gmsh . model . geo . addLine ( pt_336 , pt_337 , tag = 26 ) l_27 = gmsh . model . geo . addLine ( pt_337 , pt_338 , tag = 27 ) l_28 = gmsh . model . geo . addLine ( pt_338 , pt_339 , tag = 28 ) # transfinite curves on non-blade boundaries gmsh . model . geo . mesh . setTransfiniteCurve ( l_10 , self . nodes_inlet , \"Progression\" , 1. ) if self . dlr_mesh : gmsh . model . geo . mesh . setTransfiniteCurve ( l_13 , self . nodes_inlet , \"Progression\" , 1. ) gmsh . model . geo . mesh . setTransfiniteCurve ( l_21 , self . nodes_outlet , \"Progression\" , 1. ) # bottom / top periodicity self . bottom_tags = [ l_11 , l_14 , l_15 , l_16 , l_17 , l_18 , l_19 , l_20 ] self . top_tags = [ l_12 , l_28 , l_27 , l_26 , l_25 , l_24 , l_23 , l_22 ] # bottom non-curved side nodes gmsh . model . geo . mesh . setTransfiniteCurve ( l_11 , self . snodes_inlet , \"Progression\" , 1. ) gmsh . model . geo . mesh . setTransfiniteCurve ( l_20 , self . snodes_outlet , \"Progression\" , 1. ) # bottom curved side nodes _ = [ gmsh . model . geo . mesh . setTransfiniteCurve ( l_i , self . c_snodes , \"Progression\" , 1. ) for l_i in self . bottom_tags [ 1 : - 1 ]] # periodic boundaries /y direction gmsh . model . geo . synchronize () translation = [ 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0.04039 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 ] for tid , bid in zip ( self . top_tags , self . bottom_tags ): gmsh . model . mesh . setPeriodic ( 1 , [ tid ], [ bid ], translation ) # closed curve loop and computational domain surface definition if self . dlr_mesh : cloop_2 = gmsh . model . geo . addCurveLoop ([ l_10 , l_11 , l_12 , l_13 ]) cloop_3 = gmsh . model . geo . addCurveLoop ( [ - l_13 , l_14 , l_15 , l_16 , l_17 , l_18 , l_19 , l_20 , l_21 , l_22 , l_23 , l_24 , l_25 , l_26 , l_27 , l_28 ,] ) surf_1 = gmsh . model . geo . addPlaneSurface ([ cloop_2 ], tag = 1002 ) surf_2 = gmsh . model . geo . addPlaneSurface ([ cloop_3 , blade_loop ], tag = 1003 ) gmsh . model . geo . mesh . setTransfiniteSurface ( surf_1 ) else : cloop_3 = gmsh . model . geo . addCurveLoop ( [ l_10 , l_11 , l_14 , l_15 , l_16 , l_17 , l_18 , l_19 , l_20 , l_21 , l_22 , l_23 , l_24 , l_25 , l_26 , l_27 , l_28 , l_12 ] ) surf_2 = gmsh . model . geo . addPlaneSurface ([ cloop_3 , blade_loop ], tag = 1003 ) # Fields definition # Boundary Layer self . build_bl ( spl_list ) if self . bl else 0 # Cylinder #1 f_cyl1 = self . build_cylinder_field ( 9e-3 , self . cyl_vin , self . cyl_vout , self . cyl_xaxis , self . cyl_xcenter , - 1.171e-3 , 1.9754e-2 ) # Cylinder #2 f_cyl2 = self . build_cylinder_field ( 1.62e-2 , 1.6e-3 , 5e-3 , 2.01e-2 , 8.699e-2 , - 1.406e-3 , 1.9519e-2 ) # MinAniso self . build_minaniso_field ([ f_cyl1 , f_cyl2 ]) # define physical groups for boundary conditions self . surf_tag = [ surf_1 , surf_2 ] if self . dlr_mesh else [ surf_2 ] if self . extrusion_layers == 0 : gmsh . model . geo . addPhysicalGroup ( 2 , self . surf_tag , tag = 100 , name = \"fluid\" ) gmsh . model . geo . addPhysicalGroup ( 1 , [ l_10 ], tag = 10 , name = \"inlet\" ) logger . debug ( f \"2D BC: Inlet tags are { [ l_10 ] } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , [ l_21 ], tag = 20 , name = \"outlet\" ) logger . debug ( f \"2D BC: Outlet tags are { [ l_21 ] } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , spl_list , tag = 30 , name = \"wall\" ) logger . debug ( f \"2D BC: Wall tags are { spl_list } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , self . top_tags , tag = 40 , name = \"periodic_vert_l\" ) logger . debug ( f \"2D BC: Top tags are { self . top_tags } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , self . bottom_tags , tag = 50 , name = \"periodic_vert_r\" ) logger . debug ( f \"2D BC: Bottom tags are { self . bottom_tags } \" ) else : gmsh . model . geo . addPhysicalGroup ( 2 , self . surf_tag , tag = 100 , name = \"periodic_span_l\" ) # non-corner points defined as flow-field, inner block line and wall nodes self . non_corner_tags . extend ([ abs ( s_tag ) for s_tag in self . surf_tag ]) self . non_corner_tags . extend ([ abs ( s_tag ) for s_tag in spl_list ]) if self . dlr_mesh : self . non_corner_tags . append ( abs ( l_13 )) def build_3dmesh ( self ): \"\"\" **Performs** an extrusion along the z axis. - h_size (float): the total extruded depth. \"\"\" h_size = self . extrusion_size self . ext_tag = [ gmsh . model . geo . extrude ( [( 2 , s )], 0 , 0 , h_size , [ self . extrusion_layers ], [ 1 ], True ) for s in self . surf_tag ] # retrieve extruded surfaces and volumes vol = [ tu [ - 1 ] for tu in [ self . ext_tag [ 0 ][ 1 ], self . ext_tag [ 1 ][ 1 ]]] top = [ tu [ - 1 ] for tu in [ self . ext_tag [ 0 ][ 0 ], self . ext_tag [ 1 ][ 0 ]]] # 1st block inlet = [ self . ext_tag [ 0 ][ 2 ][ - 1 ]] perlo = [ self . ext_tag [ 0 ][ 3 ][ - 1 ]] perup = [ self . ext_tag [ 0 ][ 5 ][ - 1 ]] # 2nd block perlo += [ tu [ - 1 ] for tu in self . ext_tag [ 1 ][ 3 : 10 ]] outlet = [ self . ext_tag [ 1 ][ 10 ][ - 1 ]] perup += [ tu [ - 1 ] for tu in self . ext_tag [ 1 ][ 11 : 18 ]] wall = [ tu [ - 1 ] for tu in self . ext_tag [ 1 ][ 18 :]] # create physical groups gmsh . model . geo . addPhysicalGroup ( 3 , vol , tag = 2000 , name = \"fluid\" ) logger . debug ( \"3D BC: vol tag is 2000\" ) gmsh . model . geo . addPhysicalGroup ( 2 , top , tag = 2001 , name = \"periodic_span_r\" ) logger . debug ( \"3D BC: periodic_span_l tag is 100\" ) logger . debug ( \"3D BC: periodic_span_r tag is 2001\" ) gmsh . model . geo . addPhysicalGroup ( 2 , perlo , tag = 2003 , name = \"periodic_vert_l\" ) logger . debug ( \"3D BC: periodic_vert_l tag is 2003\" ) gmsh . model . geo . addPhysicalGroup ( 2 , perup , tag = 2004 , name = \"periodic_vert_r\" ) logger . debug ( \"3D BC: periodic_vert_r tag is 2004\" ) gmsh . model . geo . addPhysicalGroup ( 2 , inlet , tag = 2005 , name = \"inlet\" ) logger . debug ( \"3D BC: inlet tag is 2005\" ) gmsh . model . geo . addPhysicalGroup ( 2 , outlet , tag = 2006 , name = \"outlet\" ) logger . debug ( \"3D BC: outlet tag is 2006\" ) gmsh . model . geo . addPhysicalGroup ( 2 , wall , tag = 2007 , name = \"wall\" ) logger . debug ( \"3D BC: wall tag is 2007\" ) # set 2 tags to none to prevent reformatting self . non_corner_tags = None self . bottom_tags = None self . top_tags = None __init__ ( config : dict , datfile : str = '' ) Instantiates the CascadeMesh object. Input config (dict): the config file dictionary. dat_file (str): path to input_geometry.dat. Inner doutlet (float): outlet distance to the blade trailing edge. dlr_mesh (bool): builds the DLR provided mesh (True) or a simpler for adaptation (False). bl_sizefar (float): boundary layer mesh size far from the curves. nodes_inlet (int): the number of nodes to mesh the inlet. nodes_outlet (int): the number of nodes to mesh the outlet. snodes_inlet (int): the number of nodes to mesh the inlet top and bottom sides. snodes_outlet (int): the number of nodes to mesh the outlet top and bottom sides. c_snodes (int): the number of nodes to mesh the inner sides. le (int): the number of nodes to mesh the blade leading edge portion. te (int): the number of nodes to mesh the blade trailing edge lower portion. nodes_sp2 (int): the number of nodes to mesh the 1st section of the blade suction side. nodes_sp3 (int): the number of nodes to mesh the 2nd section of the blade suction side. nodes_sp4 (int): the number of nodes to mesh the 3rd section of the blade suction side. nodes_sp7 (int): the number of nodes to mesh the 1st section of the blade pressure side. nodes_sp8 (int): the number of nodes to mesh the 2nd section of the blade pressure side. nodes_ss (int): the number of nodes to mesh the suction side (dlr_mesh set to False). nodes_ps (int): the number of nodes to mesh the pressure side (dlr_mesh set to False). cyl_vin (float): cylinder field parameter Vin. cyl_vout (float): cylinder field parameter Vout. cyl_xaxis (float): cylinder field parameter Xaxis. cyl_xcenter (float): cylinder field parameter Xcenter. Note for the DLR configuration, the blade is split into 9 splines (clockwise from the tip): 2 splines (1 and 9) for the leading edge parameterized with le i.e. each spline has le /2 nodes, 2 splines (5 and 6) for the trailing edge parameterized with te i.e. each spline has te /2 nodes, 3 splines for the suction side (2, 3, 4) of lengths 0.027, 0.038 and 0.061 m, and parameterized with nodes_sp2 , nodes_sp3 and nodes_sp4 , 2 splines for the pressure side (7, 8) of lengths 0.0526 and 0.0167 m, and parameterized with nodes_sp7 , nodes_sp8 Source code in aero_optim/mesh/cascade_mesh.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def __init__ ( self , config : dict , datfile : str = \"\" ): \"\"\" Instantiates the CascadeMesh object. **Input** - config (dict): the config file dictionary. - dat_file (str): path to input_geometry.dat. **Inner** - doutlet (float): outlet distance to the blade trailing edge. - dlr_mesh (bool): builds the DLR provided mesh (True) or a simpler for adaptation (False). - bl_sizefar (float): boundary layer mesh size far from the curves. - nodes_inlet (int): the number of nodes to mesh the inlet. - nodes_outlet (int): the number of nodes to mesh the outlet. - snodes_inlet (int): the number of nodes to mesh the inlet top and bottom sides. - snodes_outlet (int): the number of nodes to mesh the outlet top and bottom sides. - c_snodes (int): the number of nodes to mesh the inner sides. - le (int): the number of nodes to mesh the blade leading edge portion. - te (int): the number of nodes to mesh the blade trailing edge lower portion. - nodes_sp2 (int): the number of nodes to mesh the 1st section of the blade suction side. - nodes_sp3 (int): the number of nodes to mesh the 2nd section of the blade suction side. - nodes_sp4 (int): the number of nodes to mesh the 3rd section of the blade suction side. - nodes_sp7 (int): the number of nodes to mesh the 1st section of the blade pressure side. - nodes_sp8 (int): the number of nodes to mesh the 2nd section of the blade pressure side. - nodes_ss (int): the number of nodes to mesh the suction side (dlr_mesh set to False). - nodes_ps (int): the number of nodes to mesh the pressure side (dlr_mesh set to False). - cyl_vin (float): cylinder field parameter Vin. - cyl_vout (float): cylinder field parameter Vout. - cyl_xaxis (float): cylinder field parameter Xaxis. - cyl_xcenter (float): cylinder field parameter Xcenter. Note: for the DLR configuration, the blade is split into 9 splines (clockwise from the tip): * 2 splines (1 and 9) for the leading edge parameterized with **le** i.e. each spline has **le**/2 nodes, * 2 splines (5 and 6) for the trailing edge parameterized with **te** i.e. each spline has **te**/2 nodes, * 3 splines for the suction side (2, 3, 4) of lengths 0.027, 0.038 and 0.061 m, and parameterized with **nodes_sp2**, **nodes_sp3** and **nodes_sp4**, * 2 splines for the pressure side (7, 8) of lengths 0.0526 and 0.0167 m, and parameterized with **nodes_sp7**, **nodes_sp8** \"\"\" super () . __init__ ( config , datfile ) self . doutlet : float = self . config [ \"gmsh\" ][ \"domain\" ] . get ( \"outlet\" , 6.3e-2 ) self . dlr_mesh : bool = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"DLR_mesh\" , False ) self . bl_sizefar : float = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"bl_sizefar\" , 1e-5 ) self . nodes_inlet : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_inlet\" , 25 ) self . nodes_outlet : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_outlet\" , 17 ) self . snodes_inlet : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"side_nodes_inlet\" , 31 ) self . snodes_outlet : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"side_nodes_outlet\" , 31 ) self . c_snodes : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"curved_side_nodes\" , 7 ) self . le : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"le\" , 16 ) self . te : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"te\" , 16 ) self . nodes_sp2 : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_sp2\" , 42 ) self . nodes_sp3 : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_sp3\" , 42 ) self . nodes_sp4 : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_sp4\" , 14 ) self . nodes_sp7 : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_sp7\" , 57 ) self . nodes_sp8 : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_sp8\" , 32 ) self . nodes_ss : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_ss\" , 400 ) self . nodes_ps : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_ps\" , 400 ) self . cyl_vin : float = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"cyl_vin\" , 8e-4 ) self . cyl_vout : float = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"cyl_vout\" , 5e-3 ) self . cyl_xaxis : float = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"cyl_xaxis\" , 1.675e-2 ) self . cyl_xcenter : float = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"cyl_xcenter\" , 8.364e-2 ) build_2dmesh () Builds the surface mesh of the computational domain. Source code in aero_optim/mesh/cascade_mesh.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 def build_2dmesh ( self ): \"\"\" **Builds** the surface mesh of the computational domain. \"\"\" wall = self . reorder_blade () pt_wall = [ gmsh . model . geo . addPoint ( p [ 0 ], p [ 1 ], p [ 2 ]) for p in wall ] # blade splines and transfinite curves if self . dlr_mesh : spl_1 = gmsh . model . geo . addSpline ( pt_wall [: 35 ]) spl_2 = gmsh . model . geo . addSpline ( pt_wall [ 35 - 1 : 88 ]) spl_3 = gmsh . model . geo . addSpline ( pt_wall [ 88 - 1 : 129 ]) spl_4 = gmsh . model . geo . addSpline ( pt_wall [ 129 - 1 : 157 ]) spl_5 = gmsh . model . geo . addSpline ( pt_wall [ 157 - 1 : 168 ]) spl_6 = gmsh . model . geo . addSpline ( pt_wall [ 168 - 1 : 179 ]) spl_7 = gmsh . model . geo . addSpline ( pt_wall [ 179 - 1 : 245 ]) spl_8 = gmsh . model . geo . addSpline ( pt_wall [ 245 - 1 : 287 ]) spl_9 = gmsh . model . geo . addSpline ( pt_wall [ 287 - 1 : 322 ] + [ pt_wall [ 0 ]]) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_1 , self . le // 2 , \"Progression\" , 1.02 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_2 , self . nodes_sp2 , \"Progression\" , 1.03 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_3 , self . nodes_sp3 , \"Progression\" , 1 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_4 , self . nodes_sp4 , \"Progression\" , 0.94 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_5 , self . te // 2 , \"Progression\" , 0.97 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_6 , self . te // 2 , \"Progression\" , 1.025 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_7 , self . nodes_sp7 , \"Progression\" , 1.015 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_8 , self . nodes_sp8 , \"Progression\" , 0.955 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_9 , self . le // 2 , \"Progression\" , 0.9 ) spl_list = [ spl_1 , spl_2 , spl_3 , spl_4 , spl_5 , spl_6 , spl_7 , spl_8 , spl_9 ] else : spl_le = gmsh . model . geo . addSpline ( pt_wall [ 287 - 1 : 322 ] + [ pt_wall [ 0 ]] + pt_wall [: 35 ]) spl_ss = gmsh . model . geo . addSpline ( pt_wall [ 35 - 1 : 88 ] + pt_wall [ 88 - 1 : 129 ] + pt_wall [ 129 - 1 : 157 ] ) spl_te = gmsh . model . geo . addSpline ( pt_wall [ 157 - 1 : 168 ] + pt_wall [ 168 - 1 : 179 ]) spl_ps = gmsh . model . geo . addSpline ( pt_wall [ 179 - 1 : 245 ] + pt_wall [ 245 - 1 : 287 ]) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_le , self . le , \"Progression\" , 1.0 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_ss , self . nodes_ss , \"Progression\" , 1.0 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_te , self . te , \"Progression\" , 1 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_ps , self . nodes_ps , \"Progression\" , 1.0 ) spl_list = [ spl_le , spl_ss , spl_te , spl_ps ] blade_loop = gmsh . model . geo . addCurveLoop ( spl_list ) # domain construction points pt_323 = gmsh . model . geo . addPoint ( - 6e-2 , - 5e-2 , 0. ) pt_324 = gmsh . model . geo . addPoint ( - 1.5e-2 , - 2.5e-2 , 0. ) pt_325 = gmsh . model . geo . addPoint ( 0. , - 1.7e-2 , 0. ) pt_326 = gmsh . model . geo . addPoint ( 1.270973e-02 , - 1.164466e-02 , 0. ) pt_327 = gmsh . model . geo . addPoint ( 2.585445e-02 , - 7.360298e-03 , 0. ) pt_328 = gmsh . model . geo . addPoint ( 3.934429e-02 , - 4.053609e-03 , 0. ) pt_329 = gmsh . model . geo . addPoint ( 5.308943e-02 , - 1.631280e-03 , 0. ) pt_330 = gmsh . model . geo . addPoint ( 6.7e-2 , 0. , 0. ) pt_331 = gmsh . model . geo . addPoint ( 6.7e-2 + self . doutlet , 0. , 0. ) pt_332 = gmsh . model . geo . addPoint ( 6.7e-2 + self . doutlet , 4.039e-2 , 0. ) pt_333 = gmsh . model . geo . addPoint ( 6.7e-2 , 4.039e-2 , 0. ) pt_334 = gmsh . model . geo . addPoint ( 5.308943e-02 , 3.875872e-02 , 0. ) pt_335 = gmsh . model . geo . addPoint ( 3.934429e-02 , 3.633639e-02 , 0. ) pt_336 = gmsh . model . geo . addPoint ( 2.585445e-02 , 3.302970e-02 , 0. ) pt_337 = gmsh . model . geo . addPoint ( 1.270973e-02 , 2.874534e-02 , 0. ) pt_338 = gmsh . model . geo . addPoint ( 0. , 2.339e-2 , 0. ) pt_339 = gmsh . model . geo . addPoint ( - 1.5e-2 , 1.539e-2 , 0. ) pt_340 = gmsh . model . geo . addPoint ( - 6e-2 , - 9.61e-3 , 0. ) # domain construction lines l_10 = gmsh . model . geo . addLine ( pt_340 , pt_323 , tag = 10 ) l_11 = gmsh . model . geo . addLine ( pt_323 , pt_324 , tag = 11 ) l_12 = gmsh . model . geo . addLine ( pt_339 , pt_340 , tag = 12 ) if self . dlr_mesh : l_13 = gmsh . model . geo . addLine ( pt_324 , pt_339 , tag = 13 ) l_14 = gmsh . model . geo . addLine ( pt_324 , pt_325 , tag = 14 ) l_15 = gmsh . model . geo . addLine ( pt_325 , pt_326 , tag = 15 ) l_16 = gmsh . model . geo . addLine ( pt_326 , pt_327 , tag = 16 ) l_17 = gmsh . model . geo . addLine ( pt_327 , pt_328 , tag = 17 ) l_18 = gmsh . model . geo . addLine ( pt_328 , pt_329 , tag = 18 ) l_19 = gmsh . model . geo . addLine ( pt_329 , pt_330 , tag = 19 ) l_20 = gmsh . model . geo . addLine ( pt_330 , pt_331 , tag = 20 ) l_21 = gmsh . model . geo . addLine ( pt_331 , pt_332 , tag = 21 ) l_22 = gmsh . model . geo . addLine ( pt_332 , pt_333 , tag = 22 ) l_23 = gmsh . model . geo . addLine ( pt_333 , pt_334 , tag = 23 ) l_24 = gmsh . model . geo . addLine ( pt_334 , pt_335 , tag = 24 ) l_25 = gmsh . model . geo . addLine ( pt_335 , pt_336 , tag = 25 ) l_26 = gmsh . model . geo . addLine ( pt_336 , pt_337 , tag = 26 ) l_27 = gmsh . model . geo . addLine ( pt_337 , pt_338 , tag = 27 ) l_28 = gmsh . model . geo . addLine ( pt_338 , pt_339 , tag = 28 ) # transfinite curves on non-blade boundaries gmsh . model . geo . mesh . setTransfiniteCurve ( l_10 , self . nodes_inlet , \"Progression\" , 1. ) if self . dlr_mesh : gmsh . model . geo . mesh . setTransfiniteCurve ( l_13 , self . nodes_inlet , \"Progression\" , 1. ) gmsh . model . geo . mesh . setTransfiniteCurve ( l_21 , self . nodes_outlet , \"Progression\" , 1. ) # bottom / top periodicity self . bottom_tags = [ l_11 , l_14 , l_15 , l_16 , l_17 , l_18 , l_19 , l_20 ] self . top_tags = [ l_12 , l_28 , l_27 , l_26 , l_25 , l_24 , l_23 , l_22 ] # bottom non-curved side nodes gmsh . model . geo . mesh . setTransfiniteCurve ( l_11 , self . snodes_inlet , \"Progression\" , 1. ) gmsh . model . geo . mesh . setTransfiniteCurve ( l_20 , self . snodes_outlet , \"Progression\" , 1. ) # bottom curved side nodes _ = [ gmsh . model . geo . mesh . setTransfiniteCurve ( l_i , self . c_snodes , \"Progression\" , 1. ) for l_i in self . bottom_tags [ 1 : - 1 ]] # periodic boundaries /y direction gmsh . model . geo . synchronize () translation = [ 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0.04039 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 ] for tid , bid in zip ( self . top_tags , self . bottom_tags ): gmsh . model . mesh . setPeriodic ( 1 , [ tid ], [ bid ], translation ) # closed curve loop and computational domain surface definition if self . dlr_mesh : cloop_2 = gmsh . model . geo . addCurveLoop ([ l_10 , l_11 , l_12 , l_13 ]) cloop_3 = gmsh . model . geo . addCurveLoop ( [ - l_13 , l_14 , l_15 , l_16 , l_17 , l_18 , l_19 , l_20 , l_21 , l_22 , l_23 , l_24 , l_25 , l_26 , l_27 , l_28 ,] ) surf_1 = gmsh . model . geo . addPlaneSurface ([ cloop_2 ], tag = 1002 ) surf_2 = gmsh . model . geo . addPlaneSurface ([ cloop_3 , blade_loop ], tag = 1003 ) gmsh . model . geo . mesh . setTransfiniteSurface ( surf_1 ) else : cloop_3 = gmsh . model . geo . addCurveLoop ( [ l_10 , l_11 , l_14 , l_15 , l_16 , l_17 , l_18 , l_19 , l_20 , l_21 , l_22 , l_23 , l_24 , l_25 , l_26 , l_27 , l_28 , l_12 ] ) surf_2 = gmsh . model . geo . addPlaneSurface ([ cloop_3 , blade_loop ], tag = 1003 ) # Fields definition # Boundary Layer self . build_bl ( spl_list ) if self . bl else 0 # Cylinder #1 f_cyl1 = self . build_cylinder_field ( 9e-3 , self . cyl_vin , self . cyl_vout , self . cyl_xaxis , self . cyl_xcenter , - 1.171e-3 , 1.9754e-2 ) # Cylinder #2 f_cyl2 = self . build_cylinder_field ( 1.62e-2 , 1.6e-3 , 5e-3 , 2.01e-2 , 8.699e-2 , - 1.406e-3 , 1.9519e-2 ) # MinAniso self . build_minaniso_field ([ f_cyl1 , f_cyl2 ]) # define physical groups for boundary conditions self . surf_tag = [ surf_1 , surf_2 ] if self . dlr_mesh else [ surf_2 ] if self . extrusion_layers == 0 : gmsh . model . geo . addPhysicalGroup ( 2 , self . surf_tag , tag = 100 , name = \"fluid\" ) gmsh . model . geo . addPhysicalGroup ( 1 , [ l_10 ], tag = 10 , name = \"inlet\" ) logger . debug ( f \"2D BC: Inlet tags are { [ l_10 ] } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , [ l_21 ], tag = 20 , name = \"outlet\" ) logger . debug ( f \"2D BC: Outlet tags are { [ l_21 ] } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , spl_list , tag = 30 , name = \"wall\" ) logger . debug ( f \"2D BC: Wall tags are { spl_list } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , self . top_tags , tag = 40 , name = \"periodic_vert_l\" ) logger . debug ( f \"2D BC: Top tags are { self . top_tags } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , self . bottom_tags , tag = 50 , name = \"periodic_vert_r\" ) logger . debug ( f \"2D BC: Bottom tags are { self . bottom_tags } \" ) else : gmsh . model . geo . addPhysicalGroup ( 2 , self . surf_tag , tag = 100 , name = \"periodic_span_l\" ) # non-corner points defined as flow-field, inner block line and wall nodes self . non_corner_tags . extend ([ abs ( s_tag ) for s_tag in self . surf_tag ]) self . non_corner_tags . extend ([ abs ( s_tag ) for s_tag in spl_list ]) if self . dlr_mesh : self . non_corner_tags . append ( abs ( l_13 )) build_3dmesh () Performs an extrusion along the z axis. - h_size (float): the total extruded depth. Source code in aero_optim/mesh/cascade_mesh.py 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 def build_3dmesh ( self ): \"\"\" **Performs** an extrusion along the z axis. - h_size (float): the total extruded depth. \"\"\" h_size = self . extrusion_size self . ext_tag = [ gmsh . model . geo . extrude ( [( 2 , s )], 0 , 0 , h_size , [ self . extrusion_layers ], [ 1 ], True ) for s in self . surf_tag ] # retrieve extruded surfaces and volumes vol = [ tu [ - 1 ] for tu in [ self . ext_tag [ 0 ][ 1 ], self . ext_tag [ 1 ][ 1 ]]] top = [ tu [ - 1 ] for tu in [ self . ext_tag [ 0 ][ 0 ], self . ext_tag [ 1 ][ 0 ]]] # 1st block inlet = [ self . ext_tag [ 0 ][ 2 ][ - 1 ]] perlo = [ self . ext_tag [ 0 ][ 3 ][ - 1 ]] perup = [ self . ext_tag [ 0 ][ 5 ][ - 1 ]] # 2nd block perlo += [ tu [ - 1 ] for tu in self . ext_tag [ 1 ][ 3 : 10 ]] outlet = [ self . ext_tag [ 1 ][ 10 ][ - 1 ]] perup += [ tu [ - 1 ] for tu in self . ext_tag [ 1 ][ 11 : 18 ]] wall = [ tu [ - 1 ] for tu in self . ext_tag [ 1 ][ 18 :]] # create physical groups gmsh . model . geo . addPhysicalGroup ( 3 , vol , tag = 2000 , name = \"fluid\" ) logger . debug ( \"3D BC: vol tag is 2000\" ) gmsh . model . geo . addPhysicalGroup ( 2 , top , tag = 2001 , name = \"periodic_span_r\" ) logger . debug ( \"3D BC: periodic_span_l tag is 100\" ) logger . debug ( \"3D BC: periodic_span_r tag is 2001\" ) gmsh . model . geo . addPhysicalGroup ( 2 , perlo , tag = 2003 , name = \"periodic_vert_l\" ) logger . debug ( \"3D BC: periodic_vert_l tag is 2003\" ) gmsh . model . geo . addPhysicalGroup ( 2 , perup , tag = 2004 , name = \"periodic_vert_r\" ) logger . debug ( \"3D BC: periodic_vert_r tag is 2004\" ) gmsh . model . geo . addPhysicalGroup ( 2 , inlet , tag = 2005 , name = \"inlet\" ) logger . debug ( \"3D BC: inlet tag is 2005\" ) gmsh . model . geo . addPhysicalGroup ( 2 , outlet , tag = 2006 , name = \"outlet\" ) logger . debug ( \"3D BC: outlet tag is 2006\" ) gmsh . model . geo . addPhysicalGroup ( 2 , wall , tag = 2007 , name = \"wall\" ) logger . debug ( \"3D BC: wall tag is 2007\" ) # set 2 tags to none to prevent reformatting self . non_corner_tags = None self . bottom_tags = None self . top_tags = None build_bl ( blade_tag : list [ int ]) Builds the boundary layer around the blade. Source code in aero_optim/mesh/cascade_mesh.py 100 101 102 103 104 105 106 107 108 109 110 111 def build_bl ( self , blade_tag : list [ int ]): \"\"\" **Builds** the boundary layer around the blade. \"\"\" f_bl = gmsh . model . mesh . field . add ( 'BoundaryLayer' ) gmsh . model . mesh . field . setNumbers ( f_bl , 'CurvesList' , blade_tag ) gmsh . model . mesh . field . setNumber ( f_bl , 'Size' , self . bl_size ) gmsh . model . mesh . field . setNumber ( f_bl , 'Ratio' , self . bl_ratio ) gmsh . model . mesh . field . setNumber ( f_bl , 'Quads' , int ( self . structured )) gmsh . model . mesh . field . setNumber ( f_bl , 'Thickness' , self . bl_thickness ) gmsh . model . mesh . field . setNumber ( f_bl , 'SizeFar' , self . bl_sizefar ) gmsh . model . mesh . field . setAsBoundaryLayer ( f_bl ) build_cylinder_field ( radius : float , VIn : float , VOut : float , XAxis : float , XCenter : float , YAxis : float , YCenter : float , ZAxis : float = 0.0 ) -> int Builds a cylinder field in the computational domain. Source code in aero_optim/mesh/cascade_mesh.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 def build_cylinder_field ( self , radius : float , VIn : float , VOut : float , XAxis : float , XCenter : float , YAxis : float , YCenter : float , ZAxis : float = 0. ) -> int : \"\"\" **Builds** a cylinder field in the computational domain. \"\"\" f_cyl = gmsh . model . mesh . field . add ( 'Cylinder' ) gmsh . model . mesh . field . setNumber ( f_cyl , 'Radius' , radius ) gmsh . model . mesh . field . setNumber ( f_cyl , 'VIn' , VIn ) gmsh . model . mesh . field . setNumber ( f_cyl , 'VOut' , VOut ) gmsh . model . mesh . field . setNumber ( f_cyl , 'XAxis' , XAxis ) gmsh . model . mesh . field . setNumber ( f_cyl , 'XCenter' , XCenter ) gmsh . model . mesh . field . setNumber ( f_cyl , 'YAxis' , YAxis ) gmsh . model . mesh . field . setNumber ( f_cyl , 'YCenter' , YCenter ) gmsh . model . mesh . field . setNumber ( f_cyl , 'ZAxis' , ZAxis ) gmsh . model . mesh . field . setAsBackgroundMesh ( f_cyl ) return f_cyl build_minaniso_field ( tag : list [ int ]) Builds a MinAniso field in the computational domain. Source code in aero_optim/mesh/cascade_mesh.py 134 135 136 137 138 139 140 def build_minaniso_field ( self , tag : list [ int ]): \"\"\" **Builds** a MinAniso field in the computational domain. \"\"\" f_minaniso = gmsh . model . mesh . field . add ( 'MinAniso' ) gmsh . model . mesh . field . setNumbers ( f_minaniso , 'FieldsList' , tag ) gmsh . model . mesh . field . setAsBackgroundMesh ( f_minaniso ) reorder_blade () -> list [ list [ float ]] Returns the blade profile after reordering. Source code in aero_optim/mesh/cascade_mesh.py 89 90 91 92 93 94 95 96 97 98 def reorder_blade ( self ) -> list [ list [ float ]]: \"\"\" **Returns** the blade profile after reordering. \"\"\" d = np . sqrt ([ x ** 2 + y ** 2 for x , y , _ in self . pts ]) start = np . argmin ( d ) if self . pts [ start + 1 ][ 1 ] > self . pts [ start ][ 1 ]: return [[ p [ 0 ], p [ 1 ], p [ 2 ]] for p in self . pts [ start :] + self . pts [: start ]] else : return [[ p [ 0 ], p [ 1 ], p [ 2 ]] for p in self . pts [: start ] + self . pts [ start :]]","title":"Mesh Module"},{"location":"dev_mesh/#mesh-source-code","text":"","title":"Mesh Source Code"},{"location":"dev_mesh/#mesh.mesh.Mesh","text":"Bases: ABC This class implements an abstract meshing class. Source code in aero_optim/mesh/mesh.py 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 class Mesh ( ABC ): \"\"\" This class implements an abstract meshing class. \"\"\" def __init__ ( self , config : dict , datfile : str = \"\" ): \"\"\" Instantiates the abstract Mesh object. **Input** - config (dict): the config file dictionary. - dat_file (str): path to input_geometry.dat. **Inner** - outdir (str): path/to/outputdirectory - outfile (str): the core name of all outputed files e.g. outfile.log, outfile.mesh, etc. - header (int): the number of header lines in dat_file. - geom_scale (float): geometry scaling factor. - mesh_format (str): the mesh format (mesh or cgns). - bl (bool): whether to mesh the boundary layer (True) or not (False). - bl_thickness (float): the BL meshing cumulated thickness. - bl_ratio (float): the BL meshing growth ratio. - bl_size (float): the BL first element size. - bl_fan_elements (int): the number of BL fan elements. - mesh_order (int): the order of the mesh. - structured (bool): whether to recombine triangles (True) or not (False). - extrusion_layers (int): the number of extrusion layers when generating a 3D mesh. - extrusion_size (float): the total size of the extruded layers. - GUI (bool): whether to launch gmsh GUI (True) or not (False). - nview (int): the number of sub-windows in gmsh GUI. - quality (bool): whether to display quality metrics in gmsh GUI (True) or not (False). - pts (list[list[float]]): the geometry coordinates. - surf_tag (list[int]): flow-field elements tags used to recombine the mesh if structured. - non_corner_tags (list[int]): non-corner physical entity tags used to define 'Corners'. - lower_tag (list[int]): lower periodic tags to be identified as one. - lower_tag (list[int]): upper periodic tags to be identified as one. \"\"\" self . config = config self . process_config () # study params self . dat_file : str = datfile if datfile else config [ \"study\" ][ \"file\" ] self . outdir : str = config [ \"study\" ][ \"outdir\" ] self . outfile = self . config [ \"study\" ] . get ( \"outfile\" , self . dat_file . split ( \"/\" )[ - 1 ][: - 4 ]) # mesh params (geom, format & boundary layer) self . header : int = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"header\" , 2 ) self . geom_scale : int = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"scale\" , 1 ) self . mesh_format : str = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"mesh_format\" , \"mesh\" ) . lower () self . bl : bool = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"bl\" , False ) self . bl_thickness : float = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"bl_thickness\" , 1e-3 ) self . bl_ratio : float = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"bl_ratio\" , 1.1 ) self . bl_size : float = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"bl_size\" , 1e-5 ) self . bl_fan_elements : int = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"bl_fan_elements\" , 10 ) self . mesh_order : int = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"order\" , 0 ) # mesh params (3d extrusion) self . structured : bool = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"structured\" , False ) self . extrusion_layers : int = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"extrusion_layers\" , 0 ) self . extrusion_size : int = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"extrusion_size\" , 0.001 ) # gui options self . GUI : bool = config [ \"gmsh\" ][ \"view\" ] . get ( \"GUI\" , True ) self . nview : int = config [ \"gmsh\" ][ \"view\" ] . get ( \"nview\" , 1 ) self . quality : bool = config [ \"gmsh\" ][ \"view\" ] . get ( \"quality\" , False ) # geometry coordinates loading self . pts : list [ list [ float ]] = from_dat ( self . dat_file , self . header , self . geom_scale ) # flow-field and non-corner tags (for recombination and corners definition) self . surf_tag : list [ int ] = [] self . non_corner_tags : list [ int ] = [] self . bottom_tags : list [ int ] = [] self . top_tags : list [ int ] = [] def get_nlayer ( self ) -> int : \"\"\" **Returns** the number of layers required to reach bl_thickness given the growth bl_ratio and the first element size bl_size. \"\"\" return math . ceil ( math . log ( 1 - self . bl_thickness * ( 1 - self . bl_ratio ) / self . bl_size ) / math . log ( self . bl_ratio ) - 1 ) def build_mesh ( self ): \"\"\" **Defines** the gmsh routine. \"\"\" gmsh . initialize () gmsh . option . setNumber ( 'General.Terminal' , 0 ) gmsh . logger . start () gmsh . model . add ( \"model\" ) self . build_2dmesh () self . build_3dmesh () if self . extrusion_layers > 0 else 0 if self . structured : [ gmsh . model . geo . mesh . setRecombine ( 2 , abs ( id )) for id in self . surf_tag ] gmsh . model . geo . synchronize () gmsh . model . mesh . generate ( 3 ) if self . extrusion_layers > 0 else gmsh . model . mesh . generate ( 2 ) if self . mesh_order : gmsh . model . mesh . setOrder ( self . mesh_order ) # visualization if self . quality : plot_quality () elt_type = \"Mesh.Triangles\" if not self . structured else \"Mesh.Quadrangles\" color = [ ( \"General.BackgroundGradient\" , 255 , 255 , 255 ), ( elt_type , 255 , 0 , 0 ) ] number = [ ( \"Geometry.Points\" , 0 ), ( \"Geometry.Curves\" , 0 ), ( \"Mesh.ColorCarousel\" , 0 ), ] if not self . quality : number . append (( \"Mesh.SurfaceFaces\" , 1 )) set_display ( color , number ) split_view ( self . nview ) if self . nview > 1 else 0 # output if self . GUI : gmsh . fltk . run () def write_mesh ( self , mesh_dir : str = \"\" ) -> str : \"\"\" **Writes** all output files: <file>.geo_unrolled, <file>.log, <file>.mesh and returns the mesh filename. - mesh_dir: the name of the directory where all gmsh generated files are saved. - format: whether to perform medit formatting (True) or not (False) of the mesh. - self.outfile: the core name of the outputed files e.g. outfile.log, outfile.mesh, etc. \"\"\" mesh_dir = self . outdir if not mesh_dir else mesh_dir check_dir ( mesh_dir ) # .geo logger . info ( f \"writing { self . outfile } .geo_unrolled to { mesh_dir } \" ) gmsh . write ( os . path . join ( mesh_dir , self . outfile + \".geo_unrolled\" )) # .mesh logger . info ( f \"writing { self . outfile } . { self . mesh_format } to { mesh_dir } \" ) gmsh . write ( os . path . join ( mesh_dir , self . outfile + f \". { self . mesh_format } \" )) # medit formatting if self . mesh_format == \"mesh\" : logger . info ( f \"medit formatting of { self . outfile } .mesh\" ) mesh_file = os . path . join ( mesh_dir , self . outfile + \".mesh\" ) mesh = open ( mesh_file , \"r\" ) . read () . splitlines () if self . extrusion_layers == 0 : mesh = self . reformat_2d ( mesh ) if self . non_corner_tags : mesh = self . add_corners ( mesh ) if self . bottom_tags and self . top_tags : mesh = self . merge_refs ( mesh ) with open ( mesh_file , 'w' ) as ftw : ftw . write ( \" \\n \" . join ( mesh )) # .log log = gmsh . logger . get () log_file = open ( os . path . join ( mesh_dir , self . outfile + \".log\" ), \"w\" ) logger . info ( f \"writing { self . outfile } .log to { mesh_dir } \" ) log_file . write ( \" \\n \" . join ( log )) # print summary summary = [ line for line in log if \"nodes\" in line and \"elements\" in line ][ - 1 ][ 6 :] logger . info ( f \"GMSH summary: { summary } \" ) # close gmsh gmsh . logger . stop () gmsh . finalize () return self . get_meshfile ( mesh_dir ) def reformat_2d ( self , mesh : list [ str ]) -> list [ str ]: \"\"\" **Fix** gmsh default .mesh format in 2D. \"\"\" idx = get_mesh_kwd ( mesh , \"Dimension\" ) mesh [ idx ] = \" Dimension 2\" del mesh [ idx + 1 ] vert_idx = get_mesh_kwd ( mesh , \"Vertices\" ) n_vert = int ( mesh [ vert_idx + 1 ]) for id in range ( vert_idx + 2 , vert_idx + 2 + n_vert ): line_data = list ( map ( float , mesh [ id ] . split ())) mesh [ id ] = \" \" * 4 + f \" { line_data [ 0 ] : >20 } \" + \\ \" \" * 4 + f \" { line_data [ 1 ] : >20 } \" + \\ \" \" * 4 + f \" { int ( line_data [ - 1 ]) : >20 } \" return mesh def add_corners ( self , mesh : list [ str ]) -> list [ str ]: \"\"\" **Adds** Corners at the end of the mesh file. \"\"\" c_vert : list [ int ] = [] logger . debug ( f \"non-corner tags: { self . non_corner_tags } \" ) vert_idx = get_mesh_kwd ( mesh , \"Vertices\" ) n_vert = int ( mesh [ vert_idx + 1 ]) for v_id , id in enumerate ( range ( vert_idx + 2 , vert_idx + 2 + n_vert )): line_data = list ( map ( float , mesh [ id ] . split ())) if int ( line_data [ - 1 ]) not in self . non_corner_tags : c_vert . append ( v_id + 1 ) mesh = mesh [: - 1 ] + [ \"Corners\" , str ( len ( c_vert ))] + [ str ( v ) for v in c_vert ] + [ \"End\" ] return mesh def merge_refs ( self , mesh : list [ str ]) -> list [ str ]: \"\"\" **Merges** the periodic boundaries references on each side of the domain. \"\"\" logger . debug ( f \"top tags: { self . top_tags } merged in ref: { max ( self . top_tags ) } \" ) logger . debug ( f \"bottom tags: { self . bottom_tags } merged in ref: { min ( self . bottom_tags ) } \" ) vert_idx = get_mesh_kwd ( mesh , \"Vertices\" ) n_vert = int ( mesh [ vert_idx + 1 ]) for id in range ( vert_idx + 2 , vert_idx + 2 + n_vert ): line_data = list ( map ( float , mesh [ id ] . split ())) if int ( line_data [ - 1 ]) in self . bottom_tags : line_data [ - 1 ] = min ( self . bottom_tags ) elif int ( line_data [ - 1 ]) in self . top_tags : line_data [ - 1 ] = max ( self . top_tags ) mesh [ id ] = \" \" * 4 + f \" { line_data [ 0 ] : >20 } \" + \\ \" \" * 4 + f \" { line_data [ 1 ] : >20 } \" + \\ \" \" * 4 + f \" { int ( line_data [ - 1 ]) : >20 } \" edge_idx = get_mesh_kwd ( mesh , \"Edges\" ) n_edges = int ( mesh [ edge_idx + 1 ]) for id in range ( edge_idx + 2 , edge_idx + 2 + n_edges ): line_data = list ( map ( int , mesh [ id ] . split ())) if line_data [ 2 ] in self . bottom_tags : line_data [ 2 ] = min ( self . bottom_tags ) elif line_data [ 2 ] in self . top_tags : line_data [ 2 ] = max ( self . top_tags ) mesh [ id ] = \" \" + f \" { line_data [ 0 ] } \" + \" \" + f \" { line_data [ 1 ] } \" + \" \" + f \" { line_data [ 2 ] } \" return mesh def get_meshfile ( self , mesh_dir : str ) -> str : \"\"\" **Returns** the path to the generated mesh. \"\"\" return os . path . join ( mesh_dir , self . outfile + f \". { self . mesh_format } \" ) @abstractmethod def process_config ( self ): \"\"\" Makes sure the config file contains the required information. \"\"\" @abstractmethod def build_2dmesh ( self ): \"\"\" Builds the surface mesh of the computational domain. \"\"\" def build_3dmesh ( self ): \"\"\" Builds a 3D mesh by extrusion \"\"\" raise Exception ( \"build_3dmesh method not implemented\" )","title":"Mesh"},{"location":"dev_mesh/#mesh.mesh.Mesh.__init__","text":"Instantiates the abstract Mesh object. Input config (dict): the config file dictionary. dat_file (str): path to input_geometry.dat. Inner outdir (str): path/to/outputdirectory outfile (str): the core name of all outputed files e.g. outfile.log, outfile.mesh, etc. header (int): the number of header lines in dat_file. geom_scale (float): geometry scaling factor. mesh_format (str): the mesh format (mesh or cgns). bl (bool): whether to mesh the boundary layer (True) or not (False). bl_thickness (float): the BL meshing cumulated thickness. bl_ratio (float): the BL meshing growth ratio. bl_size (float): the BL first element size. bl_fan_elements (int): the number of BL fan elements. mesh_order (int): the order of the mesh. structured (bool): whether to recombine triangles (True) or not (False). extrusion_layers (int): the number of extrusion layers when generating a 3D mesh. extrusion_size (float): the total size of the extruded layers. GUI (bool): whether to launch gmsh GUI (True) or not (False). nview (int): the number of sub-windows in gmsh GUI. quality (bool): whether to display quality metrics in gmsh GUI (True) or not (False). pts (list[list[float]]): the geometry coordinates. surf_tag (list[int]): flow-field elements tags used to recombine the mesh if structured. non_corner_tags (list[int]): non-corner physical entity tags used to define 'Corners'. lower_tag (list[int]): lower periodic tags to be identified as one. lower_tag (list[int]): upper periodic tags to be identified as one. Source code in aero_optim/mesh/mesh.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 def __init__ ( self , config : dict , datfile : str = \"\" ): \"\"\" Instantiates the abstract Mesh object. **Input** - config (dict): the config file dictionary. - dat_file (str): path to input_geometry.dat. **Inner** - outdir (str): path/to/outputdirectory - outfile (str): the core name of all outputed files e.g. outfile.log, outfile.mesh, etc. - header (int): the number of header lines in dat_file. - geom_scale (float): geometry scaling factor. - mesh_format (str): the mesh format (mesh or cgns). - bl (bool): whether to mesh the boundary layer (True) or not (False). - bl_thickness (float): the BL meshing cumulated thickness. - bl_ratio (float): the BL meshing growth ratio. - bl_size (float): the BL first element size. - bl_fan_elements (int): the number of BL fan elements. - mesh_order (int): the order of the mesh. - structured (bool): whether to recombine triangles (True) or not (False). - extrusion_layers (int): the number of extrusion layers when generating a 3D mesh. - extrusion_size (float): the total size of the extruded layers. - GUI (bool): whether to launch gmsh GUI (True) or not (False). - nview (int): the number of sub-windows in gmsh GUI. - quality (bool): whether to display quality metrics in gmsh GUI (True) or not (False). - pts (list[list[float]]): the geometry coordinates. - surf_tag (list[int]): flow-field elements tags used to recombine the mesh if structured. - non_corner_tags (list[int]): non-corner physical entity tags used to define 'Corners'. - lower_tag (list[int]): lower periodic tags to be identified as one. - lower_tag (list[int]): upper periodic tags to be identified as one. \"\"\" self . config = config self . process_config () # study params self . dat_file : str = datfile if datfile else config [ \"study\" ][ \"file\" ] self . outdir : str = config [ \"study\" ][ \"outdir\" ] self . outfile = self . config [ \"study\" ] . get ( \"outfile\" , self . dat_file . split ( \"/\" )[ - 1 ][: - 4 ]) # mesh params (geom, format & boundary layer) self . header : int = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"header\" , 2 ) self . geom_scale : int = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"scale\" , 1 ) self . mesh_format : str = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"mesh_format\" , \"mesh\" ) . lower () self . bl : bool = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"bl\" , False ) self . bl_thickness : float = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"bl_thickness\" , 1e-3 ) self . bl_ratio : float = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"bl_ratio\" , 1.1 ) self . bl_size : float = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"bl_size\" , 1e-5 ) self . bl_fan_elements : int = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"bl_fan_elements\" , 10 ) self . mesh_order : int = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"order\" , 0 ) # mesh params (3d extrusion) self . structured : bool = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"structured\" , False ) self . extrusion_layers : int = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"extrusion_layers\" , 0 ) self . extrusion_size : int = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"extrusion_size\" , 0.001 ) # gui options self . GUI : bool = config [ \"gmsh\" ][ \"view\" ] . get ( \"GUI\" , True ) self . nview : int = config [ \"gmsh\" ][ \"view\" ] . get ( \"nview\" , 1 ) self . quality : bool = config [ \"gmsh\" ][ \"view\" ] . get ( \"quality\" , False ) # geometry coordinates loading self . pts : list [ list [ float ]] = from_dat ( self . dat_file , self . header , self . geom_scale ) # flow-field and non-corner tags (for recombination and corners definition) self . surf_tag : list [ int ] = [] self . non_corner_tags : list [ int ] = [] self . bottom_tags : list [ int ] = [] self . top_tags : list [ int ] = []","title":"__init__"},{"location":"dev_mesh/#mesh.mesh.Mesh.add_corners","text":"Adds Corners at the end of the mesh file. Source code in aero_optim/mesh/mesh.py 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 def add_corners ( self , mesh : list [ str ]) -> list [ str ]: \"\"\" **Adds** Corners at the end of the mesh file. \"\"\" c_vert : list [ int ] = [] logger . debug ( f \"non-corner tags: { self . non_corner_tags } \" ) vert_idx = get_mesh_kwd ( mesh , \"Vertices\" ) n_vert = int ( mesh [ vert_idx + 1 ]) for v_id , id in enumerate ( range ( vert_idx + 2 , vert_idx + 2 + n_vert )): line_data = list ( map ( float , mesh [ id ] . split ())) if int ( line_data [ - 1 ]) not in self . non_corner_tags : c_vert . append ( v_id + 1 ) mesh = mesh [: - 1 ] + [ \"Corners\" , str ( len ( c_vert ))] + [ str ( v ) for v in c_vert ] + [ \"End\" ] return mesh","title":"add_corners"},{"location":"dev_mesh/#mesh.mesh.Mesh.build_2dmesh","text":"Builds the surface mesh of the computational domain. Source code in aero_optim/mesh/mesh.py 390 391 392 393 394 @abstractmethod def build_2dmesh ( self ): \"\"\" Builds the surface mesh of the computational domain. \"\"\"","title":"build_2dmesh"},{"location":"dev_mesh/#mesh.mesh.Mesh.build_3dmesh","text":"Builds a 3D mesh by extrusion Source code in aero_optim/mesh/mesh.py 396 397 398 399 400 def build_3dmesh ( self ): \"\"\" Builds a 3D mesh by extrusion \"\"\" raise Exception ( \"build_3dmesh method not implemented\" )","title":"build_3dmesh"},{"location":"dev_mesh/#mesh.mesh.Mesh.build_mesh","text":"Defines the gmsh routine. Source code in aero_optim/mesh/mesh.py 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 def build_mesh ( self ): \"\"\" **Defines** the gmsh routine. \"\"\" gmsh . initialize () gmsh . option . setNumber ( 'General.Terminal' , 0 ) gmsh . logger . start () gmsh . model . add ( \"model\" ) self . build_2dmesh () self . build_3dmesh () if self . extrusion_layers > 0 else 0 if self . structured : [ gmsh . model . geo . mesh . setRecombine ( 2 , abs ( id )) for id in self . surf_tag ] gmsh . model . geo . synchronize () gmsh . model . mesh . generate ( 3 ) if self . extrusion_layers > 0 else gmsh . model . mesh . generate ( 2 ) if self . mesh_order : gmsh . model . mesh . setOrder ( self . mesh_order ) # visualization if self . quality : plot_quality () elt_type = \"Mesh.Triangles\" if not self . structured else \"Mesh.Quadrangles\" color = [ ( \"General.BackgroundGradient\" , 255 , 255 , 255 ), ( elt_type , 255 , 0 , 0 ) ] number = [ ( \"Geometry.Points\" , 0 ), ( \"Geometry.Curves\" , 0 ), ( \"Mesh.ColorCarousel\" , 0 ), ] if not self . quality : number . append (( \"Mesh.SurfaceFaces\" , 1 )) set_display ( color , number ) split_view ( self . nview ) if self . nview > 1 else 0 # output if self . GUI : gmsh . fltk . run ()","title":"build_mesh"},{"location":"dev_mesh/#mesh.mesh.Mesh.get_meshfile","text":"Returns the path to the generated mesh. Source code in aero_optim/mesh/mesh.py 378 379 380 381 382 def get_meshfile ( self , mesh_dir : str ) -> str : \"\"\" **Returns** the path to the generated mesh. \"\"\" return os . path . join ( mesh_dir , self . outfile + f \". { self . mesh_format } \" )","title":"get_meshfile"},{"location":"dev_mesh/#mesh.mesh.Mesh.get_nlayer","text":"Returns the number of layers required to reach bl_thickness given the growth bl_ratio and the first element size bl_size. Source code in aero_optim/mesh/mesh.py 219 220 221 222 223 224 225 226 227 def get_nlayer ( self ) -> int : \"\"\" **Returns** the number of layers required to reach bl_thickness given the growth bl_ratio and the first element size bl_size. \"\"\" return math . ceil ( math . log ( 1 - self . bl_thickness * ( 1 - self . bl_ratio ) / self . bl_size ) / math . log ( self . bl_ratio ) - 1 )","title":"get_nlayer"},{"location":"dev_mesh/#mesh.mesh.Mesh.merge_refs","text":"Merges the periodic boundaries references on each side of the domain. Source code in aero_optim/mesh/mesh.py 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 def merge_refs ( self , mesh : list [ str ]) -> list [ str ]: \"\"\" **Merges** the periodic boundaries references on each side of the domain. \"\"\" logger . debug ( f \"top tags: { self . top_tags } merged in ref: { max ( self . top_tags ) } \" ) logger . debug ( f \"bottom tags: { self . bottom_tags } merged in ref: { min ( self . bottom_tags ) } \" ) vert_idx = get_mesh_kwd ( mesh , \"Vertices\" ) n_vert = int ( mesh [ vert_idx + 1 ]) for id in range ( vert_idx + 2 , vert_idx + 2 + n_vert ): line_data = list ( map ( float , mesh [ id ] . split ())) if int ( line_data [ - 1 ]) in self . bottom_tags : line_data [ - 1 ] = min ( self . bottom_tags ) elif int ( line_data [ - 1 ]) in self . top_tags : line_data [ - 1 ] = max ( self . top_tags ) mesh [ id ] = \" \" * 4 + f \" { line_data [ 0 ] : >20 } \" + \\ \" \" * 4 + f \" { line_data [ 1 ] : >20 } \" + \\ \" \" * 4 + f \" { int ( line_data [ - 1 ]) : >20 } \" edge_idx = get_mesh_kwd ( mesh , \"Edges\" ) n_edges = int ( mesh [ edge_idx + 1 ]) for id in range ( edge_idx + 2 , edge_idx + 2 + n_edges ): line_data = list ( map ( int , mesh [ id ] . split ())) if line_data [ 2 ] in self . bottom_tags : line_data [ 2 ] = min ( self . bottom_tags ) elif line_data [ 2 ] in self . top_tags : line_data [ 2 ] = max ( self . top_tags ) mesh [ id ] = \" \" + f \" { line_data [ 0 ] } \" + \" \" + f \" { line_data [ 1 ] } \" + \" \" + f \" { line_data [ 2 ] } \" return mesh","title":"merge_refs"},{"location":"dev_mesh/#mesh.mesh.Mesh.process_config","text":"Makes sure the config file contains the required information. Source code in aero_optim/mesh/mesh.py 384 385 386 387 388 @abstractmethod def process_config ( self ): \"\"\" Makes sure the config file contains the required information. \"\"\"","title":"process_config"},{"location":"dev_mesh/#mesh.mesh.Mesh.reformat_2d","text":"Fix gmsh default .mesh format in 2D. Source code in aero_optim/mesh/mesh.py 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 def reformat_2d ( self , mesh : list [ str ]) -> list [ str ]: \"\"\" **Fix** gmsh default .mesh format in 2D. \"\"\" idx = get_mesh_kwd ( mesh , \"Dimension\" ) mesh [ idx ] = \" Dimension 2\" del mesh [ idx + 1 ] vert_idx = get_mesh_kwd ( mesh , \"Vertices\" ) n_vert = int ( mesh [ vert_idx + 1 ]) for id in range ( vert_idx + 2 , vert_idx + 2 + n_vert ): line_data = list ( map ( float , mesh [ id ] . split ())) mesh [ id ] = \" \" * 4 + f \" { line_data [ 0 ] : >20 } \" + \\ \" \" * 4 + f \" { line_data [ 1 ] : >20 } \" + \\ \" \" * 4 + f \" { int ( line_data [ - 1 ]) : >20 } \" return mesh","title":"reformat_2d"},{"location":"dev_mesh/#mesh.mesh.Mesh.write_mesh","text":"Writes all output files: .geo_unrolled, .log, .mesh and returns the mesh filename. mesh_dir: the name of the directory where all gmsh generated files are saved. format: whether to perform medit formatting (True) or not (False) of the mesh. self.outfile: the core name of the outputed files e.g. outfile.log, outfile.mesh, etc. Source code in aero_optim/mesh/mesh.py 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 def write_mesh ( self , mesh_dir : str = \"\" ) -> str : \"\"\" **Writes** all output files: <file>.geo_unrolled, <file>.log, <file>.mesh and returns the mesh filename. - mesh_dir: the name of the directory where all gmsh generated files are saved. - format: whether to perform medit formatting (True) or not (False) of the mesh. - self.outfile: the core name of the outputed files e.g. outfile.log, outfile.mesh, etc. \"\"\" mesh_dir = self . outdir if not mesh_dir else mesh_dir check_dir ( mesh_dir ) # .geo logger . info ( f \"writing { self . outfile } .geo_unrolled to { mesh_dir } \" ) gmsh . write ( os . path . join ( mesh_dir , self . outfile + \".geo_unrolled\" )) # .mesh logger . info ( f \"writing { self . outfile } . { self . mesh_format } to { mesh_dir } \" ) gmsh . write ( os . path . join ( mesh_dir , self . outfile + f \". { self . mesh_format } \" )) # medit formatting if self . mesh_format == \"mesh\" : logger . info ( f \"medit formatting of { self . outfile } .mesh\" ) mesh_file = os . path . join ( mesh_dir , self . outfile + \".mesh\" ) mesh = open ( mesh_file , \"r\" ) . read () . splitlines () if self . extrusion_layers == 0 : mesh = self . reformat_2d ( mesh ) if self . non_corner_tags : mesh = self . add_corners ( mesh ) if self . bottom_tags and self . top_tags : mesh = self . merge_refs ( mesh ) with open ( mesh_file , 'w' ) as ftw : ftw . write ( \" \\n \" . join ( mesh )) # .log log = gmsh . logger . get () log_file = open ( os . path . join ( mesh_dir , self . outfile + \".log\" ), \"w\" ) logger . info ( f \"writing { self . outfile } .log to { mesh_dir } \" ) log_file . write ( \" \\n \" . join ( log )) # print summary summary = [ line for line in log if \"nodes\" in line and \"elements\" in line ][ - 1 ][ 6 :] logger . info ( f \"GMSH summary: { summary } \" ) # close gmsh gmsh . logger . stop () gmsh . finalize () return self . get_meshfile ( mesh_dir )","title":"write_mesh"},{"location":"dev_mesh/#mesh.naca_base_mesh.NACABaseMesh","text":"Bases: Mesh This class implements a meshing routine for a naca profile. The computational domain has the following structure: pt_hi_inlet ! top_side ! ! * * ------------- * pt_hi_outlet * * * | * * | * | * * | * | * <- arc_inlet | <- outlet * | * * | * | * * | * * * | * * ------------- * pt_low_outlet ! ! ! bottom_side pt_low_inlet Source code in aero_optim/mesh/naca_base_mesh.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 class NACABaseMesh ( Mesh ): \"\"\" This class implements a meshing routine for a naca profile. The computational domain has the following structure: pt_hi_inlet ! top_side ! ! * * ------------- * pt_hi_outlet * * * | * * | * | * * | * | * <- arc_inlet | <- outlet * | * * | * | * * | * * * | * * ------------- * pt_low_outlet ! ! ! bottom_side pt_low_inlet \"\"\" def __init__ ( self , config : dict , datfile : str = \"\" ): \"\"\" Instantiates the NACABaseMesh object. **Input** - config (dict): the config file dictionary. - dat_file (str): path to input_geometry.dat. **Inner** - dinlet (float): the radius of the inlet semi-circle. - doutlet (float): the distance between the airfoil trailing edge and the outlet. - offset (int): the leading edge portion defined in number of points from the leading edge. - nodes_inlet (int): the number of nodes to mesh the inlet. - nodes_outlet (int): the number of nodes to mesh the outlet. - snodes (int): the number of nodes to mesh the top and bottom sides. - le (int): the number of nodes to mesh the airfoil leading edge portion. - low (int): the number of nodes to mesh the airfoil trailing edge lower portion. - up (int): the number of nodes to mesh the airfoil trailing edge upper portion. \"\"\" super () . __init__ ( config , datfile ) self . dinlet : float = self . config [ \"gmsh\" ][ \"domain\" ] . get ( \"inlet\" , 2 ) self . doutlet : float = self . config [ \"gmsh\" ][ \"domain\" ] . get ( \"outlet\" , 10 ) self . offset : int = self . config [ \"gmsh\" ][ \"domain\" ] . get ( \"le_offset\" , 10 ) self . nodes_inlet : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_inlet\" , 100 ) self . nodes_outlet : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_outlet\" , 100 ) self . snodes : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"side_nodes\" , 100 ) self . le : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"le\" , 20 ) self . low : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"low\" , 70 ) self . up : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"up\" , 70 ) def process_config ( self ): logger . debug ( \"processing config..\" ) if \"domain\" not in self . config [ \"gmsh\" ]: logger . debug ( f \"no <domain> entry in { self . config [ 'gmsh' ] } , empty entry added\" ) self . config [ \"gmsh\" ][ \"domain\" ] = {} if \"inlet\" not in self . config [ \"gmsh\" ][ \"domain\" ]: logger . debug ( f \"no <inlet> entry in { self . config [ 'gmsh' ][ 'domain' ] } \" ) if \"outlet\" not in self . config [ \"gmsh\" ][ \"domain\" ]: logger . debug ( f \"no <outlet> entry in { self . config [ 'gmsh' ][ 'domain' ] } \" ) def split_naca ( self ) -> tuple [ list [ list [ float ]], list [ list [ float ]]]: \"\"\" **Returns** the upper and lower parts of the airfoil as ordered lists (wrt the x axis). Note: the trailing and leading edges are voluntarily excluded from both parts since the geometry is closed and these points must each have a unique tag. \"\"\" start : int = min ( self . idx_le , self . idx_te ) end : int = max ( self . idx_le , self . idx_te ) if ( max ([ p [ 1 ] for p in self . pts [ start : end + 1 ]]) > max ([ p [ 1 ] for p in self . pts [: start + 1 ] + self . pts [ end :]]) ): upper = [[ p [ 0 ], p [ 1 ], p [ 2 ]] for p in self . pts [ start + 1 : end ]] lower = [[ p [ 0 ], p [ 1 ], p [ 2 ]] for p in self . pts [: start ] + self . pts [ end + 1 :]] else : lower = [[ p [ 0 ], p [ 1 ], p [ 2 ]] for p in self . pts [ start + 1 : end ]] upper = [[ p [ 0 ], p [ 1 ], p [ 2 ]] for p in self . pts [: start ] + self . pts [ end + 1 :]] upper = sorted ( upper , key = lambda x : ( x [ 0 ]), reverse = True ) lower = sorted ( lower , key = lambda x : ( x [ 0 ])) return upper , lower def build_bl ( self , naca_tag : list [ int ], te_tag : int ): \"\"\" **Builds** the boundary layer around the airfoil. \"\"\" self . f = gmsh . model . mesh . field . add ( 'BoundaryLayer' ) gmsh . model . mesh . field . setNumbers ( self . f , 'CurvesList' , naca_tag ) gmsh . model . mesh . field . setNumber ( self . f , 'Size' , self . bl_size ) gmsh . model . mesh . field . setNumber ( self . f , 'Ratio' , self . bl_ratio ) gmsh . model . mesh . field . setNumber ( self . f , 'Quads' , int ( self . structured )) gmsh . model . mesh . field . setNumber ( self . f , 'Thickness' , self . bl_thickness ) gmsh . option . setNumber ( 'Mesh.BoundaryLayerFanElements' , self . bl_fan_elements ) gmsh . model . mesh . field . setNumbers ( self . f , 'FanPointsList' , [ te_tag ]) gmsh . model . mesh . field . setAsBoundaryLayer ( self . f ) def build_2dmesh ( self ): \"\"\" **Builds** the surface mesh of the computational domain. \"\"\" _ , self . idx_le = min (( p [ 0 ], idx ) for ( idx , p ) in enumerate ( self . pts )) _ , self . idx_te = max (( p [ 0 ], idx ) for ( idx , p ) in enumerate ( self . pts )) u_side , l_side = self . split_naca () # add points and lines for the naca lower and upper parts x_le , y_le = self . pts [ self . idx_le ][: 2 ] x_te , y_te = self . pts [ self . idx_te ][: 2 ] te_tag = gmsh . model . geo . addPoint ( x_te , y_te , 0. ) le_tag = gmsh . model . geo . addPoint ( x_le , y_le , 0. ) pt_u = [ te_tag ] + [ gmsh . model . geo . addPoint ( p [ 0 ], p [ 1 ], p [ 2 ]) for p in u_side ] pt_l = [ le_tag ] + \\ [ gmsh . model . geo . addPoint ( p [ 0 ], p [ 1 ], p [ 2 ]) for p in l_side ] + [ te_tag ] # airfoil boundary spline_low = gmsh . model . geo . addSpline ( pt_l [ self . offset :], tag = 1 ) spline_le = gmsh . model . geo . addSpline ( pt_u [ - self . offset :] + pt_l [: self . offset + 1 ], tag = 2 ) spline_up = gmsh . model . geo . addSpline ( pt_u [: - self . offset + 1 ], tag = 3 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spline_low , self . low , \"Progression\" , 1 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spline_le , self . le , \"Bump\" , 2. ) gmsh . model . geo . mesh . setTransfiniteCurve ( spline_up , self . up , \"Progression\" , 1 ) naca_loop = gmsh . model . geo . addCurveLoop ([ spline_low , spline_le , spline_up ]) # boundary layer self . build_bl ([ spline_low , spline_le , spline_up ], te_tag ) if self . bl else 0 # construction points pt_hi_inlet = gmsh . model . geo . addPoint ( x_te , y_te + self . dinlet , 0. ) pt_low_inlet = gmsh . model . geo . addPoint ( x_te , y_te - self . dinlet , 0. ) pt_hi_outlet = gmsh . model . geo . addPoint ( x_te + self . doutlet , y_te + self . dinlet , 0. ) pt_low_outlet = gmsh . model . geo . addPoint ( x_te + self . doutlet , y_te - self . dinlet , 0. ) # non-blade boundary lines arc_inlet = gmsh . model . geo . addCircleArc ( pt_hi_inlet , te_tag , pt_low_inlet ) top_side = gmsh . model . geo . addLine ( pt_hi_inlet , pt_hi_outlet ) bottom_side = gmsh . model . geo . addLine ( pt_low_outlet , pt_low_inlet ) outlet = gmsh . model . geo . addLine ( pt_hi_outlet , pt_low_outlet ) # transfinite curves on non-blade boundaries gmsh . model . geo . mesh . setTransfiniteCurve ( arc_inlet , self . nodes_inlet , \"Progression\" , 1 ) gmsh . model . geo . mesh . setTransfiniteCurve ( top_side , self . snodes , \"Progression\" , 1 ) gmsh . model . geo . mesh . setTransfiniteCurve ( bottom_side , self . snodes , \"Progression\" , 1 ) gmsh . model . geo . mesh . setTransfiniteCurve ( outlet , self . nodes_outlet , \"Progression\" , 1 ) # closed curve loop and computational domain surface definition cloop = [ - arc_inlet , top_side , outlet , bottom_side ] boundary_loop = gmsh . model . geo . addCurveLoop ( cloop ) self . surf_tag = [ gmsh . model . geo . addPlaneSurface ([ - boundary_loop , - naca_loop ], tag = 1000 )] # define physical groups for boundary conditions gmsh . model . geo . addPhysicalGroup ( 1 , [ spline_low , spline_le , spline_up ], tag = 100 ) logger . debug ( f \"BC: Wall tags are { [ spline_low , spline_le , spline_up ] } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , [ arc_inlet ], tag = 200 ) logger . debug ( f \"BC: Inlet tags are { [ arc_inlet ] } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , [ outlet ], tag = 300 ) logger . debug ( f \"BC: Outlet tags are { [ outlet ] } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , [ top_side ], tag = 400 ) logger . debug ( f \"BC: Top tags are { [ top_side ] } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , [ bottom_side ], tag = 500 ) logger . debug ( f \"BC: Bottom tags are { [ bottom_side ] } \" ) gmsh . model . geo . addPhysicalGroup ( 2 , self . surf_tag , tag = 600 )","title":"NACABaseMesh"},{"location":"dev_mesh/#mesh.naca_base_mesh.NACABaseMesh.__init__","text":"Instantiates the NACABaseMesh object. Input config (dict): the config file dictionary. dat_file (str): path to input_geometry.dat. Inner dinlet (float): the radius of the inlet semi-circle. doutlet (float): the distance between the airfoil trailing edge and the outlet. offset (int): the leading edge portion defined in number of points from the leading edge. nodes_inlet (int): the number of nodes to mesh the inlet. nodes_outlet (int): the number of nodes to mesh the outlet. snodes (int): the number of nodes to mesh the top and bottom sides. le (int): the number of nodes to mesh the airfoil leading edge portion. low (int): the number of nodes to mesh the airfoil trailing edge lower portion. up (int): the number of nodes to mesh the airfoil trailing edge upper portion. Source code in aero_optim/mesh/naca_base_mesh.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def __init__ ( self , config : dict , datfile : str = \"\" ): \"\"\" Instantiates the NACABaseMesh object. **Input** - config (dict): the config file dictionary. - dat_file (str): path to input_geometry.dat. **Inner** - dinlet (float): the radius of the inlet semi-circle. - doutlet (float): the distance between the airfoil trailing edge and the outlet. - offset (int): the leading edge portion defined in number of points from the leading edge. - nodes_inlet (int): the number of nodes to mesh the inlet. - nodes_outlet (int): the number of nodes to mesh the outlet. - snodes (int): the number of nodes to mesh the top and bottom sides. - le (int): the number of nodes to mesh the airfoil leading edge portion. - low (int): the number of nodes to mesh the airfoil trailing edge lower portion. - up (int): the number of nodes to mesh the airfoil trailing edge upper portion. \"\"\" super () . __init__ ( config , datfile ) self . dinlet : float = self . config [ \"gmsh\" ][ \"domain\" ] . get ( \"inlet\" , 2 ) self . doutlet : float = self . config [ \"gmsh\" ][ \"domain\" ] . get ( \"outlet\" , 10 ) self . offset : int = self . config [ \"gmsh\" ][ \"domain\" ] . get ( \"le_offset\" , 10 ) self . nodes_inlet : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_inlet\" , 100 ) self . nodes_outlet : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_outlet\" , 100 ) self . snodes : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"side_nodes\" , 100 ) self . le : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"le\" , 20 ) self . low : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"low\" , 70 ) self . up : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"up\" , 70 )","title":"__init__"},{"location":"dev_mesh/#mesh.naca_base_mesh.NACABaseMesh.build_2dmesh","text":"Builds the surface mesh of the computational domain. Source code in aero_optim/mesh/naca_base_mesh.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 def build_2dmesh ( self ): \"\"\" **Builds** the surface mesh of the computational domain. \"\"\" _ , self . idx_le = min (( p [ 0 ], idx ) for ( idx , p ) in enumerate ( self . pts )) _ , self . idx_te = max (( p [ 0 ], idx ) for ( idx , p ) in enumerate ( self . pts )) u_side , l_side = self . split_naca () # add points and lines for the naca lower and upper parts x_le , y_le = self . pts [ self . idx_le ][: 2 ] x_te , y_te = self . pts [ self . idx_te ][: 2 ] te_tag = gmsh . model . geo . addPoint ( x_te , y_te , 0. ) le_tag = gmsh . model . geo . addPoint ( x_le , y_le , 0. ) pt_u = [ te_tag ] + [ gmsh . model . geo . addPoint ( p [ 0 ], p [ 1 ], p [ 2 ]) for p in u_side ] pt_l = [ le_tag ] + \\ [ gmsh . model . geo . addPoint ( p [ 0 ], p [ 1 ], p [ 2 ]) for p in l_side ] + [ te_tag ] # airfoil boundary spline_low = gmsh . model . geo . addSpline ( pt_l [ self . offset :], tag = 1 ) spline_le = gmsh . model . geo . addSpline ( pt_u [ - self . offset :] + pt_l [: self . offset + 1 ], tag = 2 ) spline_up = gmsh . model . geo . addSpline ( pt_u [: - self . offset + 1 ], tag = 3 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spline_low , self . low , \"Progression\" , 1 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spline_le , self . le , \"Bump\" , 2. ) gmsh . model . geo . mesh . setTransfiniteCurve ( spline_up , self . up , \"Progression\" , 1 ) naca_loop = gmsh . model . geo . addCurveLoop ([ spline_low , spline_le , spline_up ]) # boundary layer self . build_bl ([ spline_low , spline_le , spline_up ], te_tag ) if self . bl else 0 # construction points pt_hi_inlet = gmsh . model . geo . addPoint ( x_te , y_te + self . dinlet , 0. ) pt_low_inlet = gmsh . model . geo . addPoint ( x_te , y_te - self . dinlet , 0. ) pt_hi_outlet = gmsh . model . geo . addPoint ( x_te + self . doutlet , y_te + self . dinlet , 0. ) pt_low_outlet = gmsh . model . geo . addPoint ( x_te + self . doutlet , y_te - self . dinlet , 0. ) # non-blade boundary lines arc_inlet = gmsh . model . geo . addCircleArc ( pt_hi_inlet , te_tag , pt_low_inlet ) top_side = gmsh . model . geo . addLine ( pt_hi_inlet , pt_hi_outlet ) bottom_side = gmsh . model . geo . addLine ( pt_low_outlet , pt_low_inlet ) outlet = gmsh . model . geo . addLine ( pt_hi_outlet , pt_low_outlet ) # transfinite curves on non-blade boundaries gmsh . model . geo . mesh . setTransfiniteCurve ( arc_inlet , self . nodes_inlet , \"Progression\" , 1 ) gmsh . model . geo . mesh . setTransfiniteCurve ( top_side , self . snodes , \"Progression\" , 1 ) gmsh . model . geo . mesh . setTransfiniteCurve ( bottom_side , self . snodes , \"Progression\" , 1 ) gmsh . model . geo . mesh . setTransfiniteCurve ( outlet , self . nodes_outlet , \"Progression\" , 1 ) # closed curve loop and computational domain surface definition cloop = [ - arc_inlet , top_side , outlet , bottom_side ] boundary_loop = gmsh . model . geo . addCurveLoop ( cloop ) self . surf_tag = [ gmsh . model . geo . addPlaneSurface ([ - boundary_loop , - naca_loop ], tag = 1000 )] # define physical groups for boundary conditions gmsh . model . geo . addPhysicalGroup ( 1 , [ spline_low , spline_le , spline_up ], tag = 100 ) logger . debug ( f \"BC: Wall tags are { [ spline_low , spline_le , spline_up ] } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , [ arc_inlet ], tag = 200 ) logger . debug ( f \"BC: Inlet tags are { [ arc_inlet ] } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , [ outlet ], tag = 300 ) logger . debug ( f \"BC: Outlet tags are { [ outlet ] } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , [ top_side ], tag = 400 ) logger . debug ( f \"BC: Top tags are { [ top_side ] } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , [ bottom_side ], tag = 500 ) logger . debug ( f \"BC: Bottom tags are { [ bottom_side ] } \" ) gmsh . model . geo . addPhysicalGroup ( 2 , self . surf_tag , tag = 600 )","title":"build_2dmesh"},{"location":"dev_mesh/#mesh.naca_base_mesh.NACABaseMesh.build_bl","text":"Builds the boundary layer around the airfoil. Source code in aero_optim/mesh/naca_base_mesh.py 101 102 103 104 105 106 107 108 109 110 111 112 113 def build_bl ( self , naca_tag : list [ int ], te_tag : int ): \"\"\" **Builds** the boundary layer around the airfoil. \"\"\" self . f = gmsh . model . mesh . field . add ( 'BoundaryLayer' ) gmsh . model . mesh . field . setNumbers ( self . f , 'CurvesList' , naca_tag ) gmsh . model . mesh . field . setNumber ( self . f , 'Size' , self . bl_size ) gmsh . model . mesh . field . setNumber ( self . f , 'Ratio' , self . bl_ratio ) gmsh . model . mesh . field . setNumber ( self . f , 'Quads' , int ( self . structured )) gmsh . model . mesh . field . setNumber ( self . f , 'Thickness' , self . bl_thickness ) gmsh . option . setNumber ( 'Mesh.BoundaryLayerFanElements' , self . bl_fan_elements ) gmsh . model . mesh . field . setNumbers ( self . f , 'FanPointsList' , [ te_tag ]) gmsh . model . mesh . field . setAsBoundaryLayer ( self . f )","title":"build_bl"},{"location":"dev_mesh/#mesh.naca_base_mesh.NACABaseMesh.split_naca","text":"Returns the upper and lower parts of the airfoil as ordered lists (wrt the x axis). Note the trailing and leading edges are voluntarily excluded from both parts since the geometry is closed and these points must each have a unique tag. Source code in aero_optim/mesh/naca_base_mesh.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def split_naca ( self ) -> tuple [ list [ list [ float ]], list [ list [ float ]]]: \"\"\" **Returns** the upper and lower parts of the airfoil as ordered lists (wrt the x axis). Note: the trailing and leading edges are voluntarily excluded from both parts since the geometry is closed and these points must each have a unique tag. \"\"\" start : int = min ( self . idx_le , self . idx_te ) end : int = max ( self . idx_le , self . idx_te ) if ( max ([ p [ 1 ] for p in self . pts [ start : end + 1 ]]) > max ([ p [ 1 ] for p in self . pts [: start + 1 ] + self . pts [ end :]]) ): upper = [[ p [ 0 ], p [ 1 ], p [ 2 ]] for p in self . pts [ start + 1 : end ]] lower = [[ p [ 0 ], p [ 1 ], p [ 2 ]] for p in self . pts [: start ] + self . pts [ end + 1 :]] else : lower = [[ p [ 0 ], p [ 1 ], p [ 2 ]] for p in self . pts [ start + 1 : end ]] upper = [[ p [ 0 ], p [ 1 ], p [ 2 ]] for p in self . pts [: start ] + self . pts [ end + 1 :]] upper = sorted ( upper , key = lambda x : ( x [ 0 ]), reverse = True ) lower = sorted ( lower , key = lambda x : ( x [ 0 ])) return upper , lower","title":"split_naca"},{"location":"dev_mesh/#mesh.naca_block_mesh.NACABlockMesh","text":"Bases: NACABaseMesh This class implements a blocking mesh routine for a naca profile based on: https://github.com/ComputationalDomain/CMesh_rae69ck-il Source code in aero_optim/mesh/naca_block_mesh.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 class NACABlockMesh ( NACABaseMesh ): \"\"\" This class implements a blocking mesh routine for a naca profile based on:</br> https://github.com/ComputationalDomain/CMesh_rae69ck-il \"\"\" def __init__ ( self , config : dict , datfile : str = \"\" ): \"\"\" Instantiates the BlockMesh object. **Input** - config (dict): the config file dictionary. - dat_file (str): path to input_geometry.dat. \"\"\" super () . __init__ ( config , datfile ) def build_2dmesh ( self ): \"\"\" **Builds** the surface mesh of the computational domain. **Inner** - R (float): radius of the outer circle. - d_out (float): distance to the outlet. - offset (int): offset from leading edge. - b_width (float): block_width. - n_inlet (int): nbr of lead edge & inlet nodes. - r_inlet (float): bump ratio of lead edge & inlet nodes. - n_vertical (int) : nbr of out & verti nodes. - r_vertical (float): out & vert growth. - n_airfoil (int): nbr of nodes on each sides. - r_airfoil (float): airfoil sides growth. - n_wake (int): nbr of nodes in the wake dir. - r_wake (float): wake growth. \"\"\" R = self . dinlet d_out = self . doutlet offset = self . config [ \"gmsh\" ][ \"domain\" ] . get ( \"le_offset\" , 10 ) b_width = self . config [ \"gmsh\" ][ \"domain\" ] . get ( \"block_width\" , 10 ) n_inlet = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"n_inlet\" , 60 ) r_inlet = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"r_inlet\" , 1. ) n_vertical = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"n_vertical\" , 90 ) r_vertical = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"r_vertical\" , 1 / 0.95 ) n_airfoil = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"n_airfoil\" , 50 ) r_airfoil = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"r_airfoil\" , 1 ) n_wake = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"n_wake\" , 100 ) r_wake = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"r_wake\" , 1 / 0.95 ) _ , self . idx_le = min (( p [ 0 ], idx ) for ( idx , p ) in enumerate ( self . pts )) _ , self . idx_te = max (( p [ 0 ], idx ) for ( idx , p ) in enumerate ( self . pts )) u_side , l_side = self . split_naca () # add points and lines for the naca lower and upper parts x_le , y_le = self . pts [ self . idx_le ][: 2 ] x_te , y_te = self . pts [ self . idx_te ][: 2 ] te_tag = gmsh . model . geo . addPoint ( x_te , y_te , 0. ) le_tag = gmsh . model . geo . addPoint ( x_le , y_le , 0. ) pt_u = [ te_tag ] + [ gmsh . model . geo . addPoint ( p [ 0 ], p [ 1 ], p [ 2 ]) for p in u_side ] pt_l = [ le_tag ] + \\ [ gmsh . model . geo . addPoint ( p [ 0 ], p [ 1 ], p [ 2 ]) for p in l_side ] + [ te_tag ] # airfoil boundary spline_low = gmsh . model . geo . addSpline ( pt_l [ offset :], tag = 1 ) spline_le = gmsh . model . geo . addSpline ( pt_u [ - offset :] + pt_l [: offset + 1 ], tag = 2 ) spline_up = gmsh . model . geo . addSpline ( pt_u [: - offset + 1 ], tag = 3 ) # domain and block construction points pt_229 = gmsh . model . geo . addPoint ( x_te - b_width , R , 0. , tag = 229 ) pt_230 = gmsh . model . geo . addPoint ( x_te - b_width , - R , 0. , tag = 230 ) pt_231 = gmsh . model . geo . addPoint ( x_te , R , 0. , tag = 231 ) pt_232 = gmsh . model . geo . addPoint ( x_te , - R , 0. , tag = 232 ) pt_233 = gmsh . model . geo . addPoint ( d_out , R , 0. , tag = 233 ) pt_234 = gmsh . model . geo . addPoint ( d_out , - R , 0. , tag = 234 ) pt_235 = gmsh . model . geo . addPoint ( d_out , 0 , 0. , tag = 235 ) # domain and block lines circle_4 = gmsh . model . geo . addCircleArc ( pt_230 , te_tag , pt_229 ) line_5 = gmsh . model . geo . addLine ( pt_u [ - offset ], pt_229 ) line_6 = gmsh . model . geo . addLine ( pt_l [ offset ], pt_230 ) line_7 = gmsh . model . geo . addLine ( pt_229 , pt_231 ) line_8 = gmsh . model . geo . addLine ( pt_230 , pt_232 ) line_9 = gmsh . model . geo . addLine ( pt_231 , pt_233 ) line_10 = gmsh . model . geo . addLine ( pt_232 , pt_234 ) line_11 = gmsh . model . geo . addLine ( pt_235 , pt_234 ) line_12 = gmsh . model . geo . addLine ( pt_235 , pt_233 ) line_13 = gmsh . model . geo . addLine ( te_tag , pt_231 ) line_14 = gmsh . model . geo . addLine ( te_tag , pt_232 ) line_15 = gmsh . model . geo . addLine ( te_tag , pt_235 ) # meshing parameters gmsh . model . geo . mesh . setTransfiniteCurve ( circle_4 , n_inlet , \"Bump\" , r_inlet ) gmsh . model . geo . mesh . setTransfiniteCurve ( spline_le , n_inlet , \"Bump\" , r_inlet ) _ = [ gmsh . model . geo . mesh . setTransfiniteCurve ( lid , n_vertical , \"Progression\" , r_vertical ) for lid in [ line_5 , line_6 , line_11 , line_12 , line_13 , line_14 ]] gmsh . model . geo . mesh . setTransfiniteCurve ( spline_low , n_airfoil , \"Bump\" , r_airfoil ) gmsh . model . geo . mesh . setTransfiniteCurve ( spline_up , n_airfoil , \"Bump\" , r_airfoil ) gmsh . model . geo . mesh . setTransfiniteCurve ( line_7 , n_airfoil , \"Bump\" , r_airfoil ) gmsh . model . geo . mesh . setTransfiniteCurve ( line_8 , n_airfoil , \"Bump\" , r_airfoil ) gmsh . model . geo . mesh . setTransfiniteCurve ( line_15 , n_wake , \"Progression\" , r_wake ) gmsh . model . geo . mesh . setTransfiniteCurve ( line_9 , n_wake , \"Progression\" , r_wake ) gmsh . model . geo . mesh . setTransfiniteCurve ( line_10 , n_wake , \"Progression\" , r_wake ) # domain and block surfaces cloop_1 = gmsh . model . geo . addCurveLoop ([ circle_4 , - line_5 , spline_le , line_6 ]) surf_1 = gmsh . model . geo . addPlaneSurface ([ - cloop_1 ], tag = 1001 ) gmsh . model . geo . mesh . setTransfiniteSurface ( surf_1 ) cloop_2 = gmsh . model . geo . addCurveLoop ([ line_5 , line_7 , - line_13 , spline_up ]) surf_2 = gmsh . model . geo . addPlaneSurface ([ - cloop_2 ], tag = 1002 ) gmsh . model . geo . mesh . setTransfiniteSurface ( surf_2 ) cloop_3 = gmsh . model . geo . addCurveLoop ([ line_13 , line_9 , - line_12 , - line_15 ]) surf_3 = gmsh . model . geo . addPlaneSurface ([ - cloop_3 ], tag = 1003 ) gmsh . model . geo . mesh . setTransfiniteSurface ( surf_3 ) cloop_4 = gmsh . model . geo . addCurveLoop ([ line_6 , line_8 , - line_14 , - spline_low ]) surf_4 = gmsh . model . geo . addPlaneSurface ([ - cloop_4 ], tag = 1004 ) gmsh . model . geo . mesh . setTransfiniteSurface ( surf_4 ) cloop_5 = gmsh . model . geo . addCurveLoop ([ line_14 , line_10 , - line_11 , - line_15 ]) surf_5 = gmsh . model . geo . addPlaneSurface ([ - cloop_5 ], tag = 1005 ) gmsh . model . geo . mesh . setTransfiniteSurface ( surf_5 ) # physical groups self . surf_tag = [ surf_1 , surf_2 , surf_3 , - surf_5 , - surf_4 ] gmsh . model . geo . addPhysicalGroup ( 2 , self . surf_tag , tag = 100 ) gmsh . model . geo . addPhysicalGroup ( 1 , [ circle_4 , line_7 , line_8 ], tag = 10 ) logger . debug ( f \"BC: Inlet tags are { [ circle_4 , line_7 , line_8 ] } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , [ line_11 , line_12 ], tag = 20 ) logger . debug ( f \"BC: Outlet tags are { [ line_11 , line_12 ] } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , [ line_9 , line_10 ], tag = 40 ) logger . debug ( f \"BC: Side tags are { [ line_9 , line_10 ] } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , [ spline_up , spline_le , spline_low ], tag = 30 ) logger . debug ( f \"BC: Wall tags are { [ spline_up , spline_le , spline_low ] } \" )","title":"NACABlockMesh"},{"location":"dev_mesh/#mesh.naca_block_mesh.NACABlockMesh.__init__","text":"Instantiates the BlockMesh object. Input config (dict): the config file dictionary. dat_file (str): path to input_geometry.dat. Source code in aero_optim/mesh/naca_block_mesh.py 14 15 16 17 18 19 20 21 22 23 def __init__ ( self , config : dict , datfile : str = \"\" ): \"\"\" Instantiates the BlockMesh object. **Input** - config (dict): the config file dictionary. - dat_file (str): path to input_geometry.dat. \"\"\" super () . __init__ ( config , datfile )","title":"__init__"},{"location":"dev_mesh/#mesh.naca_block_mesh.NACABlockMesh.build_2dmesh","text":"Builds the surface mesh of the computational domain. Inner R (float): radius of the outer circle. d_out (float): distance to the outlet. offset (int): offset from leading edge. b_width (float): block_width. n_inlet (int): nbr of lead edge & inlet nodes. r_inlet (float): bump ratio of lead edge & inlet nodes. n_vertical (int) : nbr of out & verti nodes. r_vertical (float): out & vert growth. n_airfoil (int): nbr of nodes on each sides. r_airfoil (float): airfoil sides growth. n_wake (int): nbr of nodes in the wake dir. r_wake (float): wake growth. Source code in aero_optim/mesh/naca_block_mesh.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def build_2dmesh ( self ): \"\"\" **Builds** the surface mesh of the computational domain. **Inner** - R (float): radius of the outer circle. - d_out (float): distance to the outlet. - offset (int): offset from leading edge. - b_width (float): block_width. - n_inlet (int): nbr of lead edge & inlet nodes. - r_inlet (float): bump ratio of lead edge & inlet nodes. - n_vertical (int) : nbr of out & verti nodes. - r_vertical (float): out & vert growth. - n_airfoil (int): nbr of nodes on each sides. - r_airfoil (float): airfoil sides growth. - n_wake (int): nbr of nodes in the wake dir. - r_wake (float): wake growth. \"\"\" R = self . dinlet d_out = self . doutlet offset = self . config [ \"gmsh\" ][ \"domain\" ] . get ( \"le_offset\" , 10 ) b_width = self . config [ \"gmsh\" ][ \"domain\" ] . get ( \"block_width\" , 10 ) n_inlet = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"n_inlet\" , 60 ) r_inlet = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"r_inlet\" , 1. ) n_vertical = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"n_vertical\" , 90 ) r_vertical = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"r_vertical\" , 1 / 0.95 ) n_airfoil = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"n_airfoil\" , 50 ) r_airfoil = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"r_airfoil\" , 1 ) n_wake = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"n_wake\" , 100 ) r_wake = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"r_wake\" , 1 / 0.95 ) _ , self . idx_le = min (( p [ 0 ], idx ) for ( idx , p ) in enumerate ( self . pts )) _ , self . idx_te = max (( p [ 0 ], idx ) for ( idx , p ) in enumerate ( self . pts )) u_side , l_side = self . split_naca () # add points and lines for the naca lower and upper parts x_le , y_le = self . pts [ self . idx_le ][: 2 ] x_te , y_te = self . pts [ self . idx_te ][: 2 ] te_tag = gmsh . model . geo . addPoint ( x_te , y_te , 0. ) le_tag = gmsh . model . geo . addPoint ( x_le , y_le , 0. ) pt_u = [ te_tag ] + [ gmsh . model . geo . addPoint ( p [ 0 ], p [ 1 ], p [ 2 ]) for p in u_side ] pt_l = [ le_tag ] + \\ [ gmsh . model . geo . addPoint ( p [ 0 ], p [ 1 ], p [ 2 ]) for p in l_side ] + [ te_tag ] # airfoil boundary spline_low = gmsh . model . geo . addSpline ( pt_l [ offset :], tag = 1 ) spline_le = gmsh . model . geo . addSpline ( pt_u [ - offset :] + pt_l [: offset + 1 ], tag = 2 ) spline_up = gmsh . model . geo . addSpline ( pt_u [: - offset + 1 ], tag = 3 ) # domain and block construction points pt_229 = gmsh . model . geo . addPoint ( x_te - b_width , R , 0. , tag = 229 ) pt_230 = gmsh . model . geo . addPoint ( x_te - b_width , - R , 0. , tag = 230 ) pt_231 = gmsh . model . geo . addPoint ( x_te , R , 0. , tag = 231 ) pt_232 = gmsh . model . geo . addPoint ( x_te , - R , 0. , tag = 232 ) pt_233 = gmsh . model . geo . addPoint ( d_out , R , 0. , tag = 233 ) pt_234 = gmsh . model . geo . addPoint ( d_out , - R , 0. , tag = 234 ) pt_235 = gmsh . model . geo . addPoint ( d_out , 0 , 0. , tag = 235 ) # domain and block lines circle_4 = gmsh . model . geo . addCircleArc ( pt_230 , te_tag , pt_229 ) line_5 = gmsh . model . geo . addLine ( pt_u [ - offset ], pt_229 ) line_6 = gmsh . model . geo . addLine ( pt_l [ offset ], pt_230 ) line_7 = gmsh . model . geo . addLine ( pt_229 , pt_231 ) line_8 = gmsh . model . geo . addLine ( pt_230 , pt_232 ) line_9 = gmsh . model . geo . addLine ( pt_231 , pt_233 ) line_10 = gmsh . model . geo . addLine ( pt_232 , pt_234 ) line_11 = gmsh . model . geo . addLine ( pt_235 , pt_234 ) line_12 = gmsh . model . geo . addLine ( pt_235 , pt_233 ) line_13 = gmsh . model . geo . addLine ( te_tag , pt_231 ) line_14 = gmsh . model . geo . addLine ( te_tag , pt_232 ) line_15 = gmsh . model . geo . addLine ( te_tag , pt_235 ) # meshing parameters gmsh . model . geo . mesh . setTransfiniteCurve ( circle_4 , n_inlet , \"Bump\" , r_inlet ) gmsh . model . geo . mesh . setTransfiniteCurve ( spline_le , n_inlet , \"Bump\" , r_inlet ) _ = [ gmsh . model . geo . mesh . setTransfiniteCurve ( lid , n_vertical , \"Progression\" , r_vertical ) for lid in [ line_5 , line_6 , line_11 , line_12 , line_13 , line_14 ]] gmsh . model . geo . mesh . setTransfiniteCurve ( spline_low , n_airfoil , \"Bump\" , r_airfoil ) gmsh . model . geo . mesh . setTransfiniteCurve ( spline_up , n_airfoil , \"Bump\" , r_airfoil ) gmsh . model . geo . mesh . setTransfiniteCurve ( line_7 , n_airfoil , \"Bump\" , r_airfoil ) gmsh . model . geo . mesh . setTransfiniteCurve ( line_8 , n_airfoil , \"Bump\" , r_airfoil ) gmsh . model . geo . mesh . setTransfiniteCurve ( line_15 , n_wake , \"Progression\" , r_wake ) gmsh . model . geo . mesh . setTransfiniteCurve ( line_9 , n_wake , \"Progression\" , r_wake ) gmsh . model . geo . mesh . setTransfiniteCurve ( line_10 , n_wake , \"Progression\" , r_wake ) # domain and block surfaces cloop_1 = gmsh . model . geo . addCurveLoop ([ circle_4 , - line_5 , spline_le , line_6 ]) surf_1 = gmsh . model . geo . addPlaneSurface ([ - cloop_1 ], tag = 1001 ) gmsh . model . geo . mesh . setTransfiniteSurface ( surf_1 ) cloop_2 = gmsh . model . geo . addCurveLoop ([ line_5 , line_7 , - line_13 , spline_up ]) surf_2 = gmsh . model . geo . addPlaneSurface ([ - cloop_2 ], tag = 1002 ) gmsh . model . geo . mesh . setTransfiniteSurface ( surf_2 ) cloop_3 = gmsh . model . geo . addCurveLoop ([ line_13 , line_9 , - line_12 , - line_15 ]) surf_3 = gmsh . model . geo . addPlaneSurface ([ - cloop_3 ], tag = 1003 ) gmsh . model . geo . mesh . setTransfiniteSurface ( surf_3 ) cloop_4 = gmsh . model . geo . addCurveLoop ([ line_6 , line_8 , - line_14 , - spline_low ]) surf_4 = gmsh . model . geo . addPlaneSurface ([ - cloop_4 ], tag = 1004 ) gmsh . model . geo . mesh . setTransfiniteSurface ( surf_4 ) cloop_5 = gmsh . model . geo . addCurveLoop ([ line_14 , line_10 , - line_11 , - line_15 ]) surf_5 = gmsh . model . geo . addPlaneSurface ([ - cloop_5 ], tag = 1005 ) gmsh . model . geo . mesh . setTransfiniteSurface ( surf_5 ) # physical groups self . surf_tag = [ surf_1 , surf_2 , surf_3 , - surf_5 , - surf_4 ] gmsh . model . geo . addPhysicalGroup ( 2 , self . surf_tag , tag = 100 ) gmsh . model . geo . addPhysicalGroup ( 1 , [ circle_4 , line_7 , line_8 ], tag = 10 ) logger . debug ( f \"BC: Inlet tags are { [ circle_4 , line_7 , line_8 ] } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , [ line_11 , line_12 ], tag = 20 ) logger . debug ( f \"BC: Outlet tags are { [ line_11 , line_12 ] } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , [ line_9 , line_10 ], tag = 40 ) logger . debug ( f \"BC: Side tags are { [ line_9 , line_10 ] } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , [ spline_up , spline_le , spline_low ], tag = 30 ) logger . debug ( f \"BC: Wall tags are { [ spline_up , spline_le , spline_low ] } \" )","title":"build_2dmesh"},{"location":"dev_mesh/#mesh.cascade_mesh.CascadeMesh","text":"Bases: Mesh This class implements a mesh routine for a compressor cascade geometry. Source code in aero_optim/mesh/cascade_mesh.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 class CascadeMesh ( Mesh ): \"\"\" This class implements a mesh routine for a compressor cascade geometry. \"\"\" def __init__ ( self , config : dict , datfile : str = \"\" ): \"\"\" Instantiates the CascadeMesh object. **Input** - config (dict): the config file dictionary. - dat_file (str): path to input_geometry.dat. **Inner** - doutlet (float): outlet distance to the blade trailing edge. - dlr_mesh (bool): builds the DLR provided mesh (True) or a simpler for adaptation (False). - bl_sizefar (float): boundary layer mesh size far from the curves. - nodes_inlet (int): the number of nodes to mesh the inlet. - nodes_outlet (int): the number of nodes to mesh the outlet. - snodes_inlet (int): the number of nodes to mesh the inlet top and bottom sides. - snodes_outlet (int): the number of nodes to mesh the outlet top and bottom sides. - c_snodes (int): the number of nodes to mesh the inner sides. - le (int): the number of nodes to mesh the blade leading edge portion. - te (int): the number of nodes to mesh the blade trailing edge lower portion. - nodes_sp2 (int): the number of nodes to mesh the 1st section of the blade suction side. - nodes_sp3 (int): the number of nodes to mesh the 2nd section of the blade suction side. - nodes_sp4 (int): the number of nodes to mesh the 3rd section of the blade suction side. - nodes_sp7 (int): the number of nodes to mesh the 1st section of the blade pressure side. - nodes_sp8 (int): the number of nodes to mesh the 2nd section of the blade pressure side. - nodes_ss (int): the number of nodes to mesh the suction side (dlr_mesh set to False). - nodes_ps (int): the number of nodes to mesh the pressure side (dlr_mesh set to False). - cyl_vin (float): cylinder field parameter Vin. - cyl_vout (float): cylinder field parameter Vout. - cyl_xaxis (float): cylinder field parameter Xaxis. - cyl_xcenter (float): cylinder field parameter Xcenter. Note: for the DLR configuration, the blade is split into 9 splines (clockwise from the tip): * 2 splines (1 and 9) for the leading edge parameterized with **le** i.e. each spline has **le**/2 nodes, * 2 splines (5 and 6) for the trailing edge parameterized with **te** i.e. each spline has **te**/2 nodes, * 3 splines for the suction side (2, 3, 4) of lengths 0.027, 0.038 and 0.061 m, and parameterized with **nodes_sp2**, **nodes_sp3** and **nodes_sp4**, * 2 splines for the pressure side (7, 8) of lengths 0.0526 and 0.0167 m, and parameterized with **nodes_sp7**, **nodes_sp8** \"\"\" super () . __init__ ( config , datfile ) self . doutlet : float = self . config [ \"gmsh\" ][ \"domain\" ] . get ( \"outlet\" , 6.3e-2 ) self . dlr_mesh : bool = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"DLR_mesh\" , False ) self . bl_sizefar : float = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"bl_sizefar\" , 1e-5 ) self . nodes_inlet : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_inlet\" , 25 ) self . nodes_outlet : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_outlet\" , 17 ) self . snodes_inlet : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"side_nodes_inlet\" , 31 ) self . snodes_outlet : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"side_nodes_outlet\" , 31 ) self . c_snodes : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"curved_side_nodes\" , 7 ) self . le : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"le\" , 16 ) self . te : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"te\" , 16 ) self . nodes_sp2 : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_sp2\" , 42 ) self . nodes_sp3 : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_sp3\" , 42 ) self . nodes_sp4 : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_sp4\" , 14 ) self . nodes_sp7 : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_sp7\" , 57 ) self . nodes_sp8 : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_sp8\" , 32 ) self . nodes_ss : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_ss\" , 400 ) self . nodes_ps : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_ps\" , 400 ) self . cyl_vin : float = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"cyl_vin\" , 8e-4 ) self . cyl_vout : float = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"cyl_vout\" , 5e-3 ) self . cyl_xaxis : float = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"cyl_xaxis\" , 1.675e-2 ) self . cyl_xcenter : float = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"cyl_xcenter\" , 8.364e-2 ) def process_config ( self ): logger . debug ( \"processing config..\" ) if \"domain\" not in self . config [ \"gmsh\" ]: logger . debug ( f \"no <domain> entry in { self . config [ 'gmsh' ] } , empty entry added\" ) self . config [ \"gmsh\" ][ \"domain\" ] = {} def reorder_blade ( self ) -> list [ list [ float ]]: \"\"\" **Returns** the blade profile after reordering. \"\"\" d = np . sqrt ([ x ** 2 + y ** 2 for x , y , _ in self . pts ]) start = np . argmin ( d ) if self . pts [ start + 1 ][ 1 ] > self . pts [ start ][ 1 ]: return [[ p [ 0 ], p [ 1 ], p [ 2 ]] for p in self . pts [ start :] + self . pts [: start ]] else : return [[ p [ 0 ], p [ 1 ], p [ 2 ]] for p in self . pts [: start ] + self . pts [ start :]] def build_bl ( self , blade_tag : list [ int ]): \"\"\" **Builds** the boundary layer around the blade. \"\"\" f_bl = gmsh . model . mesh . field . add ( 'BoundaryLayer' ) gmsh . model . mesh . field . setNumbers ( f_bl , 'CurvesList' , blade_tag ) gmsh . model . mesh . field . setNumber ( f_bl , 'Size' , self . bl_size ) gmsh . model . mesh . field . setNumber ( f_bl , 'Ratio' , self . bl_ratio ) gmsh . model . mesh . field . setNumber ( f_bl , 'Quads' , int ( self . structured )) gmsh . model . mesh . field . setNumber ( f_bl , 'Thickness' , self . bl_thickness ) gmsh . model . mesh . field . setNumber ( f_bl , 'SizeFar' , self . bl_sizefar ) gmsh . model . mesh . field . setAsBoundaryLayer ( f_bl ) def build_cylinder_field ( self , radius : float , VIn : float , VOut : float , XAxis : float , XCenter : float , YAxis : float , YCenter : float , ZAxis : float = 0. ) -> int : \"\"\" **Builds** a cylinder field in the computational domain. \"\"\" f_cyl = gmsh . model . mesh . field . add ( 'Cylinder' ) gmsh . model . mesh . field . setNumber ( f_cyl , 'Radius' , radius ) gmsh . model . mesh . field . setNumber ( f_cyl , 'VIn' , VIn ) gmsh . model . mesh . field . setNumber ( f_cyl , 'VOut' , VOut ) gmsh . model . mesh . field . setNumber ( f_cyl , 'XAxis' , XAxis ) gmsh . model . mesh . field . setNumber ( f_cyl , 'XCenter' , XCenter ) gmsh . model . mesh . field . setNumber ( f_cyl , 'YAxis' , YAxis ) gmsh . model . mesh . field . setNumber ( f_cyl , 'YCenter' , YCenter ) gmsh . model . mesh . field . setNumber ( f_cyl , 'ZAxis' , ZAxis ) gmsh . model . mesh . field . setAsBackgroundMesh ( f_cyl ) return f_cyl def build_minaniso_field ( self , tag : list [ int ]): \"\"\" **Builds** a MinAniso field in the computational domain. \"\"\" f_minaniso = gmsh . model . mesh . field . add ( 'MinAniso' ) gmsh . model . mesh . field . setNumbers ( f_minaniso , 'FieldsList' , tag ) gmsh . model . mesh . field . setAsBackgroundMesh ( f_minaniso ) def build_2dmesh ( self ): \"\"\" **Builds** the surface mesh of the computational domain. \"\"\" wall = self . reorder_blade () pt_wall = [ gmsh . model . geo . addPoint ( p [ 0 ], p [ 1 ], p [ 2 ]) for p in wall ] # blade splines and transfinite curves if self . dlr_mesh : spl_1 = gmsh . model . geo . addSpline ( pt_wall [: 35 ]) spl_2 = gmsh . model . geo . addSpline ( pt_wall [ 35 - 1 : 88 ]) spl_3 = gmsh . model . geo . addSpline ( pt_wall [ 88 - 1 : 129 ]) spl_4 = gmsh . model . geo . addSpline ( pt_wall [ 129 - 1 : 157 ]) spl_5 = gmsh . model . geo . addSpline ( pt_wall [ 157 - 1 : 168 ]) spl_6 = gmsh . model . geo . addSpline ( pt_wall [ 168 - 1 : 179 ]) spl_7 = gmsh . model . geo . addSpline ( pt_wall [ 179 - 1 : 245 ]) spl_8 = gmsh . model . geo . addSpline ( pt_wall [ 245 - 1 : 287 ]) spl_9 = gmsh . model . geo . addSpline ( pt_wall [ 287 - 1 : 322 ] + [ pt_wall [ 0 ]]) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_1 , self . le // 2 , \"Progression\" , 1.02 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_2 , self . nodes_sp2 , \"Progression\" , 1.03 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_3 , self . nodes_sp3 , \"Progression\" , 1 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_4 , self . nodes_sp4 , \"Progression\" , 0.94 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_5 , self . te // 2 , \"Progression\" , 0.97 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_6 , self . te // 2 , \"Progression\" , 1.025 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_7 , self . nodes_sp7 , \"Progression\" , 1.015 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_8 , self . nodes_sp8 , \"Progression\" , 0.955 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_9 , self . le // 2 , \"Progression\" , 0.9 ) spl_list = [ spl_1 , spl_2 , spl_3 , spl_4 , spl_5 , spl_6 , spl_7 , spl_8 , spl_9 ] else : spl_le = gmsh . model . geo . addSpline ( pt_wall [ 287 - 1 : 322 ] + [ pt_wall [ 0 ]] + pt_wall [: 35 ]) spl_ss = gmsh . model . geo . addSpline ( pt_wall [ 35 - 1 : 88 ] + pt_wall [ 88 - 1 : 129 ] + pt_wall [ 129 - 1 : 157 ] ) spl_te = gmsh . model . geo . addSpline ( pt_wall [ 157 - 1 : 168 ] + pt_wall [ 168 - 1 : 179 ]) spl_ps = gmsh . model . geo . addSpline ( pt_wall [ 179 - 1 : 245 ] + pt_wall [ 245 - 1 : 287 ]) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_le , self . le , \"Progression\" , 1.0 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_ss , self . nodes_ss , \"Progression\" , 1.0 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_te , self . te , \"Progression\" , 1 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_ps , self . nodes_ps , \"Progression\" , 1.0 ) spl_list = [ spl_le , spl_ss , spl_te , spl_ps ] blade_loop = gmsh . model . geo . addCurveLoop ( spl_list ) # domain construction points pt_323 = gmsh . model . geo . addPoint ( - 6e-2 , - 5e-2 , 0. ) pt_324 = gmsh . model . geo . addPoint ( - 1.5e-2 , - 2.5e-2 , 0. ) pt_325 = gmsh . model . geo . addPoint ( 0. , - 1.7e-2 , 0. ) pt_326 = gmsh . model . geo . addPoint ( 1.270973e-02 , - 1.164466e-02 , 0. ) pt_327 = gmsh . model . geo . addPoint ( 2.585445e-02 , - 7.360298e-03 , 0. ) pt_328 = gmsh . model . geo . addPoint ( 3.934429e-02 , - 4.053609e-03 , 0. ) pt_329 = gmsh . model . geo . addPoint ( 5.308943e-02 , - 1.631280e-03 , 0. ) pt_330 = gmsh . model . geo . addPoint ( 6.7e-2 , 0. , 0. ) pt_331 = gmsh . model . geo . addPoint ( 6.7e-2 + self . doutlet , 0. , 0. ) pt_332 = gmsh . model . geo . addPoint ( 6.7e-2 + self . doutlet , 4.039e-2 , 0. ) pt_333 = gmsh . model . geo . addPoint ( 6.7e-2 , 4.039e-2 , 0. ) pt_334 = gmsh . model . geo . addPoint ( 5.308943e-02 , 3.875872e-02 , 0. ) pt_335 = gmsh . model . geo . addPoint ( 3.934429e-02 , 3.633639e-02 , 0. ) pt_336 = gmsh . model . geo . addPoint ( 2.585445e-02 , 3.302970e-02 , 0. ) pt_337 = gmsh . model . geo . addPoint ( 1.270973e-02 , 2.874534e-02 , 0. ) pt_338 = gmsh . model . geo . addPoint ( 0. , 2.339e-2 , 0. ) pt_339 = gmsh . model . geo . addPoint ( - 1.5e-2 , 1.539e-2 , 0. ) pt_340 = gmsh . model . geo . addPoint ( - 6e-2 , - 9.61e-3 , 0. ) # domain construction lines l_10 = gmsh . model . geo . addLine ( pt_340 , pt_323 , tag = 10 ) l_11 = gmsh . model . geo . addLine ( pt_323 , pt_324 , tag = 11 ) l_12 = gmsh . model . geo . addLine ( pt_339 , pt_340 , tag = 12 ) if self . dlr_mesh : l_13 = gmsh . model . geo . addLine ( pt_324 , pt_339 , tag = 13 ) l_14 = gmsh . model . geo . addLine ( pt_324 , pt_325 , tag = 14 ) l_15 = gmsh . model . geo . addLine ( pt_325 , pt_326 , tag = 15 ) l_16 = gmsh . model . geo . addLine ( pt_326 , pt_327 , tag = 16 ) l_17 = gmsh . model . geo . addLine ( pt_327 , pt_328 , tag = 17 ) l_18 = gmsh . model . geo . addLine ( pt_328 , pt_329 , tag = 18 ) l_19 = gmsh . model . geo . addLine ( pt_329 , pt_330 , tag = 19 ) l_20 = gmsh . model . geo . addLine ( pt_330 , pt_331 , tag = 20 ) l_21 = gmsh . model . geo . addLine ( pt_331 , pt_332 , tag = 21 ) l_22 = gmsh . model . geo . addLine ( pt_332 , pt_333 , tag = 22 ) l_23 = gmsh . model . geo . addLine ( pt_333 , pt_334 , tag = 23 ) l_24 = gmsh . model . geo . addLine ( pt_334 , pt_335 , tag = 24 ) l_25 = gmsh . model . geo . addLine ( pt_335 , pt_336 , tag = 25 ) l_26 = gmsh . model . geo . addLine ( pt_336 , pt_337 , tag = 26 ) l_27 = gmsh . model . geo . addLine ( pt_337 , pt_338 , tag = 27 ) l_28 = gmsh . model . geo . addLine ( pt_338 , pt_339 , tag = 28 ) # transfinite curves on non-blade boundaries gmsh . model . geo . mesh . setTransfiniteCurve ( l_10 , self . nodes_inlet , \"Progression\" , 1. ) if self . dlr_mesh : gmsh . model . geo . mesh . setTransfiniteCurve ( l_13 , self . nodes_inlet , \"Progression\" , 1. ) gmsh . model . geo . mesh . setTransfiniteCurve ( l_21 , self . nodes_outlet , \"Progression\" , 1. ) # bottom / top periodicity self . bottom_tags = [ l_11 , l_14 , l_15 , l_16 , l_17 , l_18 , l_19 , l_20 ] self . top_tags = [ l_12 , l_28 , l_27 , l_26 , l_25 , l_24 , l_23 , l_22 ] # bottom non-curved side nodes gmsh . model . geo . mesh . setTransfiniteCurve ( l_11 , self . snodes_inlet , \"Progression\" , 1. ) gmsh . model . geo . mesh . setTransfiniteCurve ( l_20 , self . snodes_outlet , \"Progression\" , 1. ) # bottom curved side nodes _ = [ gmsh . model . geo . mesh . setTransfiniteCurve ( l_i , self . c_snodes , \"Progression\" , 1. ) for l_i in self . bottom_tags [ 1 : - 1 ]] # periodic boundaries /y direction gmsh . model . geo . synchronize () translation = [ 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0.04039 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 ] for tid , bid in zip ( self . top_tags , self . bottom_tags ): gmsh . model . mesh . setPeriodic ( 1 , [ tid ], [ bid ], translation ) # closed curve loop and computational domain surface definition if self . dlr_mesh : cloop_2 = gmsh . model . geo . addCurveLoop ([ l_10 , l_11 , l_12 , l_13 ]) cloop_3 = gmsh . model . geo . addCurveLoop ( [ - l_13 , l_14 , l_15 , l_16 , l_17 , l_18 , l_19 , l_20 , l_21 , l_22 , l_23 , l_24 , l_25 , l_26 , l_27 , l_28 ,] ) surf_1 = gmsh . model . geo . addPlaneSurface ([ cloop_2 ], tag = 1002 ) surf_2 = gmsh . model . geo . addPlaneSurface ([ cloop_3 , blade_loop ], tag = 1003 ) gmsh . model . geo . mesh . setTransfiniteSurface ( surf_1 ) else : cloop_3 = gmsh . model . geo . addCurveLoop ( [ l_10 , l_11 , l_14 , l_15 , l_16 , l_17 , l_18 , l_19 , l_20 , l_21 , l_22 , l_23 , l_24 , l_25 , l_26 , l_27 , l_28 , l_12 ] ) surf_2 = gmsh . model . geo . addPlaneSurface ([ cloop_3 , blade_loop ], tag = 1003 ) # Fields definition # Boundary Layer self . build_bl ( spl_list ) if self . bl else 0 # Cylinder #1 f_cyl1 = self . build_cylinder_field ( 9e-3 , self . cyl_vin , self . cyl_vout , self . cyl_xaxis , self . cyl_xcenter , - 1.171e-3 , 1.9754e-2 ) # Cylinder #2 f_cyl2 = self . build_cylinder_field ( 1.62e-2 , 1.6e-3 , 5e-3 , 2.01e-2 , 8.699e-2 , - 1.406e-3 , 1.9519e-2 ) # MinAniso self . build_minaniso_field ([ f_cyl1 , f_cyl2 ]) # define physical groups for boundary conditions self . surf_tag = [ surf_1 , surf_2 ] if self . dlr_mesh else [ surf_2 ] if self . extrusion_layers == 0 : gmsh . model . geo . addPhysicalGroup ( 2 , self . surf_tag , tag = 100 , name = \"fluid\" ) gmsh . model . geo . addPhysicalGroup ( 1 , [ l_10 ], tag = 10 , name = \"inlet\" ) logger . debug ( f \"2D BC: Inlet tags are { [ l_10 ] } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , [ l_21 ], tag = 20 , name = \"outlet\" ) logger . debug ( f \"2D BC: Outlet tags are { [ l_21 ] } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , spl_list , tag = 30 , name = \"wall\" ) logger . debug ( f \"2D BC: Wall tags are { spl_list } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , self . top_tags , tag = 40 , name = \"periodic_vert_l\" ) logger . debug ( f \"2D BC: Top tags are { self . top_tags } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , self . bottom_tags , tag = 50 , name = \"periodic_vert_r\" ) logger . debug ( f \"2D BC: Bottom tags are { self . bottom_tags } \" ) else : gmsh . model . geo . addPhysicalGroup ( 2 , self . surf_tag , tag = 100 , name = \"periodic_span_l\" ) # non-corner points defined as flow-field, inner block line and wall nodes self . non_corner_tags . extend ([ abs ( s_tag ) for s_tag in self . surf_tag ]) self . non_corner_tags . extend ([ abs ( s_tag ) for s_tag in spl_list ]) if self . dlr_mesh : self . non_corner_tags . append ( abs ( l_13 )) def build_3dmesh ( self ): \"\"\" **Performs** an extrusion along the z axis. - h_size (float): the total extruded depth. \"\"\" h_size = self . extrusion_size self . ext_tag = [ gmsh . model . geo . extrude ( [( 2 , s )], 0 , 0 , h_size , [ self . extrusion_layers ], [ 1 ], True ) for s in self . surf_tag ] # retrieve extruded surfaces and volumes vol = [ tu [ - 1 ] for tu in [ self . ext_tag [ 0 ][ 1 ], self . ext_tag [ 1 ][ 1 ]]] top = [ tu [ - 1 ] for tu in [ self . ext_tag [ 0 ][ 0 ], self . ext_tag [ 1 ][ 0 ]]] # 1st block inlet = [ self . ext_tag [ 0 ][ 2 ][ - 1 ]] perlo = [ self . ext_tag [ 0 ][ 3 ][ - 1 ]] perup = [ self . ext_tag [ 0 ][ 5 ][ - 1 ]] # 2nd block perlo += [ tu [ - 1 ] for tu in self . ext_tag [ 1 ][ 3 : 10 ]] outlet = [ self . ext_tag [ 1 ][ 10 ][ - 1 ]] perup += [ tu [ - 1 ] for tu in self . ext_tag [ 1 ][ 11 : 18 ]] wall = [ tu [ - 1 ] for tu in self . ext_tag [ 1 ][ 18 :]] # create physical groups gmsh . model . geo . addPhysicalGroup ( 3 , vol , tag = 2000 , name = \"fluid\" ) logger . debug ( \"3D BC: vol tag is 2000\" ) gmsh . model . geo . addPhysicalGroup ( 2 , top , tag = 2001 , name = \"periodic_span_r\" ) logger . debug ( \"3D BC: periodic_span_l tag is 100\" ) logger . debug ( \"3D BC: periodic_span_r tag is 2001\" ) gmsh . model . geo . addPhysicalGroup ( 2 , perlo , tag = 2003 , name = \"periodic_vert_l\" ) logger . debug ( \"3D BC: periodic_vert_l tag is 2003\" ) gmsh . model . geo . addPhysicalGroup ( 2 , perup , tag = 2004 , name = \"periodic_vert_r\" ) logger . debug ( \"3D BC: periodic_vert_r tag is 2004\" ) gmsh . model . geo . addPhysicalGroup ( 2 , inlet , tag = 2005 , name = \"inlet\" ) logger . debug ( \"3D BC: inlet tag is 2005\" ) gmsh . model . geo . addPhysicalGroup ( 2 , outlet , tag = 2006 , name = \"outlet\" ) logger . debug ( \"3D BC: outlet tag is 2006\" ) gmsh . model . geo . addPhysicalGroup ( 2 , wall , tag = 2007 , name = \"wall\" ) logger . debug ( \"3D BC: wall tag is 2007\" ) # set 2 tags to none to prevent reformatting self . non_corner_tags = None self . bottom_tags = None self . top_tags = None","title":"CascadeMesh"},{"location":"dev_mesh/#mesh.cascade_mesh.CascadeMesh.__init__","text":"Instantiates the CascadeMesh object. Input config (dict): the config file dictionary. dat_file (str): path to input_geometry.dat. Inner doutlet (float): outlet distance to the blade trailing edge. dlr_mesh (bool): builds the DLR provided mesh (True) or a simpler for adaptation (False). bl_sizefar (float): boundary layer mesh size far from the curves. nodes_inlet (int): the number of nodes to mesh the inlet. nodes_outlet (int): the number of nodes to mesh the outlet. snodes_inlet (int): the number of nodes to mesh the inlet top and bottom sides. snodes_outlet (int): the number of nodes to mesh the outlet top and bottom sides. c_snodes (int): the number of nodes to mesh the inner sides. le (int): the number of nodes to mesh the blade leading edge portion. te (int): the number of nodes to mesh the blade trailing edge lower portion. nodes_sp2 (int): the number of nodes to mesh the 1st section of the blade suction side. nodes_sp3 (int): the number of nodes to mesh the 2nd section of the blade suction side. nodes_sp4 (int): the number of nodes to mesh the 3rd section of the blade suction side. nodes_sp7 (int): the number of nodes to mesh the 1st section of the blade pressure side. nodes_sp8 (int): the number of nodes to mesh the 2nd section of the blade pressure side. nodes_ss (int): the number of nodes to mesh the suction side (dlr_mesh set to False). nodes_ps (int): the number of nodes to mesh the pressure side (dlr_mesh set to False). cyl_vin (float): cylinder field parameter Vin. cyl_vout (float): cylinder field parameter Vout. cyl_xaxis (float): cylinder field parameter Xaxis. cyl_xcenter (float): cylinder field parameter Xcenter. Note for the DLR configuration, the blade is split into 9 splines (clockwise from the tip): 2 splines (1 and 9) for the leading edge parameterized with le i.e. each spline has le /2 nodes, 2 splines (5 and 6) for the trailing edge parameterized with te i.e. each spline has te /2 nodes, 3 splines for the suction side (2, 3, 4) of lengths 0.027, 0.038 and 0.061 m, and parameterized with nodes_sp2 , nodes_sp3 and nodes_sp4 , 2 splines for the pressure side (7, 8) of lengths 0.0526 and 0.0167 m, and parameterized with nodes_sp7 , nodes_sp8 Source code in aero_optim/mesh/cascade_mesh.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def __init__ ( self , config : dict , datfile : str = \"\" ): \"\"\" Instantiates the CascadeMesh object. **Input** - config (dict): the config file dictionary. - dat_file (str): path to input_geometry.dat. **Inner** - doutlet (float): outlet distance to the blade trailing edge. - dlr_mesh (bool): builds the DLR provided mesh (True) or a simpler for adaptation (False). - bl_sizefar (float): boundary layer mesh size far from the curves. - nodes_inlet (int): the number of nodes to mesh the inlet. - nodes_outlet (int): the number of nodes to mesh the outlet. - snodes_inlet (int): the number of nodes to mesh the inlet top and bottom sides. - snodes_outlet (int): the number of nodes to mesh the outlet top and bottom sides. - c_snodes (int): the number of nodes to mesh the inner sides. - le (int): the number of nodes to mesh the blade leading edge portion. - te (int): the number of nodes to mesh the blade trailing edge lower portion. - nodes_sp2 (int): the number of nodes to mesh the 1st section of the blade suction side. - nodes_sp3 (int): the number of nodes to mesh the 2nd section of the blade suction side. - nodes_sp4 (int): the number of nodes to mesh the 3rd section of the blade suction side. - nodes_sp7 (int): the number of nodes to mesh the 1st section of the blade pressure side. - nodes_sp8 (int): the number of nodes to mesh the 2nd section of the blade pressure side. - nodes_ss (int): the number of nodes to mesh the suction side (dlr_mesh set to False). - nodes_ps (int): the number of nodes to mesh the pressure side (dlr_mesh set to False). - cyl_vin (float): cylinder field parameter Vin. - cyl_vout (float): cylinder field parameter Vout. - cyl_xaxis (float): cylinder field parameter Xaxis. - cyl_xcenter (float): cylinder field parameter Xcenter. Note: for the DLR configuration, the blade is split into 9 splines (clockwise from the tip): * 2 splines (1 and 9) for the leading edge parameterized with **le** i.e. each spline has **le**/2 nodes, * 2 splines (5 and 6) for the trailing edge parameterized with **te** i.e. each spline has **te**/2 nodes, * 3 splines for the suction side (2, 3, 4) of lengths 0.027, 0.038 and 0.061 m, and parameterized with **nodes_sp2**, **nodes_sp3** and **nodes_sp4**, * 2 splines for the pressure side (7, 8) of lengths 0.0526 and 0.0167 m, and parameterized with **nodes_sp7**, **nodes_sp8** \"\"\" super () . __init__ ( config , datfile ) self . doutlet : float = self . config [ \"gmsh\" ][ \"domain\" ] . get ( \"outlet\" , 6.3e-2 ) self . dlr_mesh : bool = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"DLR_mesh\" , False ) self . bl_sizefar : float = config [ \"gmsh\" ][ \"mesh\" ] . get ( \"bl_sizefar\" , 1e-5 ) self . nodes_inlet : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_inlet\" , 25 ) self . nodes_outlet : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_outlet\" , 17 ) self . snodes_inlet : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"side_nodes_inlet\" , 31 ) self . snodes_outlet : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"side_nodes_outlet\" , 31 ) self . c_snodes : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"curved_side_nodes\" , 7 ) self . le : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"le\" , 16 ) self . te : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"te\" , 16 ) self . nodes_sp2 : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_sp2\" , 42 ) self . nodes_sp3 : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_sp3\" , 42 ) self . nodes_sp4 : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_sp4\" , 14 ) self . nodes_sp7 : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_sp7\" , 57 ) self . nodes_sp8 : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_sp8\" , 32 ) self . nodes_ss : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_ss\" , 400 ) self . nodes_ps : int = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"nodes_ps\" , 400 ) self . cyl_vin : float = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"cyl_vin\" , 8e-4 ) self . cyl_vout : float = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"cyl_vout\" , 5e-3 ) self . cyl_xaxis : float = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"cyl_xaxis\" , 1.675e-2 ) self . cyl_xcenter : float = self . config [ \"gmsh\" ][ \"mesh\" ] . get ( \"cyl_xcenter\" , 8.364e-2 )","title":"__init__"},{"location":"dev_mesh/#mesh.cascade_mesh.CascadeMesh.build_2dmesh","text":"Builds the surface mesh of the computational domain. Source code in aero_optim/mesh/cascade_mesh.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 def build_2dmesh ( self ): \"\"\" **Builds** the surface mesh of the computational domain. \"\"\" wall = self . reorder_blade () pt_wall = [ gmsh . model . geo . addPoint ( p [ 0 ], p [ 1 ], p [ 2 ]) for p in wall ] # blade splines and transfinite curves if self . dlr_mesh : spl_1 = gmsh . model . geo . addSpline ( pt_wall [: 35 ]) spl_2 = gmsh . model . geo . addSpline ( pt_wall [ 35 - 1 : 88 ]) spl_3 = gmsh . model . geo . addSpline ( pt_wall [ 88 - 1 : 129 ]) spl_4 = gmsh . model . geo . addSpline ( pt_wall [ 129 - 1 : 157 ]) spl_5 = gmsh . model . geo . addSpline ( pt_wall [ 157 - 1 : 168 ]) spl_6 = gmsh . model . geo . addSpline ( pt_wall [ 168 - 1 : 179 ]) spl_7 = gmsh . model . geo . addSpline ( pt_wall [ 179 - 1 : 245 ]) spl_8 = gmsh . model . geo . addSpline ( pt_wall [ 245 - 1 : 287 ]) spl_9 = gmsh . model . geo . addSpline ( pt_wall [ 287 - 1 : 322 ] + [ pt_wall [ 0 ]]) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_1 , self . le // 2 , \"Progression\" , 1.02 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_2 , self . nodes_sp2 , \"Progression\" , 1.03 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_3 , self . nodes_sp3 , \"Progression\" , 1 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_4 , self . nodes_sp4 , \"Progression\" , 0.94 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_5 , self . te // 2 , \"Progression\" , 0.97 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_6 , self . te // 2 , \"Progression\" , 1.025 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_7 , self . nodes_sp7 , \"Progression\" , 1.015 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_8 , self . nodes_sp8 , \"Progression\" , 0.955 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_9 , self . le // 2 , \"Progression\" , 0.9 ) spl_list = [ spl_1 , spl_2 , spl_3 , spl_4 , spl_5 , spl_6 , spl_7 , spl_8 , spl_9 ] else : spl_le = gmsh . model . geo . addSpline ( pt_wall [ 287 - 1 : 322 ] + [ pt_wall [ 0 ]] + pt_wall [: 35 ]) spl_ss = gmsh . model . geo . addSpline ( pt_wall [ 35 - 1 : 88 ] + pt_wall [ 88 - 1 : 129 ] + pt_wall [ 129 - 1 : 157 ] ) spl_te = gmsh . model . geo . addSpline ( pt_wall [ 157 - 1 : 168 ] + pt_wall [ 168 - 1 : 179 ]) spl_ps = gmsh . model . geo . addSpline ( pt_wall [ 179 - 1 : 245 ] + pt_wall [ 245 - 1 : 287 ]) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_le , self . le , \"Progression\" , 1.0 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_ss , self . nodes_ss , \"Progression\" , 1.0 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_te , self . te , \"Progression\" , 1 ) gmsh . model . geo . mesh . setTransfiniteCurve ( spl_ps , self . nodes_ps , \"Progression\" , 1.0 ) spl_list = [ spl_le , spl_ss , spl_te , spl_ps ] blade_loop = gmsh . model . geo . addCurveLoop ( spl_list ) # domain construction points pt_323 = gmsh . model . geo . addPoint ( - 6e-2 , - 5e-2 , 0. ) pt_324 = gmsh . model . geo . addPoint ( - 1.5e-2 , - 2.5e-2 , 0. ) pt_325 = gmsh . model . geo . addPoint ( 0. , - 1.7e-2 , 0. ) pt_326 = gmsh . model . geo . addPoint ( 1.270973e-02 , - 1.164466e-02 , 0. ) pt_327 = gmsh . model . geo . addPoint ( 2.585445e-02 , - 7.360298e-03 , 0. ) pt_328 = gmsh . model . geo . addPoint ( 3.934429e-02 , - 4.053609e-03 , 0. ) pt_329 = gmsh . model . geo . addPoint ( 5.308943e-02 , - 1.631280e-03 , 0. ) pt_330 = gmsh . model . geo . addPoint ( 6.7e-2 , 0. , 0. ) pt_331 = gmsh . model . geo . addPoint ( 6.7e-2 + self . doutlet , 0. , 0. ) pt_332 = gmsh . model . geo . addPoint ( 6.7e-2 + self . doutlet , 4.039e-2 , 0. ) pt_333 = gmsh . model . geo . addPoint ( 6.7e-2 , 4.039e-2 , 0. ) pt_334 = gmsh . model . geo . addPoint ( 5.308943e-02 , 3.875872e-02 , 0. ) pt_335 = gmsh . model . geo . addPoint ( 3.934429e-02 , 3.633639e-02 , 0. ) pt_336 = gmsh . model . geo . addPoint ( 2.585445e-02 , 3.302970e-02 , 0. ) pt_337 = gmsh . model . geo . addPoint ( 1.270973e-02 , 2.874534e-02 , 0. ) pt_338 = gmsh . model . geo . addPoint ( 0. , 2.339e-2 , 0. ) pt_339 = gmsh . model . geo . addPoint ( - 1.5e-2 , 1.539e-2 , 0. ) pt_340 = gmsh . model . geo . addPoint ( - 6e-2 , - 9.61e-3 , 0. ) # domain construction lines l_10 = gmsh . model . geo . addLine ( pt_340 , pt_323 , tag = 10 ) l_11 = gmsh . model . geo . addLine ( pt_323 , pt_324 , tag = 11 ) l_12 = gmsh . model . geo . addLine ( pt_339 , pt_340 , tag = 12 ) if self . dlr_mesh : l_13 = gmsh . model . geo . addLine ( pt_324 , pt_339 , tag = 13 ) l_14 = gmsh . model . geo . addLine ( pt_324 , pt_325 , tag = 14 ) l_15 = gmsh . model . geo . addLine ( pt_325 , pt_326 , tag = 15 ) l_16 = gmsh . model . geo . addLine ( pt_326 , pt_327 , tag = 16 ) l_17 = gmsh . model . geo . addLine ( pt_327 , pt_328 , tag = 17 ) l_18 = gmsh . model . geo . addLine ( pt_328 , pt_329 , tag = 18 ) l_19 = gmsh . model . geo . addLine ( pt_329 , pt_330 , tag = 19 ) l_20 = gmsh . model . geo . addLine ( pt_330 , pt_331 , tag = 20 ) l_21 = gmsh . model . geo . addLine ( pt_331 , pt_332 , tag = 21 ) l_22 = gmsh . model . geo . addLine ( pt_332 , pt_333 , tag = 22 ) l_23 = gmsh . model . geo . addLine ( pt_333 , pt_334 , tag = 23 ) l_24 = gmsh . model . geo . addLine ( pt_334 , pt_335 , tag = 24 ) l_25 = gmsh . model . geo . addLine ( pt_335 , pt_336 , tag = 25 ) l_26 = gmsh . model . geo . addLine ( pt_336 , pt_337 , tag = 26 ) l_27 = gmsh . model . geo . addLine ( pt_337 , pt_338 , tag = 27 ) l_28 = gmsh . model . geo . addLine ( pt_338 , pt_339 , tag = 28 ) # transfinite curves on non-blade boundaries gmsh . model . geo . mesh . setTransfiniteCurve ( l_10 , self . nodes_inlet , \"Progression\" , 1. ) if self . dlr_mesh : gmsh . model . geo . mesh . setTransfiniteCurve ( l_13 , self . nodes_inlet , \"Progression\" , 1. ) gmsh . model . geo . mesh . setTransfiniteCurve ( l_21 , self . nodes_outlet , \"Progression\" , 1. ) # bottom / top periodicity self . bottom_tags = [ l_11 , l_14 , l_15 , l_16 , l_17 , l_18 , l_19 , l_20 ] self . top_tags = [ l_12 , l_28 , l_27 , l_26 , l_25 , l_24 , l_23 , l_22 ] # bottom non-curved side nodes gmsh . model . geo . mesh . setTransfiniteCurve ( l_11 , self . snodes_inlet , \"Progression\" , 1. ) gmsh . model . geo . mesh . setTransfiniteCurve ( l_20 , self . snodes_outlet , \"Progression\" , 1. ) # bottom curved side nodes _ = [ gmsh . model . geo . mesh . setTransfiniteCurve ( l_i , self . c_snodes , \"Progression\" , 1. ) for l_i in self . bottom_tags [ 1 : - 1 ]] # periodic boundaries /y direction gmsh . model . geo . synchronize () translation = [ 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0.04039 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 ] for tid , bid in zip ( self . top_tags , self . bottom_tags ): gmsh . model . mesh . setPeriodic ( 1 , [ tid ], [ bid ], translation ) # closed curve loop and computational domain surface definition if self . dlr_mesh : cloop_2 = gmsh . model . geo . addCurveLoop ([ l_10 , l_11 , l_12 , l_13 ]) cloop_3 = gmsh . model . geo . addCurveLoop ( [ - l_13 , l_14 , l_15 , l_16 , l_17 , l_18 , l_19 , l_20 , l_21 , l_22 , l_23 , l_24 , l_25 , l_26 , l_27 , l_28 ,] ) surf_1 = gmsh . model . geo . addPlaneSurface ([ cloop_2 ], tag = 1002 ) surf_2 = gmsh . model . geo . addPlaneSurface ([ cloop_3 , blade_loop ], tag = 1003 ) gmsh . model . geo . mesh . setTransfiniteSurface ( surf_1 ) else : cloop_3 = gmsh . model . geo . addCurveLoop ( [ l_10 , l_11 , l_14 , l_15 , l_16 , l_17 , l_18 , l_19 , l_20 , l_21 , l_22 , l_23 , l_24 , l_25 , l_26 , l_27 , l_28 , l_12 ] ) surf_2 = gmsh . model . geo . addPlaneSurface ([ cloop_3 , blade_loop ], tag = 1003 ) # Fields definition # Boundary Layer self . build_bl ( spl_list ) if self . bl else 0 # Cylinder #1 f_cyl1 = self . build_cylinder_field ( 9e-3 , self . cyl_vin , self . cyl_vout , self . cyl_xaxis , self . cyl_xcenter , - 1.171e-3 , 1.9754e-2 ) # Cylinder #2 f_cyl2 = self . build_cylinder_field ( 1.62e-2 , 1.6e-3 , 5e-3 , 2.01e-2 , 8.699e-2 , - 1.406e-3 , 1.9519e-2 ) # MinAniso self . build_minaniso_field ([ f_cyl1 , f_cyl2 ]) # define physical groups for boundary conditions self . surf_tag = [ surf_1 , surf_2 ] if self . dlr_mesh else [ surf_2 ] if self . extrusion_layers == 0 : gmsh . model . geo . addPhysicalGroup ( 2 , self . surf_tag , tag = 100 , name = \"fluid\" ) gmsh . model . geo . addPhysicalGroup ( 1 , [ l_10 ], tag = 10 , name = \"inlet\" ) logger . debug ( f \"2D BC: Inlet tags are { [ l_10 ] } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , [ l_21 ], tag = 20 , name = \"outlet\" ) logger . debug ( f \"2D BC: Outlet tags are { [ l_21 ] } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , spl_list , tag = 30 , name = \"wall\" ) logger . debug ( f \"2D BC: Wall tags are { spl_list } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , self . top_tags , tag = 40 , name = \"periodic_vert_l\" ) logger . debug ( f \"2D BC: Top tags are { self . top_tags } \" ) gmsh . model . geo . addPhysicalGroup ( 1 , self . bottom_tags , tag = 50 , name = \"periodic_vert_r\" ) logger . debug ( f \"2D BC: Bottom tags are { self . bottom_tags } \" ) else : gmsh . model . geo . addPhysicalGroup ( 2 , self . surf_tag , tag = 100 , name = \"periodic_span_l\" ) # non-corner points defined as flow-field, inner block line and wall nodes self . non_corner_tags . extend ([ abs ( s_tag ) for s_tag in self . surf_tag ]) self . non_corner_tags . extend ([ abs ( s_tag ) for s_tag in spl_list ]) if self . dlr_mesh : self . non_corner_tags . append ( abs ( l_13 ))","title":"build_2dmesh"},{"location":"dev_mesh/#mesh.cascade_mesh.CascadeMesh.build_3dmesh","text":"Performs an extrusion along the z axis. - h_size (float): the total extruded depth. Source code in aero_optim/mesh/cascade_mesh.py 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 def build_3dmesh ( self ): \"\"\" **Performs** an extrusion along the z axis. - h_size (float): the total extruded depth. \"\"\" h_size = self . extrusion_size self . ext_tag = [ gmsh . model . geo . extrude ( [( 2 , s )], 0 , 0 , h_size , [ self . extrusion_layers ], [ 1 ], True ) for s in self . surf_tag ] # retrieve extruded surfaces and volumes vol = [ tu [ - 1 ] for tu in [ self . ext_tag [ 0 ][ 1 ], self . ext_tag [ 1 ][ 1 ]]] top = [ tu [ - 1 ] for tu in [ self . ext_tag [ 0 ][ 0 ], self . ext_tag [ 1 ][ 0 ]]] # 1st block inlet = [ self . ext_tag [ 0 ][ 2 ][ - 1 ]] perlo = [ self . ext_tag [ 0 ][ 3 ][ - 1 ]] perup = [ self . ext_tag [ 0 ][ 5 ][ - 1 ]] # 2nd block perlo += [ tu [ - 1 ] for tu in self . ext_tag [ 1 ][ 3 : 10 ]] outlet = [ self . ext_tag [ 1 ][ 10 ][ - 1 ]] perup += [ tu [ - 1 ] for tu in self . ext_tag [ 1 ][ 11 : 18 ]] wall = [ tu [ - 1 ] for tu in self . ext_tag [ 1 ][ 18 :]] # create physical groups gmsh . model . geo . addPhysicalGroup ( 3 , vol , tag = 2000 , name = \"fluid\" ) logger . debug ( \"3D BC: vol tag is 2000\" ) gmsh . model . geo . addPhysicalGroup ( 2 , top , tag = 2001 , name = \"periodic_span_r\" ) logger . debug ( \"3D BC: periodic_span_l tag is 100\" ) logger . debug ( \"3D BC: periodic_span_r tag is 2001\" ) gmsh . model . geo . addPhysicalGroup ( 2 , perlo , tag = 2003 , name = \"periodic_vert_l\" ) logger . debug ( \"3D BC: periodic_vert_l tag is 2003\" ) gmsh . model . geo . addPhysicalGroup ( 2 , perup , tag = 2004 , name = \"periodic_vert_r\" ) logger . debug ( \"3D BC: periodic_vert_r tag is 2004\" ) gmsh . model . geo . addPhysicalGroup ( 2 , inlet , tag = 2005 , name = \"inlet\" ) logger . debug ( \"3D BC: inlet tag is 2005\" ) gmsh . model . geo . addPhysicalGroup ( 2 , outlet , tag = 2006 , name = \"outlet\" ) logger . debug ( \"3D BC: outlet tag is 2006\" ) gmsh . model . geo . addPhysicalGroup ( 2 , wall , tag = 2007 , name = \"wall\" ) logger . debug ( \"3D BC: wall tag is 2007\" ) # set 2 tags to none to prevent reformatting self . non_corner_tags = None self . bottom_tags = None self . top_tags = None","title":"build_3dmesh"},{"location":"dev_mesh/#mesh.cascade_mesh.CascadeMesh.build_bl","text":"Builds the boundary layer around the blade. Source code in aero_optim/mesh/cascade_mesh.py 100 101 102 103 104 105 106 107 108 109 110 111 def build_bl ( self , blade_tag : list [ int ]): \"\"\" **Builds** the boundary layer around the blade. \"\"\" f_bl = gmsh . model . mesh . field . add ( 'BoundaryLayer' ) gmsh . model . mesh . field . setNumbers ( f_bl , 'CurvesList' , blade_tag ) gmsh . model . mesh . field . setNumber ( f_bl , 'Size' , self . bl_size ) gmsh . model . mesh . field . setNumber ( f_bl , 'Ratio' , self . bl_ratio ) gmsh . model . mesh . field . setNumber ( f_bl , 'Quads' , int ( self . structured )) gmsh . model . mesh . field . setNumber ( f_bl , 'Thickness' , self . bl_thickness ) gmsh . model . mesh . field . setNumber ( f_bl , 'SizeFar' , self . bl_sizefar ) gmsh . model . mesh . field . setAsBoundaryLayer ( f_bl )","title":"build_bl"},{"location":"dev_mesh/#mesh.cascade_mesh.CascadeMesh.build_cylinder_field","text":"Builds a cylinder field in the computational domain. Source code in aero_optim/mesh/cascade_mesh.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 def build_cylinder_field ( self , radius : float , VIn : float , VOut : float , XAxis : float , XCenter : float , YAxis : float , YCenter : float , ZAxis : float = 0. ) -> int : \"\"\" **Builds** a cylinder field in the computational domain. \"\"\" f_cyl = gmsh . model . mesh . field . add ( 'Cylinder' ) gmsh . model . mesh . field . setNumber ( f_cyl , 'Radius' , radius ) gmsh . model . mesh . field . setNumber ( f_cyl , 'VIn' , VIn ) gmsh . model . mesh . field . setNumber ( f_cyl , 'VOut' , VOut ) gmsh . model . mesh . field . setNumber ( f_cyl , 'XAxis' , XAxis ) gmsh . model . mesh . field . setNumber ( f_cyl , 'XCenter' , XCenter ) gmsh . model . mesh . field . setNumber ( f_cyl , 'YAxis' , YAxis ) gmsh . model . mesh . field . setNumber ( f_cyl , 'YCenter' , YCenter ) gmsh . model . mesh . field . setNumber ( f_cyl , 'ZAxis' , ZAxis ) gmsh . model . mesh . field . setAsBackgroundMesh ( f_cyl ) return f_cyl","title":"build_cylinder_field"},{"location":"dev_mesh/#mesh.cascade_mesh.CascadeMesh.build_minaniso_field","text":"Builds a MinAniso field in the computational domain. Source code in aero_optim/mesh/cascade_mesh.py 134 135 136 137 138 139 140 def build_minaniso_field ( self , tag : list [ int ]): \"\"\" **Builds** a MinAniso field in the computational domain. \"\"\" f_minaniso = gmsh . model . mesh . field . add ( 'MinAniso' ) gmsh . model . mesh . field . setNumbers ( f_minaniso , 'FieldsList' , tag ) gmsh . model . mesh . field . setAsBackgroundMesh ( f_minaniso )","title":"build_minaniso_field"},{"location":"dev_mesh/#mesh.cascade_mesh.CascadeMesh.reorder_blade","text":"Returns the blade profile after reordering. Source code in aero_optim/mesh/cascade_mesh.py 89 90 91 92 93 94 95 96 97 98 def reorder_blade ( self ) -> list [ list [ float ]]: \"\"\" **Returns** the blade profile after reordering. \"\"\" d = np . sqrt ([ x ** 2 + y ** 2 for x , y , _ in self . pts ]) start = np . argmin ( d ) if self . pts [ start + 1 ][ 1 ] > self . pts [ start ][ 1 ]: return [[ p [ 0 ], p [ 1 ], p [ 2 ]] for p in self . pts [ start :] + self . pts [: start ]] else : return [[ p [ 0 ], p [ 1 ], p [ 2 ]] for p in self . pts [: start ] + self . pts [ start :]]","title":"reorder_blade"},{"location":"dev_mfsm/","text":"MF-SM Source Code MfModel classes mf_sm.mf_models.MfModel Bases: ABC Wrapping class around a multifidelity model to define it, train it and evaluate it. Attributes: dim ( int ) \u2013 problem dimension. model_dict ( dict ) \u2013 dictionary containing all necessary model parameters. outdir ( str ) \u2013 path to the model folder. seed ( int ) \u2013 seed to enforce reproducibility. x_lf_DOE ( ndarray ) \u2013 the lf_DOE the model was trained with. x_hf_DOE ( ndarray ) \u2013 the hf_DOE the model was trained with. y_lf_DOE ( ndarray ) \u2013 the lf_DOE the model was trained with. y_hf_DOE ( ndarray ) \u2013 the hf_DOE the model was trained with. Source code in aero_optim/mf_sm/mf_models.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 class MfModel ( ABC ): \"\"\" Wrapping class around a multifidelity model to define it, train it and evaluate it. Attributes: dim (int): problem dimension. model_dict (dict): dictionary containing all necessary model parameters. outdir (str): path to the model folder. seed (int): seed to enforce reproducibility. x_lf_DOE (np.ndarray): the lf_DOE the model was trained with. x_hf_DOE (np.ndarray): the hf_DOE the model was trained with. y_lf_DOE (np.ndarray): the lf_DOE the model was trained with. y_hf_DOE (np.ndarray): the hf_DOE the model was trained with. \"\"\" def __init__ ( self , dim : int , model_dict : dict , outdir : str , seed : int ): self . dim = dim self . model_dict = model_dict self . outdir = outdir self . seed = seed self . requires_nested_doe : bool self . x_lf_DOE : np . ndarray | None = None self . x_hf_DOE : np . ndarray | None = None self . y_lf_DOE : np . ndarray | None = None self . y_hf_DOE : np . ndarray | None = None # seed numpy np . random . seed ( seed ) @abstractmethod def train ( self ): \"\"\" Trains a model with low and high fidelity data. \"\"\" @abstractmethod def evaluate ( self , x : np . ndarray ): \"\"\" Returns a model prediction for a given input x. \"\"\" def evaluate_std ( self , x : np . ndarray ): raise Exception ( \"Not implemented\" ) def get_DOE ( self ) -> np . ndarray : \"\"\" Returns the DOE the model was trained with. \"\"\" assert self . x_lf_DOE is not None and self . x_hf_DOE is not None if self . requires_nested_doe : return np . copy ( self . x_lf_DOE ) else : return np . vstack (( self . x_lf_DOE , self . x_hf_DOE )) def set_DOE ( self , x_lf : np . ndarray , x_hf : np . ndarray , y_lf : np . ndarray , y_hf : np . ndarray ): \"\"\" Sets the hf and lf DOEs the model was trained with. \"\"\" if self . x_lf_DOE is None : self . x_lf_DOE = x_lf self . x_hf_DOE = x_hf self . y_lf_DOE = y_lf self . y_hf_DOE = y_hf else : assert ( self . x_lf_DOE is not None and self . x_hf_DOE is not None and self . y_lf_DOE is not None and self . y_hf_DOE is not None ) self . x_lf_DOE = np . vstack (( self . x_lf_DOE , x_lf )) self . x_hf_DOE = np . vstack (( self . x_hf_DOE , x_hf )) if self . y_lf_DOE . ndim == 2 : self . y_lf_DOE = np . vstack (( self . y_lf_DOE , y_lf )) self . y_hf_DOE = np . vstack (( self . y_hf_DOE , y_hf )) else : self . y_lf_DOE = np . hstack (( self . y_lf_DOE , y_lf )) self . y_hf_DOE = np . hstack (( self . y_hf_DOE , y_hf )) def get_y_star ( self ) -> float | np . ndarray : \"\"\" Returns the current best lf fitness (SOO). \"\"\" # single objective, y_star is simply the min value assert self . y_hf_DOE is not None return min ( self . y_hf_DOE ) evaluate ( x : np . ndarray ) abstractmethod Returns a model prediction for a given input x. Source code in aero_optim/mf_sm/mf_models.py 55 56 57 58 59 @abstractmethod def evaluate ( self , x : np . ndarray ): \"\"\" Returns a model prediction for a given input x. \"\"\" get_DOE () -> np . ndarray Returns the DOE the model was trained with. Source code in aero_optim/mf_sm/mf_models.py 64 65 66 67 68 69 70 71 72 def get_DOE ( self ) -> np . ndarray : \"\"\" Returns the DOE the model was trained with. \"\"\" assert self . x_lf_DOE is not None and self . x_hf_DOE is not None if self . requires_nested_doe : return np . copy ( self . x_lf_DOE ) else : return np . vstack (( self . x_lf_DOE , self . x_hf_DOE )) get_y_star () -> float | np . ndarray Returns the current best lf fitness (SOO). Source code in aero_optim/mf_sm/mf_models.py 99 100 101 102 103 104 105 def get_y_star ( self ) -> float | np . ndarray : \"\"\" Returns the current best lf fitness (SOO). \"\"\" # single objective, y_star is simply the min value assert self . y_hf_DOE is not None return min ( self . y_hf_DOE ) set_DOE ( x_lf : np . ndarray , x_hf : np . ndarray , y_lf : np . ndarray , y_hf : np . ndarray ) Sets the hf and lf DOEs the model was trained with. Source code in aero_optim/mf_sm/mf_models.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def set_DOE ( self , x_lf : np . ndarray , x_hf : np . ndarray , y_lf : np . ndarray , y_hf : np . ndarray ): \"\"\" Sets the hf and lf DOEs the model was trained with. \"\"\" if self . x_lf_DOE is None : self . x_lf_DOE = x_lf self . x_hf_DOE = x_hf self . y_lf_DOE = y_lf self . y_hf_DOE = y_hf else : assert ( self . x_lf_DOE is not None and self . x_hf_DOE is not None and self . y_lf_DOE is not None and self . y_hf_DOE is not None ) self . x_lf_DOE = np . vstack (( self . x_lf_DOE , x_lf )) self . x_hf_DOE = np . vstack (( self . x_hf_DOE , x_hf )) if self . y_lf_DOE . ndim == 2 : self . y_lf_DOE = np . vstack (( self . y_lf_DOE , y_lf )) self . y_hf_DOE = np . vstack (( self . y_hf_DOE , y_hf )) else : self . y_lf_DOE = np . hstack (( self . y_lf_DOE , y_lf )) self . y_hf_DOE = np . hstack (( self . y_hf_DOE , y_hf )) train () abstractmethod Trains a model with low and high fidelity data. Source code in aero_optim/mf_sm/mf_models.py 49 50 51 52 53 @abstractmethod def train ( self ): \"\"\" Trains a model with low and high fidelity data. \"\"\" mf_sm.mf_models.MfDNN Bases: MfModel Wrapping class around a torch multifidelity deep neural network model. Source code in aero_optim/mf_sm/mf_models.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 class MfDNN ( MfModel ): \"\"\" Wrapping class around a torch multifidelity deep neural network model. \"\"\" def __init__ ( self , dim : int , model_dict : dict , outdir : str , seed : int ): super () . __init__ ( dim , model_dict , outdir , seed ) check_dir ( outdir ) self . requires_nested_doe = model_dict . get ( \"nested_doe\" , False ) self . name = model_dict . get ( \"name\" , \"MFDNN\" ) # seed torch torch . manual_seed ( seed ) # select device self . device : torch . device = torch . device ( \"cuda\" if torch . cuda . is_available () else \"cpu\" ) # the first layer of both network is created here self . model_dict [ \"NNL\" ][ \"layer_sizes_NNL\" ] . insert ( 0 , dim ) self . n_obj = self . model_dict [ \"NNL\" ][ \"layer_sizes_NNL\" ][ - 1 ] self . model_dict [ \"NNH\" ][ \"layer_sizes_NNH1\" ] . insert ( 0 , dim + self . n_obj ) self . model_dict [ \"NNH\" ][ \"layer_sizes_NNH2\" ] . insert ( 0 , dim + self . n_obj ) # low fidelity network self . NNL = NNL ( self . model_dict [ \"NNL\" ][ \"layer_sizes_NNL\" ]) # high fidelity network self . NNH = NNH ( self . model_dict [ \"NNH\" ][ \"layer_sizes_NNH1\" ], self . model_dict [ \"NNH\" ][ \"layer_sizes_NNH2\" ] ) # to device self . NNL . to ( self . device ) self . NNH . to ( self . device ) # init weights self . NNL . apply ( weights_init ) self . NNH . apply ( weights_init ) def train ( self ): # pretrain low fidelity model weight_decay_NNL = self . model_dict [ \"NNL\" ][ \"optimizer\" ] . get ( \"weight_decay\" , 0 ) if self . model_dict [ \"pretraining\" ]: loss_target = self . model_dict [ \"NNL\" ] . get ( \"loss_target\" , 1e-3 ) niter = self . model_dict [ \"NNL\" ] . get ( \"niter\" , 10000 ) # define optimizer lr = self . model_dict [ \"NNL\" ][ \"optimizer\" ] . get ( \"lr\" , 1e-3 ) NNL_optimizer = torch . optim . Adam ( self . NNL . parameters (), lr = lr , weight_decay = weight_decay_NNL ) # define scheduler if \"scheduler\" in self . model_dict [ \"NNL\" ]: NNL_scheduler = torch . optim . lr_scheduler . MultiStepLR ( NNL_optimizer , ** self . model_dict [ \"NNL\" ][ \"scheduler\" ] ) else : NNL_scheduler = None # pretrain assert self . x_lf_DOE is not None and self . y_lf_DOE is not None NNL_pretrain ( self . NNL , NNL_optimizer , self . x_lf_DOE , self . y_lf_DOE , loss_target , niter , self . device , scheduler = NNL_scheduler ) # coupled training loss_target = self . model_dict [ \"NNH\" ] . get ( \"loss_target\" , 1e-5 ) niter = self . model_dict [ \"NNH\" ] . get ( \"niter\" , 15000 ) # define optimizer lr = self . model_dict [ \"NNH\" ][ \"optimizer\" ] . get ( \"lr\" , 1e-4 ) weight_decay_NNH1 = ( self . model_dict [ \"NNH\" ][ \"optimizer\" ] . get ( \"weight_decay_NNH1\" , 0 ) ) weight_decay_NNH2 = ( self . model_dict [ \"NNH\" ][ \"optimizer\" ] . get ( \"weight_decay_NNH2\" , 0 ) ) MfDNN_optimizer = torch . optim . Adam ( [{ 'params' : self . NNH . NNH1 . parameters (), 'weight_decay' : weight_decay_NNH1 }, { 'params' : self . NNH . NNH2 . parameters (), 'weight_decay' : weight_decay_NNH2 }, { 'params' : self . NNH . alpha }, { 'params' : self . NNL . parameters (), 'weight_decay' : weight_decay_NNL }], lr = lr ) # define scheduler if \"scheduler\" in self . model_dict [ \"NNH\" ]: MfDNN_scheduler = torch . optim . lr_scheduler . MultiStepLR ( MfDNN_optimizer , ** self . model_dict [ \"NNH\" ][ \"scheduler\" ] ) else : MfDNN_scheduler = None # train assert self . x_lf_DOE is not None and self . y_lf_DOE is not None assert self . x_hf_DOE is not None and self . y_hf_DOE is not None MfDNN_train ( self . NNL , self . NNH , MfDNN_optimizer , self . x_lf_DOE , self . y_lf_DOE , self . x_hf_DOE , self . y_hf_DOE , loss_target , niter , self . device , self . outdir , scheduler = MfDNN_scheduler ) def evaluate ( self , x : np . ndarray ) -> np . ndarray | list [ np . ndarray ]: x_torch = torch . from_numpy ( x ) . float () x_torch = x_torch . to ( self . device ) y_lo_hi = self . NNL . eval ()( x_torch ) y = self . NNH . eval ()( torch . cat (( x_torch , y_lo_hi ), dim = 1 )) y_np = y . cpu () . detach () . numpy () return y_np if self . n_obj == 1 else [ y_np [:, c_ ][:, None ] for c_ in range ( self . n_obj )] mf_sm.mf_models.MfSMT Bases: MfModel Wrapping class around an smt multifidelity cokriging model. Source code in aero_optim/mf_sm/mf_models.py 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 class MfSMT ( MfModel ): \"\"\" Wrapping class around an smt multifidelity cokriging model. \"\"\" def __init__ ( self , dim : int , model_dict : dict , outdir : str , seed : int ): super () . __init__ ( dim , model_dict , outdir , seed ) self . requires_nested_doe = model_dict . get ( \"nested_doe\" , True ) self . name = model_dict . get ( \"name\" , \"AR1\" ) self . eval_noise = model_dict . get ( \"eval_noise\" , False ) self . model = MFK ( theta0 = dim * [ 1.0 ], eval_noise = self . eval_noise , print_global = False ) def train ( self ): self . model . set_training_values ( self . x_lf_DOE , self . y_lf_DOE , name = 0 ) self . model . set_training_values ( self . x_hf_DOE , self . y_hf_DOE ) self . model . train () def evaluate ( self , x : np . ndarray ) -> np . ndarray : y = self . model . predict_values ( x ) return y def evaluate_std ( self , x : np . ndarray ) -> np . ndarray : return np . sqrt ( self . model . predict_variances ( x )) mf_sm.mf_models.MultiObjectiveModel Bases: MfModel Multi-objective surrogate model. Source code in aero_optim/mf_sm/mf_models.py 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 class MultiObjectiveModel ( MfModel ): \"\"\" Multi-objective surrogate model. \"\"\" def __init__ ( self , list_of_models : list [ MfSMT | MfKPLS | SfSMT | MfLGP ]): self . models : list [ MfSMT | MfKPLS | SfSMT | MfLGP ] = list_of_models self . requires_nested_doe = self . models [ 0 ] . requires_nested_doe self . name = self . models [ 0 ] . name def train ( self ): for model in self . models : model . train () def evaluate ( self , x : np . ndarray ) -> list [ np . ndarray ]: return [ model . evaluate ( x ) for model in self . models ] def evaluate_std ( self , x : np . ndarray ) -> list [ np . ndarray ]: return [ model . evaluate_std ( x ) for model in self . models ] def get_DOE ( self ) -> np . ndarray : return self . models [ 0 ] . get_DOE () def set_DOE ( self , x_lf : np . ndarray , x_hf : np . ndarray , y_lf : np . ndarray | list [ np . ndarray ], y_hf : np . ndarray | list [ np . ndarray ] ): for model , yy_lf , yy_hf in zip ( self . models , y_lf , y_hf ): model . set_DOE ( x_lf , x_hf , yy_lf , yy_hf ) def get_y_star ( self ) -> float | np . ndarray : \"\"\" Returns the current best lf fitness (SO) or pareto front (MO). \"\"\" raise Exception ( \"Not implemented\" ) get_y_star () -> float | np . ndarray Returns the current best lf fitness (SO) or pareto front (MO). Source code in aero_optim/mf_sm/mf_models.py 362 363 364 365 366 def get_y_star ( self ) -> float | np . ndarray : \"\"\" Returns the current best lf fitness (SO) or pareto front (MO). \"\"\" raise Exception ( \"Not implemented\" ) Infill problems mf_sm.mf_infill.EDProblem Bases: Problem Euclidean Distance problem. Source code in aero_optim/mf_sm/mf_infill.py 97 98 99 100 101 102 103 104 105 106 class EDProblem ( Problem ): \"\"\" Euclidean Distance problem. \"\"\" def __init__ ( self , DOE : np . ndarray , n_var : int , bound : list ): super () . __init__ ( n_var = n_var , n_obj = 1 , xl = bound [ 0 ], xu = bound [ - 1 ]) self . DOE = DOE def _evaluate ( self , x : np . ndarray , out : np . ndarray , * args , ** kwargs ): out [ \"F\" ] = - ED_acquisition_function ( x , self . DOE ) mf_sm.mf_infill.AcquisitionFunctionProblem Bases: Problem Generic class for Bayesian acquisition function optimization problems. Source code in aero_optim/mf_sm/mf_infill.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 class AcquisitionFunctionProblem ( Problem ): \"\"\" Generic class for Bayesian acquisition function optimization problems. \"\"\" def __init__ ( self , function : Callable , model : MfLGP | MfKPLS | MfSMT | SfSMT | MultiObjectiveModel , n_var : int , bound : list , min : bool = True ): Problem . __init__ ( self , n_var = n_var , n_ieq_constr = 0 , xl = bound [ 0 ], xu = bound [ 1 ] ) self . model = model self . function = function self . min = min def _evaluate ( self , X : np . ndarray , out : np . ndarray , * args , ** kwargs ): out [ \"F\" ] = self . function ( X , self . model ) if self . min else - self . function ( X , self . model ) mf_sm.mf_infill.RegCritProblem Bases: Problem Regularized infill criterion problem: see R. Grapin et al. (2022): https://doi.org/10.2514/6.2022-4053 Source code in aero_optim/mf_sm/mf_infill.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 class RegCritProblem ( Problem ): \"\"\" Regularized infill criterion problem: see R. Grapin et al. (2022): https://doi.org/10.2514/6.2022-4053 \"\"\" def __init__ ( self , function : Callable , model : MultiObjectiveModel , n_var : int , bound : list , gamma : float ): super () . __init__ ( n_var = n_var , n_obj = 1 , xl = bound [ 0 ], xu = bound [ - 1 ]) self . model = model self . gamma = gamma self . function = function def _evaluate ( self , x : np . ndarray , out : np . ndarray ): u1 = self . model . models [ 0 ] . evaluate ( x ) u2 = self . model . models [ 1 ] . evaluate ( x ) out [ \"F\" ] = - ( self . gamma * self . function ( x , self . model ) - np . sum ( np . column_stack ([ u1 , u2 ]), axis = 1 )) Infill acquisition functions mf_sm . mf_infill . ED_acquisition_function ( x : np . ndarray , DOE : np . ndarray ) -> np . ndarray Euclidean Distance: see X. Zhang et al. (2021): https://doi.org/10.1016/j.cma.2020.113485 Source code in aero_optim/mf_sm/mf_infill.py 22 23 24 25 26 27 28 29 30 def ED_acquisition_function ( x : np . ndarray , DOE : np . ndarray ) -> np . ndarray : \"\"\" Euclidean Distance: see X. Zhang et al. (2021): https://doi.org/10.1016/j.cma.2020.113485 \"\"\" f1 = np . min ( cdist ( np . atleast_2d ( x ), DOE , \"euclidean\" ), axis = 1 ) f1 = np . expand_dims ( f1 , axis = 1 ) assert f1 . shape == ( x . shape [ 0 ], 1 ), f \"f1 shape { f1 . shape } x shape { x . shape } \" return f1 mf_sm . mf_infill . LCB_acquisition_function ( x : np . ndarray , model : MfSMT , alpha : float = 1 ) -> np . ndarray Lower Confidence Bound acquisition function. Source code in aero_optim/mf_sm/mf_infill.py 33 34 35 36 37 def LCB_acquisition_function ( x : np . ndarray , model : MfSMT , alpha : float = 1 ) -> np . ndarray : \"\"\" Lower Confidence Bound acquisition function. \"\"\" return model . evaluate ( x ) - alpha * model . evaluate_std ( x ) mf_sm . mf_infill . EI_acquisition_function ( x : np . ndarray , model : MfSMT ) -> np . ndarray Expected Improvement acquisition function. Source code in aero_optim/mf_sm/mf_infill.py 40 41 42 43 44 45 46 47 48 49 def EI_acquisition_function ( x : np . ndarray , model : MfSMT ) -> np . ndarray : \"\"\" Expected Improvement acquisition function. \"\"\" u = model . get_y_star () - model . evaluate ( x ) std = model . evaluate_std ( x ) f1 = u * norm . cdf ( u / ( std + EPSILON )) + std * norm . pdf ( u / ( std + EPSILON )) zero_std_idx = np . argwhere ( std < EPSILON ) f1 [ zero_std_idx ] = 0. return f1 mf_sm . mf_infill . PI_acquisition_function ( x : np . ndarray , model : MultiObjectiveModel ) -> np . ndarray Bi-objective Probability of Improvement: see A. J. Keane (2006): https://doi.org/10.2514/1.16875 Source code in aero_optim/mf_sm/mf_infill.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def PI_acquisition_function ( x : np . ndarray , model : MultiObjectiveModel ) -> np . ndarray : \"\"\" Bi-objective Probability of Improvement: see A. J. Keane (2006): https://doi.org/10.2514/1.16875 \"\"\" assert model . models [ 0 ] . y_hf_DOE is not None assert model . models [ 1 ] . y_hf_DOE is not None pareto = compute_pareto ( model . models [ 0 ] . y_hf_DOE , model . models [ 1 ] . y_hf_DOE ) u1 = model . models [ 0 ] . evaluate ( x ) u2 = model . models [ 1 ] . evaluate ( x ) std1 = model . models [ 0 ] . evaluate_std ( x ) + EPSILON std2 = model . models [ 1 ] . evaluate_std ( x ) + EPSILON PIaug = norm . cdf (( pareto [ 0 , 0 ] - u1 ) / std1 ) for i in range ( len ( pareto ) - 1 ): PIaug += ( ( norm . cdf (( pareto [ i + 1 , 0 ] - u1 ) / std1 ) - norm . cdf (( pareto [ i , 0 ] - u1 ) / std1 )) * norm . cdf (( pareto [ i , 1 ] - u2 ) / std2 ) ) PIaug += ( 1 - norm . cdf (( pareto [ - 1 , 0 ] - u1 ) / std1 )) * norm . cdf (( pareto [ - 1 , 1 ] - u2 ) / std2 ) return PIaug mf_sm . mf_infill . MPI_acquisition_function ( x : np . ndarray , model : MultiObjectiveModel ) -> np . ndarray Bi-objective Minimal Probability of Improvement: see A. A. Rahat (2017): https://dl.acm.org/doi/10.1145/3071178.3071276 Source code in aero_optim/mf_sm/mf_infill.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 def MPI_acquisition_function ( x : np . ndarray , model : MultiObjectiveModel ) -> np . ndarray : \"\"\" Bi-objective Minimal Probability of Improvement: see A. A. Rahat (2017): https://dl.acm.org/doi/10.1145/3071178.3071276 \"\"\" assert model . models [ 0 ] . y_hf_DOE is not None assert model . models [ 1 ] . y_hf_DOE is not None pareto = compute_pareto ( model . models [ 0 ] . y_hf_DOE , model . models [ 1 ] . y_hf_DOE ) u1 = model . models [ 0 ] . evaluate ( x ) u2 = model . models [ 1 ] . evaluate ( x ) std1 = model . models [ 0 ] . evaluate_std ( x ) + EPSILON std2 = model . models [ 1 ] . evaluate_std ( x ) + EPSILON MPI = np . min ( np . column_stack ( [ 1 - norm . cdf (( u1 - pp [ 0 ]) / std1 ) * norm . cdf (( u2 - pp [ 1 ]) / std2 ) for pp in pareto ] ), axis = 1 ) return MPI","title":"Multi-Fidelity Surrogate Module"},{"location":"dev_mfsm/#mf-sm-source-code","text":"","title":"MF-SM Source Code"},{"location":"dev_mfsm/#mfmodel-classes","text":"","title":"MfModel classes"},{"location":"dev_mfsm/#mf_sm.mf_models.MfModel","text":"Bases: ABC Wrapping class around a multifidelity model to define it, train it and evaluate it. Attributes: dim ( int ) \u2013 problem dimension. model_dict ( dict ) \u2013 dictionary containing all necessary model parameters. outdir ( str ) \u2013 path to the model folder. seed ( int ) \u2013 seed to enforce reproducibility. x_lf_DOE ( ndarray ) \u2013 the lf_DOE the model was trained with. x_hf_DOE ( ndarray ) \u2013 the hf_DOE the model was trained with. y_lf_DOE ( ndarray ) \u2013 the lf_DOE the model was trained with. y_hf_DOE ( ndarray ) \u2013 the hf_DOE the model was trained with. Source code in aero_optim/mf_sm/mf_models.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 class MfModel ( ABC ): \"\"\" Wrapping class around a multifidelity model to define it, train it and evaluate it. Attributes: dim (int): problem dimension. model_dict (dict): dictionary containing all necessary model parameters. outdir (str): path to the model folder. seed (int): seed to enforce reproducibility. x_lf_DOE (np.ndarray): the lf_DOE the model was trained with. x_hf_DOE (np.ndarray): the hf_DOE the model was trained with. y_lf_DOE (np.ndarray): the lf_DOE the model was trained with. y_hf_DOE (np.ndarray): the hf_DOE the model was trained with. \"\"\" def __init__ ( self , dim : int , model_dict : dict , outdir : str , seed : int ): self . dim = dim self . model_dict = model_dict self . outdir = outdir self . seed = seed self . requires_nested_doe : bool self . x_lf_DOE : np . ndarray | None = None self . x_hf_DOE : np . ndarray | None = None self . y_lf_DOE : np . ndarray | None = None self . y_hf_DOE : np . ndarray | None = None # seed numpy np . random . seed ( seed ) @abstractmethod def train ( self ): \"\"\" Trains a model with low and high fidelity data. \"\"\" @abstractmethod def evaluate ( self , x : np . ndarray ): \"\"\" Returns a model prediction for a given input x. \"\"\" def evaluate_std ( self , x : np . ndarray ): raise Exception ( \"Not implemented\" ) def get_DOE ( self ) -> np . ndarray : \"\"\" Returns the DOE the model was trained with. \"\"\" assert self . x_lf_DOE is not None and self . x_hf_DOE is not None if self . requires_nested_doe : return np . copy ( self . x_lf_DOE ) else : return np . vstack (( self . x_lf_DOE , self . x_hf_DOE )) def set_DOE ( self , x_lf : np . ndarray , x_hf : np . ndarray , y_lf : np . ndarray , y_hf : np . ndarray ): \"\"\" Sets the hf and lf DOEs the model was trained with. \"\"\" if self . x_lf_DOE is None : self . x_lf_DOE = x_lf self . x_hf_DOE = x_hf self . y_lf_DOE = y_lf self . y_hf_DOE = y_hf else : assert ( self . x_lf_DOE is not None and self . x_hf_DOE is not None and self . y_lf_DOE is not None and self . y_hf_DOE is not None ) self . x_lf_DOE = np . vstack (( self . x_lf_DOE , x_lf )) self . x_hf_DOE = np . vstack (( self . x_hf_DOE , x_hf )) if self . y_lf_DOE . ndim == 2 : self . y_lf_DOE = np . vstack (( self . y_lf_DOE , y_lf )) self . y_hf_DOE = np . vstack (( self . y_hf_DOE , y_hf )) else : self . y_lf_DOE = np . hstack (( self . y_lf_DOE , y_lf )) self . y_hf_DOE = np . hstack (( self . y_hf_DOE , y_hf )) def get_y_star ( self ) -> float | np . ndarray : \"\"\" Returns the current best lf fitness (SOO). \"\"\" # single objective, y_star is simply the min value assert self . y_hf_DOE is not None return min ( self . y_hf_DOE )","title":"MfModel"},{"location":"dev_mfsm/#mf_sm.mf_models.MfModel.evaluate","text":"Returns a model prediction for a given input x. Source code in aero_optim/mf_sm/mf_models.py 55 56 57 58 59 @abstractmethod def evaluate ( self , x : np . ndarray ): \"\"\" Returns a model prediction for a given input x. \"\"\"","title":"evaluate"},{"location":"dev_mfsm/#mf_sm.mf_models.MfModel.get_DOE","text":"Returns the DOE the model was trained with. Source code in aero_optim/mf_sm/mf_models.py 64 65 66 67 68 69 70 71 72 def get_DOE ( self ) -> np . ndarray : \"\"\" Returns the DOE the model was trained with. \"\"\" assert self . x_lf_DOE is not None and self . x_hf_DOE is not None if self . requires_nested_doe : return np . copy ( self . x_lf_DOE ) else : return np . vstack (( self . x_lf_DOE , self . x_hf_DOE ))","title":"get_DOE"},{"location":"dev_mfsm/#mf_sm.mf_models.MfModel.get_y_star","text":"Returns the current best lf fitness (SOO). Source code in aero_optim/mf_sm/mf_models.py 99 100 101 102 103 104 105 def get_y_star ( self ) -> float | np . ndarray : \"\"\" Returns the current best lf fitness (SOO). \"\"\" # single objective, y_star is simply the min value assert self . y_hf_DOE is not None return min ( self . y_hf_DOE )","title":"get_y_star"},{"location":"dev_mfsm/#mf_sm.mf_models.MfModel.set_DOE","text":"Sets the hf and lf DOEs the model was trained with. Source code in aero_optim/mf_sm/mf_models.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def set_DOE ( self , x_lf : np . ndarray , x_hf : np . ndarray , y_lf : np . ndarray , y_hf : np . ndarray ): \"\"\" Sets the hf and lf DOEs the model was trained with. \"\"\" if self . x_lf_DOE is None : self . x_lf_DOE = x_lf self . x_hf_DOE = x_hf self . y_lf_DOE = y_lf self . y_hf_DOE = y_hf else : assert ( self . x_lf_DOE is not None and self . x_hf_DOE is not None and self . y_lf_DOE is not None and self . y_hf_DOE is not None ) self . x_lf_DOE = np . vstack (( self . x_lf_DOE , x_lf )) self . x_hf_DOE = np . vstack (( self . x_hf_DOE , x_hf )) if self . y_lf_DOE . ndim == 2 : self . y_lf_DOE = np . vstack (( self . y_lf_DOE , y_lf )) self . y_hf_DOE = np . vstack (( self . y_hf_DOE , y_hf )) else : self . y_lf_DOE = np . hstack (( self . y_lf_DOE , y_lf )) self . y_hf_DOE = np . hstack (( self . y_hf_DOE , y_hf ))","title":"set_DOE"},{"location":"dev_mfsm/#mf_sm.mf_models.MfModel.train","text":"Trains a model with low and high fidelity data. Source code in aero_optim/mf_sm/mf_models.py 49 50 51 52 53 @abstractmethod def train ( self ): \"\"\" Trains a model with low and high fidelity data. \"\"\"","title":"train"},{"location":"dev_mfsm/#mf_sm.mf_models.MfDNN","text":"Bases: MfModel Wrapping class around a torch multifidelity deep neural network model. Source code in aero_optim/mf_sm/mf_models.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 class MfDNN ( MfModel ): \"\"\" Wrapping class around a torch multifidelity deep neural network model. \"\"\" def __init__ ( self , dim : int , model_dict : dict , outdir : str , seed : int ): super () . __init__ ( dim , model_dict , outdir , seed ) check_dir ( outdir ) self . requires_nested_doe = model_dict . get ( \"nested_doe\" , False ) self . name = model_dict . get ( \"name\" , \"MFDNN\" ) # seed torch torch . manual_seed ( seed ) # select device self . device : torch . device = torch . device ( \"cuda\" if torch . cuda . is_available () else \"cpu\" ) # the first layer of both network is created here self . model_dict [ \"NNL\" ][ \"layer_sizes_NNL\" ] . insert ( 0 , dim ) self . n_obj = self . model_dict [ \"NNL\" ][ \"layer_sizes_NNL\" ][ - 1 ] self . model_dict [ \"NNH\" ][ \"layer_sizes_NNH1\" ] . insert ( 0 , dim + self . n_obj ) self . model_dict [ \"NNH\" ][ \"layer_sizes_NNH2\" ] . insert ( 0 , dim + self . n_obj ) # low fidelity network self . NNL = NNL ( self . model_dict [ \"NNL\" ][ \"layer_sizes_NNL\" ]) # high fidelity network self . NNH = NNH ( self . model_dict [ \"NNH\" ][ \"layer_sizes_NNH1\" ], self . model_dict [ \"NNH\" ][ \"layer_sizes_NNH2\" ] ) # to device self . NNL . to ( self . device ) self . NNH . to ( self . device ) # init weights self . NNL . apply ( weights_init ) self . NNH . apply ( weights_init ) def train ( self ): # pretrain low fidelity model weight_decay_NNL = self . model_dict [ \"NNL\" ][ \"optimizer\" ] . get ( \"weight_decay\" , 0 ) if self . model_dict [ \"pretraining\" ]: loss_target = self . model_dict [ \"NNL\" ] . get ( \"loss_target\" , 1e-3 ) niter = self . model_dict [ \"NNL\" ] . get ( \"niter\" , 10000 ) # define optimizer lr = self . model_dict [ \"NNL\" ][ \"optimizer\" ] . get ( \"lr\" , 1e-3 ) NNL_optimizer = torch . optim . Adam ( self . NNL . parameters (), lr = lr , weight_decay = weight_decay_NNL ) # define scheduler if \"scheduler\" in self . model_dict [ \"NNL\" ]: NNL_scheduler = torch . optim . lr_scheduler . MultiStepLR ( NNL_optimizer , ** self . model_dict [ \"NNL\" ][ \"scheduler\" ] ) else : NNL_scheduler = None # pretrain assert self . x_lf_DOE is not None and self . y_lf_DOE is not None NNL_pretrain ( self . NNL , NNL_optimizer , self . x_lf_DOE , self . y_lf_DOE , loss_target , niter , self . device , scheduler = NNL_scheduler ) # coupled training loss_target = self . model_dict [ \"NNH\" ] . get ( \"loss_target\" , 1e-5 ) niter = self . model_dict [ \"NNH\" ] . get ( \"niter\" , 15000 ) # define optimizer lr = self . model_dict [ \"NNH\" ][ \"optimizer\" ] . get ( \"lr\" , 1e-4 ) weight_decay_NNH1 = ( self . model_dict [ \"NNH\" ][ \"optimizer\" ] . get ( \"weight_decay_NNH1\" , 0 ) ) weight_decay_NNH2 = ( self . model_dict [ \"NNH\" ][ \"optimizer\" ] . get ( \"weight_decay_NNH2\" , 0 ) ) MfDNN_optimizer = torch . optim . Adam ( [{ 'params' : self . NNH . NNH1 . parameters (), 'weight_decay' : weight_decay_NNH1 }, { 'params' : self . NNH . NNH2 . parameters (), 'weight_decay' : weight_decay_NNH2 }, { 'params' : self . NNH . alpha }, { 'params' : self . NNL . parameters (), 'weight_decay' : weight_decay_NNL }], lr = lr ) # define scheduler if \"scheduler\" in self . model_dict [ \"NNH\" ]: MfDNN_scheduler = torch . optim . lr_scheduler . MultiStepLR ( MfDNN_optimizer , ** self . model_dict [ \"NNH\" ][ \"scheduler\" ] ) else : MfDNN_scheduler = None # train assert self . x_lf_DOE is not None and self . y_lf_DOE is not None assert self . x_hf_DOE is not None and self . y_hf_DOE is not None MfDNN_train ( self . NNL , self . NNH , MfDNN_optimizer , self . x_lf_DOE , self . y_lf_DOE , self . x_hf_DOE , self . y_hf_DOE , loss_target , niter , self . device , self . outdir , scheduler = MfDNN_scheduler ) def evaluate ( self , x : np . ndarray ) -> np . ndarray | list [ np . ndarray ]: x_torch = torch . from_numpy ( x ) . float () x_torch = x_torch . to ( self . device ) y_lo_hi = self . NNL . eval ()( x_torch ) y = self . NNH . eval ()( torch . cat (( x_torch , y_lo_hi ), dim = 1 )) y_np = y . cpu () . detach () . numpy () return y_np if self . n_obj == 1 else [ y_np [:, c_ ][:, None ] for c_ in range ( self . n_obj )]","title":"MfDNN"},{"location":"dev_mfsm/#mf_sm.mf_models.MfSMT","text":"Bases: MfModel Wrapping class around an smt multifidelity cokriging model. Source code in aero_optim/mf_sm/mf_models.py 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 class MfSMT ( MfModel ): \"\"\" Wrapping class around an smt multifidelity cokriging model. \"\"\" def __init__ ( self , dim : int , model_dict : dict , outdir : str , seed : int ): super () . __init__ ( dim , model_dict , outdir , seed ) self . requires_nested_doe = model_dict . get ( \"nested_doe\" , True ) self . name = model_dict . get ( \"name\" , \"AR1\" ) self . eval_noise = model_dict . get ( \"eval_noise\" , False ) self . model = MFK ( theta0 = dim * [ 1.0 ], eval_noise = self . eval_noise , print_global = False ) def train ( self ): self . model . set_training_values ( self . x_lf_DOE , self . y_lf_DOE , name = 0 ) self . model . set_training_values ( self . x_hf_DOE , self . y_hf_DOE ) self . model . train () def evaluate ( self , x : np . ndarray ) -> np . ndarray : y = self . model . predict_values ( x ) return y def evaluate_std ( self , x : np . ndarray ) -> np . ndarray : return np . sqrt ( self . model . predict_variances ( x ))","title":"MfSMT"},{"location":"dev_mfsm/#mf_sm.mf_models.MultiObjectiveModel","text":"Bases: MfModel Multi-objective surrogate model. Source code in aero_optim/mf_sm/mf_models.py 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 class MultiObjectiveModel ( MfModel ): \"\"\" Multi-objective surrogate model. \"\"\" def __init__ ( self , list_of_models : list [ MfSMT | MfKPLS | SfSMT | MfLGP ]): self . models : list [ MfSMT | MfKPLS | SfSMT | MfLGP ] = list_of_models self . requires_nested_doe = self . models [ 0 ] . requires_nested_doe self . name = self . models [ 0 ] . name def train ( self ): for model in self . models : model . train () def evaluate ( self , x : np . ndarray ) -> list [ np . ndarray ]: return [ model . evaluate ( x ) for model in self . models ] def evaluate_std ( self , x : np . ndarray ) -> list [ np . ndarray ]: return [ model . evaluate_std ( x ) for model in self . models ] def get_DOE ( self ) -> np . ndarray : return self . models [ 0 ] . get_DOE () def set_DOE ( self , x_lf : np . ndarray , x_hf : np . ndarray , y_lf : np . ndarray | list [ np . ndarray ], y_hf : np . ndarray | list [ np . ndarray ] ): for model , yy_lf , yy_hf in zip ( self . models , y_lf , y_hf ): model . set_DOE ( x_lf , x_hf , yy_lf , yy_hf ) def get_y_star ( self ) -> float | np . ndarray : \"\"\" Returns the current best lf fitness (SO) or pareto front (MO). \"\"\" raise Exception ( \"Not implemented\" )","title":"MultiObjectiveModel"},{"location":"dev_mfsm/#mf_sm.mf_models.MultiObjectiveModel.get_y_star","text":"Returns the current best lf fitness (SO) or pareto front (MO). Source code in aero_optim/mf_sm/mf_models.py 362 363 364 365 366 def get_y_star ( self ) -> float | np . ndarray : \"\"\" Returns the current best lf fitness (SO) or pareto front (MO). \"\"\" raise Exception ( \"Not implemented\" )","title":"get_y_star"},{"location":"dev_mfsm/#infill-problems","text":"","title":"Infill problems"},{"location":"dev_mfsm/#mf_sm.mf_infill.EDProblem","text":"Bases: Problem Euclidean Distance problem. Source code in aero_optim/mf_sm/mf_infill.py 97 98 99 100 101 102 103 104 105 106 class EDProblem ( Problem ): \"\"\" Euclidean Distance problem. \"\"\" def __init__ ( self , DOE : np . ndarray , n_var : int , bound : list ): super () . __init__ ( n_var = n_var , n_obj = 1 , xl = bound [ 0 ], xu = bound [ - 1 ]) self . DOE = DOE def _evaluate ( self , x : np . ndarray , out : np . ndarray , * args , ** kwargs ): out [ \"F\" ] = - ED_acquisition_function ( x , self . DOE )","title":"EDProblem"},{"location":"dev_mfsm/#mf_sm.mf_infill.AcquisitionFunctionProblem","text":"Bases: Problem Generic class for Bayesian acquisition function optimization problems. Source code in aero_optim/mf_sm/mf_infill.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 class AcquisitionFunctionProblem ( Problem ): \"\"\" Generic class for Bayesian acquisition function optimization problems. \"\"\" def __init__ ( self , function : Callable , model : MfLGP | MfKPLS | MfSMT | SfSMT | MultiObjectiveModel , n_var : int , bound : list , min : bool = True ): Problem . __init__ ( self , n_var = n_var , n_ieq_constr = 0 , xl = bound [ 0 ], xu = bound [ 1 ] ) self . model = model self . function = function self . min = min def _evaluate ( self , X : np . ndarray , out : np . ndarray , * args , ** kwargs ): out [ \"F\" ] = self . function ( X , self . model ) if self . min else - self . function ( X , self . model )","title":"AcquisitionFunctionProblem"},{"location":"dev_mfsm/#mf_sm.mf_infill.RegCritProblem","text":"Bases: Problem Regularized infill criterion problem: see R. Grapin et al. (2022): https://doi.org/10.2514/6.2022-4053 Source code in aero_optim/mf_sm/mf_infill.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 class RegCritProblem ( Problem ): \"\"\" Regularized infill criterion problem: see R. Grapin et al. (2022): https://doi.org/10.2514/6.2022-4053 \"\"\" def __init__ ( self , function : Callable , model : MultiObjectiveModel , n_var : int , bound : list , gamma : float ): super () . __init__ ( n_var = n_var , n_obj = 1 , xl = bound [ 0 ], xu = bound [ - 1 ]) self . model = model self . gamma = gamma self . function = function def _evaluate ( self , x : np . ndarray , out : np . ndarray ): u1 = self . model . models [ 0 ] . evaluate ( x ) u2 = self . model . models [ 1 ] . evaluate ( x ) out [ \"F\" ] = - ( self . gamma * self . function ( x , self . model ) - np . sum ( np . column_stack ([ u1 , u2 ]), axis = 1 ))","title":"RegCritProblem"},{"location":"dev_mfsm/#infill-acquisition-functions","text":"","title":"Infill acquisition functions"},{"location":"dev_mfsm/#mf_sm.mf_infill.ED_acquisition_function","text":"Euclidean Distance: see X. Zhang et al. (2021): https://doi.org/10.1016/j.cma.2020.113485 Source code in aero_optim/mf_sm/mf_infill.py 22 23 24 25 26 27 28 29 30 def ED_acquisition_function ( x : np . ndarray , DOE : np . ndarray ) -> np . ndarray : \"\"\" Euclidean Distance: see X. Zhang et al. (2021): https://doi.org/10.1016/j.cma.2020.113485 \"\"\" f1 = np . min ( cdist ( np . atleast_2d ( x ), DOE , \"euclidean\" ), axis = 1 ) f1 = np . expand_dims ( f1 , axis = 1 ) assert f1 . shape == ( x . shape [ 0 ], 1 ), f \"f1 shape { f1 . shape } x shape { x . shape } \" return f1","title":"ED_acquisition_function"},{"location":"dev_mfsm/#mf_sm.mf_infill.LCB_acquisition_function","text":"Lower Confidence Bound acquisition function. Source code in aero_optim/mf_sm/mf_infill.py 33 34 35 36 37 def LCB_acquisition_function ( x : np . ndarray , model : MfSMT , alpha : float = 1 ) -> np . ndarray : \"\"\" Lower Confidence Bound acquisition function. \"\"\" return model . evaluate ( x ) - alpha * model . evaluate_std ( x )","title":"LCB_acquisition_function"},{"location":"dev_mfsm/#mf_sm.mf_infill.EI_acquisition_function","text":"Expected Improvement acquisition function. Source code in aero_optim/mf_sm/mf_infill.py 40 41 42 43 44 45 46 47 48 49 def EI_acquisition_function ( x : np . ndarray , model : MfSMT ) -> np . ndarray : \"\"\" Expected Improvement acquisition function. \"\"\" u = model . get_y_star () - model . evaluate ( x ) std = model . evaluate_std ( x ) f1 = u * norm . cdf ( u / ( std + EPSILON )) + std * norm . pdf ( u / ( std + EPSILON )) zero_std_idx = np . argwhere ( std < EPSILON ) f1 [ zero_std_idx ] = 0. return f1","title":"EI_acquisition_function"},{"location":"dev_mfsm/#mf_sm.mf_infill.PI_acquisition_function","text":"Bi-objective Probability of Improvement: see A. J. Keane (2006): https://doi.org/10.2514/1.16875 Source code in aero_optim/mf_sm/mf_infill.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def PI_acquisition_function ( x : np . ndarray , model : MultiObjectiveModel ) -> np . ndarray : \"\"\" Bi-objective Probability of Improvement: see A. J. Keane (2006): https://doi.org/10.2514/1.16875 \"\"\" assert model . models [ 0 ] . y_hf_DOE is not None assert model . models [ 1 ] . y_hf_DOE is not None pareto = compute_pareto ( model . models [ 0 ] . y_hf_DOE , model . models [ 1 ] . y_hf_DOE ) u1 = model . models [ 0 ] . evaluate ( x ) u2 = model . models [ 1 ] . evaluate ( x ) std1 = model . models [ 0 ] . evaluate_std ( x ) + EPSILON std2 = model . models [ 1 ] . evaluate_std ( x ) + EPSILON PIaug = norm . cdf (( pareto [ 0 , 0 ] - u1 ) / std1 ) for i in range ( len ( pareto ) - 1 ): PIaug += ( ( norm . cdf (( pareto [ i + 1 , 0 ] - u1 ) / std1 ) - norm . cdf (( pareto [ i , 0 ] - u1 ) / std1 )) * norm . cdf (( pareto [ i , 1 ] - u2 ) / std2 ) ) PIaug += ( 1 - norm . cdf (( pareto [ - 1 , 0 ] - u1 ) / std1 )) * norm . cdf (( pareto [ - 1 , 1 ] - u2 ) / std2 ) return PIaug","title":"PI_acquisition_function"},{"location":"dev_mfsm/#mf_sm.mf_infill.MPI_acquisition_function","text":"Bi-objective Minimal Probability of Improvement: see A. A. Rahat (2017): https://dl.acm.org/doi/10.1145/3071178.3071276 Source code in aero_optim/mf_sm/mf_infill.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 def MPI_acquisition_function ( x : np . ndarray , model : MultiObjectiveModel ) -> np . ndarray : \"\"\" Bi-objective Minimal Probability of Improvement: see A. A. Rahat (2017): https://dl.acm.org/doi/10.1145/3071178.3071276 \"\"\" assert model . models [ 0 ] . y_hf_DOE is not None assert model . models [ 1 ] . y_hf_DOE is not None pareto = compute_pareto ( model . models [ 0 ] . y_hf_DOE , model . models [ 1 ] . y_hf_DOE ) u1 = model . models [ 0 ] . evaluate ( x ) u2 = model . models [ 1 ] . evaluate ( x ) std1 = model . models [ 0 ] . evaluate_std ( x ) + EPSILON std2 = model . models [ 1 ] . evaluate_std ( x ) + EPSILON MPI = np . min ( np . column_stack ( [ 1 - norm . cdf (( u1 - pp [ 0 ]) / std1 ) * norm . cdf (( u2 - pp [ 1 ]) / std2 ) for pp in pareto ] ), axis = 1 ) return MPI","title":"MPI_acquisition_function"},{"location":"dev_optimizer/","text":"Evolution and Optimizer Source Code Evolution classes optim.evolution.Evolution Bases: ABC This class implements an abstract evolution object. Source code in aero_optim/optim/evolution.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 class Evolution ( ABC ): \"\"\" This class implements an abstract evolution object. \"\"\" def __init__ ( self , config : dict , debug : bool ): self . custom_file : str = config [ \"study\" ] . get ( \"custom_file\" , \"\" ) self . set_optimizer ( debug = debug ) self . optimizer : Type [ Optimizer ] = self . OptimizerClass ( config ) self . set_ea () @abstractmethod def set_optimizer ( self , * args , ** kwargs ): \"\"\" Sets the optimizer object. \"\"\" self . OptimizerClass = ( get_custom_class ( self . custom_file , \"CustomOptimizer\" ) if self . custom_file else None ) @abstractmethod def set_ea ( self , * args , ** kwargs ): \"\"\" Sets the evolutionary computation algorithm. \"\"\" @abstractmethod def evolve ( self , * args , ** kwargs ): \"\"\" Defines how to execute the optimization. \"\"\" evolve ( * args , ** kwargs ) abstractmethod Defines how to execute the optimization. Source code in aero_optim/optim/evolution.py 49 50 51 52 53 @abstractmethod def evolve ( self , * args , ** kwargs ): \"\"\" Defines how to execute the optimization. \"\"\" set_ea ( * args , ** kwargs ) abstractmethod Sets the evolutionary computation algorithm. Source code in aero_optim/optim/evolution.py 43 44 45 46 47 @abstractmethod def set_ea ( self , * args , ** kwargs ): \"\"\" Sets the evolutionary computation algorithm. \"\"\" set_optimizer ( * args , ** kwargs ) abstractmethod Sets the optimizer object. Source code in aero_optim/optim/evolution.py 34 35 36 37 38 39 40 41 @abstractmethod def set_optimizer ( self , * args , ** kwargs ): \"\"\" Sets the optimizer object. \"\"\" self . OptimizerClass = ( get_custom_class ( self . custom_file , \"CustomOptimizer\" ) if self . custom_file else None ) inspyred Evolution optim.evolution.InspyredEvolution Bases: Evolution This class implements a default inspyred based evolution object. Source code in aero_optim/optim/evolution.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 class InspyredEvolution ( Evolution ): \"\"\" This class implements a default inspyred based evolution object. \"\"\" def __init__ ( self , config : dict , debug : bool = False ): super () . __init__ ( config , debug ) self . algorithm . observer = self . optimizer . _observe self . algorithm . terminator = terminators . generation_termination def set_optimizer ( self , debug : bool = False ): \"\"\" **Instantiates** the optimizer attribute as custom if any or from default classes. \"\"\" super () . set_optimizer () if not self . OptimizerClass : if debug : self . OptimizerClass = InspyredDebugOptimizer else : self . OptimizerClass = InspyredWolfOptimizer logger . info ( f \"optimizer set to { self . OptimizerClass } \" ) def set_ea ( self ): \"\"\" **Instantiates** the default algorithm attribute. \"\"\" self . algorithm = inspyred_select_strategy ( self . optimizer . strategy , self . optimizer . prng ) def evolve ( self ): \"\"\" **Executes** the default evolution method. \"\"\" final_pop = self . algorithm . evolve ( generator = self . optimizer . generator . _ins_generator , evaluator = self . optimizer . _evaluate , pop_size = self . optimizer . doe_size , max_generations = self . optimizer . max_generations , bounder = Bounder ( * self . optimizer . bound ), maximize = self . optimizer . maximize , ** self . optimizer . ea_kwargs ) self . optimizer . final_observe () # output results best = max ( final_pop ) index , opt_J = ( max ( enumerate ( self . optimizer . J ), key = ope . itemgetter ( 1 )) if self . optimizer . maximize else min ( enumerate ( self . optimizer . J ), key = ope . itemgetter ( 1 )) ) gid , cid = ( index // self . optimizer . doe_size , index % self . optimizer . doe_size ) logger . info ( f \"optimal J: { opt_J } (J_ins: { best . fitness } ), \\n \" f \"D: { ' ' . join ([ str ( d ) for d in self . optimizer . inputs [ gid ][ cid ]]) } \\n \" f \"D_ins: { ' ' . join ([ str ( d ) for d in best . candidate [: self . optimizer . n_design ]]) } \" f \" \\n [g { gid } , c { cid } ]\" ) evolve () Executes the default evolution method. Source code in aero_optim/optim/evolution.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def evolve ( self ): \"\"\" **Executes** the default evolution method. \"\"\" final_pop = self . algorithm . evolve ( generator = self . optimizer . generator . _ins_generator , evaluator = self . optimizer . _evaluate , pop_size = self . optimizer . doe_size , max_generations = self . optimizer . max_generations , bounder = Bounder ( * self . optimizer . bound ), maximize = self . optimizer . maximize , ** self . optimizer . ea_kwargs ) self . optimizer . final_observe () # output results best = max ( final_pop ) index , opt_J = ( max ( enumerate ( self . optimizer . J ), key = ope . itemgetter ( 1 )) if self . optimizer . maximize else min ( enumerate ( self . optimizer . J ), key = ope . itemgetter ( 1 )) ) gid , cid = ( index // self . optimizer . doe_size , index % self . optimizer . doe_size ) logger . info ( f \"optimal J: { opt_J } (J_ins: { best . fitness } ), \\n \" f \"D: { ' ' . join ([ str ( d ) for d in self . optimizer . inputs [ gid ][ cid ]]) } \\n \" f \"D_ins: { ' ' . join ([ str ( d ) for d in best . candidate [: self . optimizer . n_design ]]) } \" f \" \\n [g { gid } , c { cid } ]\" ) set_ea () Instantiates the default algorithm attribute. Source code in aero_optim/optim/evolution.py 129 130 131 132 133 def set_ea ( self ): \"\"\" **Instantiates** the default algorithm attribute. \"\"\" self . algorithm = inspyred_select_strategy ( self . optimizer . strategy , self . optimizer . prng ) set_optimizer ( debug : bool = False ) Instantiates the optimizer attribute as custom if any or from default classes. Source code in aero_optim/optim/evolution.py 117 118 119 120 121 122 123 124 125 126 127 def set_optimizer ( self , debug : bool = False ): \"\"\" **Instantiates** the optimizer attribute as custom if any or from default classes. \"\"\" super () . set_optimizer () if not self . OptimizerClass : if debug : self . OptimizerClass = InspyredDebugOptimizer else : self . OptimizerClass = InspyredWolfOptimizer logger . info ( f \"optimizer set to { self . OptimizerClass } \" ) pymoo Evolution optim.evolution.PymooEvolution Bases: Evolution This class implements a default pymoo based evolution object. Source code in aero_optim/optim/evolution.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 class PymooEvolution ( Evolution ): \"\"\" This class implements a default pymoo based evolution object. \"\"\" def __init__ ( self , config : dict , debug : bool = False ): super () . __init__ ( config , debug ) def set_optimizer ( self , debug : bool = False ): \"\"\" **Instantiates** the optimizer attribute as custom if any or from default classes. \"\"\" super () . set_optimizer () if not self . OptimizerClass : if debug : self . OptimizerClass = PymooDebugOptimizer else : self . OptimizerClass = PymooWolfOptimizer logger . info ( f \"optimizer set to { self . OptimizerClass } \" ) def set_ea ( self ): \"\"\" **Instantiates** the default algorithm attribute. \"\"\" self . algorithm = pymoo_select_strategy ( self . optimizer . strategy , self . optimizer . doe_size , self . optimizer . generator . _pymoo_generator (), self . optimizer . ea_kwargs ) def evolve ( self ): \"\"\" **Executes** the default evolution method. \"\"\" res = minimize ( problem = self . optimizer , algorithm = self . algorithm , termination = get_termination ( \"n_gen\" , self . optimizer . max_generations ), seed = self . optimizer . seed , verbose = True ) self . optimizer . final_observe () # output results best = res . F index , opt_J = min ( enumerate ( self . optimizer . J ), key = lambda x : abs ( best - x [ 1 ])) gid , cid = ( index // self . optimizer . doe_size , index % self . optimizer . doe_size ) logger . info ( f \"optimal J: { opt_J } (J_pymoo: { best } ), \\n \" f \"D: { ' ' . join ([ str ( d ) for d in self . optimizer . inputs [ gid ][ cid ]]) } \\n \" f \"D_pymoo: { ' ' . join ([ str ( d ) for d in res . X ]) } \\n \" f \"[g { gid } , c { cid } ]\" ) evolve () Executes the default evolution method. Source code in aero_optim/optim/evolution.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def evolve ( self ): \"\"\" **Executes** the default evolution method. \"\"\" res = minimize ( problem = self . optimizer , algorithm = self . algorithm , termination = get_termination ( \"n_gen\" , self . optimizer . max_generations ), seed = self . optimizer . seed , verbose = True ) self . optimizer . final_observe () # output results best = res . F index , opt_J = min ( enumerate ( self . optimizer . J ), key = lambda x : abs ( best - x [ 1 ])) gid , cid = ( index // self . optimizer . doe_size , index % self . optimizer . doe_size ) logger . info ( f \"optimal J: { opt_J } (J_pymoo: { best } ), \\n \" f \"D: { ' ' . join ([ str ( d ) for d in self . optimizer . inputs [ gid ][ cid ]]) } \\n \" f \"D_pymoo: { ' ' . join ([ str ( d ) for d in res . X ]) } \\n \" f \"[g { gid } , c { cid } ]\" ) set_ea () Instantiates the default algorithm attribute. Source code in aero_optim/optim/evolution.py 75 76 77 78 79 80 81 82 83 84 def set_ea ( self ): \"\"\" **Instantiates** the default algorithm attribute. \"\"\" self . algorithm = pymoo_select_strategy ( self . optimizer . strategy , self . optimizer . doe_size , self . optimizer . generator . _pymoo_generator (), self . optimizer . ea_kwargs ) set_optimizer ( debug : bool = False ) Instantiates the optimizer attribute as custom if any or from default classes. Source code in aero_optim/optim/evolution.py 63 64 65 66 67 68 69 70 71 72 73 def set_optimizer ( self , debug : bool = False ): \"\"\" **Instantiates** the optimizer attribute as custom if any or from default classes. \"\"\" super () . set_optimizer () if not self . OptimizerClass : if debug : self . OptimizerClass = PymooDebugOptimizer else : self . OptimizerClass = PymooWolfOptimizer logger . info ( f \"optimizer set to { self . OptimizerClass } \" ) Optimizer classes optim.optimizer.Optimizer Bases: ABC This class implements an abstract optimizer. Source code in aero_optim/optim/optimizer.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 class Optimizer ( ABC ): \"\"\" This class implements an abstract optimizer. \"\"\" def __init__ ( self , config : dict , debug : bool = False ): \"\"\" Instantiates the Optimizer object. **Input** - config (dict): the config file dictionary. - debug (bool): skip FFD and Mesh objects instantation for debugging purposes. **Inner** - n_design (int): the number of design variables (dimensions of the problem). - doe_size (int): the size of the initial and subsequent generations. - max_generations (int): the number of generations before termination. - dat_file (str): path to input_geometry.dat (baseline geometry). - outdir (str): highest level optimization output directory. Note: the result folder tree is structured as follows: ``` outdir |__ FFD (contains <geom>_gXX_cYY.dat) |__ Figs (contains the figures generated during the optimization) |__ MESH (contains <geom>_gXX_cYY.mesh, .log, .geo_unrolled) |__ SOLVER |__ solver_gXX_cYY (contains the results of each simulation) ``` - study_type (str): use-case/meshing routine. - ffd_type (str): deformation method. - strategy (str): the optimization algorithm amongst inspyred's [ES, PSO] and pymoo's [GA, PSO]</br> see https://pythonhosted.org/inspyred/examples.html#standard-algorithms</br> and https://pymoo.org/algorithms/list.html#nb-algorithms-list - maximize (bool): whether to maximize or minimize the objective QoIs. - budget (int): maximum number of concurrent proc in use. - nproc_per_sim (int): number of proc per simulation. - bound (tuple[float]): design variables boundaries. - custom_doe (str): path to a custom doe. - sampler_name (str): name of the sampling algorithm used to generate samples. the initial generation. - seed (int): seed number of the random processes involved in the optimization. - prng (random.Random): pseudo-random generator passed to inspyred generator. - ea_kwargs (dict): additional arguments to be passed to the evolution algorithm. - gen_ctr (int): generation counter. - generator (Generator): Generator object for the initial generation sampling. - ffd (FFD_2D): FFD_2D object to generate deformed geometries. - gmsh_mesh (Mesh): Mesh class to generate deformed geometries meshes. - simulator (Simulator): Simulator object to perform simulations. - mean (list[float]): list of populations mean fitness. - median (list[float]): list of populations median fitness. - max (list[float]): list of populations max fitness. - min (list[float]): list of populations min fitness. - J (list[float | list[float]]): the list of all generated candidates fitnesses. - inputs (list[list[np.ndarray]]): all input candidates. - ffd_profiles (list[list[np.ndarray]]): all deformed geometries {gid: {cid: ffd_profile}}. - QoI (str): the quantity of intereset to minimize/maximize. - n_plt (int): the number of best candidates results to display after each evaluation. - cmap (str): the colormaps used for the observer plot</br> see https://matplotlib.org/stable/users/explain/colors/colormaps.html. \"\"\" self . config = config self . process_config () # required entries self . n_design : int = config [ \"optim\" ][ \"n_design\" ] self . doe_size : int = config [ \"optim\" ][ \"doe_size\" ] self . max_generations : int = config [ \"optim\" ][ \"max_generations\" ] self . dat_file : str = config [ \"study\" ][ \"file\" ] self . outdir : str = config [ \"study\" ][ \"outdir\" ] self . study_type : str = config [ \"study\" ][ \"study_type\" ] # optional entries self . ffd_type : str = config [ \"study\" ] . get ( \"ffd_type\" , \"\" ) self . custom_file : str = config [ \"study\" ] . get ( \"custom_file\" , \"\" ) self . strategy : str = config [ \"optim\" ] . get ( \"strategy\" , \"PSO\" ) self . maximize : bool = config [ \"optim\" ] . get ( \"maximize\" , False ) self . budget : int = config [ \"optim\" ] . get ( \"budget\" , 4 ) self . nproc_per_sim : int = config [ \"optim\" ] . get ( \"nproc_per_sim\" , 1 ) self . bound : tuple [ Any , ... ] = tuple ( config [ \"optim\" ] . get ( \"bound\" , [ - 1 , 1 ])) self . custom_doe : str = config [ \"optim\" ] . get ( \"custom_doe\" , \"\" ) self . sampler_name : str = config [ \"optim\" ] . get ( \"sampler_name\" , \"lhs\" ) self . ea_kwargs : dict = config [ \"optim\" ] . get ( \"ea_kwargs\" , {}) # reproducibility variables self . seed : int = config [ \"optim\" ] . get ( \"seed\" , 123 ) self . prng : Random = Random () self . prng . seed ( self . seed ) # generation counter self . gen_ctr : int = 0 # optimization objects if not debug : self . set_ffd_class () self . set_gmsh_mesh_class () self . generator : Generator = Generator ( self . seed , self . n_design , self . doe_size , self . sampler_name , self . bound , self . custom_doe ) self . set_simulator_class () self . simulator = self . SimulatorClass ( self . config ) # population statistics self . mean : list [ float ] = [] self . median : list [ float ] = [] self . max : list [ float ] = [] self . min : list [ float ] = [] # set other inner optimization variables self . J : list [ float | list [ float ]] = [] self . inputs : list [ list [ np . ndarray ]] = [] self . ffd_profiles : list [ list [ np . ndarray ]] = [] self . QoI : str = self . config [ \"optim\" ] . get ( \"QoI\" , \"CD\" ) self . n_plt : int = self . config [ \"optim\" ] . get ( \"n_plt\" , 5 ) self . cmap : str = self . config [ \"optim\" ] . get ( \"cmap\" , \"viridis\" ) self . set_inner () # figure directory self . figdir : str = os . path . join ( self . outdir , \"Figs\" ) check_dir ( self . figdir ) def process_config ( self ): \"\"\" **Makes sure** the config file contains the required information. \"\"\" logger . info ( \"processing config..\" ) if \"n_design\" not in self . config [ \"optim\" ]: raise Exception ( f \"ERROR -- no <n_design> entry in { self . config [ 'optim' ] } \" ) if \"doe_size\" not in self . config [ \"optim\" ]: raise Exception ( f \"ERROR -- no <doe_size> entry in { self . config [ 'optim' ] } \" ) if \"max_generations\" not in self . config [ \"optim\" ]: raise Exception ( f \"ERROR -- no <max_generations> entry in { self . config [ 'optim' ] } \" ) if \"file\" not in self . config [ \"study\" ]: raise Exception ( f \"ERROR -- no <file> entry in { self . config [ 'study' ] } \" ) if \"budget\" not in self . config [ \"optim\" ]: logger . warning ( f \"no <budget> entry in { self . config [ 'optim' ] } \" ) if \"nproc_per_sim\" not in self . config [ \"optim\" ]: logger . warning ( f \"no <nproc_per_sim> entry in { self . config [ 'optim' ] } \" ) if \"bound\" not in self . config [ \"optim\" ]: logger . warning ( f \"no <bound> entry in { self . config [ 'optim' ] } \" ) if \"sampler_name\" not in self . config [ \"optim\" ]: logger . warning ( f \"no <sampler_name> entry in { self . config [ 'optim' ] } \" ) if \"seed\" not in self . config [ \"optim\" ]: logger . warning ( f \"no <seed> entry in { self . config [ 'optim' ] } \" ) # alter config for optimization purposes if \"outfile\" in self . config [ \"study\" ]: logger . warning ( f \"<outfile> entry in { self . config [ 'study' ] } will be ignored\" ) del self . config [ \"study\" ][ \"outfile\" ] if \"view\" in self . config [ \"gmsh\" ] and \"GUI\" in self . config [ \"gmsh\" ][ \"view\" ]: logger . warning ( f \"<GUI> entry in { self . config [ 'gmsh' ][ 'view' ] } forced to False\" ) self . config [ \"gmsh\" ][ \"view\" ][ \"GUI\" ] = False def set_ffd_class ( self ): \"\"\" **Instantiates** the deformation class and object as custom if found, as one of the default classes otherwise. \"\"\" self . FFDClass = ( get_custom_class ( self . custom_file , \"CustomFFD\" ) if self . custom_file else None ) ffd_config = self . config . get ( \"ffd\" , {}) rotation = ffd_config . get ( \"rotation\" , False ) if not self . FFDClass : # standard FFD 2D if self . ffd_type == FFD_TYPE [ 0 ]: self . FFDClass = FFD_2D self . ffd = self . FFDClass ( self . dat_file , self . n_design // 2 , ** ffd_config ) # POD coupled FFD 2D elif self . ffd_type == FFD_TYPE [ 1 ]: self . FFDClass = FFD_POD_2D ffd_config [ \"ffd_ncontrol\" ] = self . n_design ffd_config [ \"ffd_bound\" ] = self . bound logger . info ( f \"ffd bound: { self . bound } \" ) self . ffd = self . FFDClass ( self . dat_file , ** ffd_config ) self . n_design = ffd_config [ \"pod_ncontrol\" ] self . bound = ffd_config . get ( \"pod_bound\" , self . ffd . get_bound ()) logger . info ( f \"pod bound: { self . bound } \" ) else : raise Exception ( f \"ERROR -- incorrect ffd_type < { self . ffd_type } >\" ) else : self . ffd = self . FFDClass ( self . dat_file , self . n_design , ** ffd_config ) # rotation wrapper if rotation : logger . info ( f \"rotation: { rotation } \" ) self . ffd = RotationWrapper ( self . ffd ) rot_bound = ffd_config . get ( \"rot_bound\" , [ - 1 , 1 ]) # convert bound from tuple of floats to tuple of lists if not isinstance ( self . bound [ 0 ], list ): self . bound = ([ self . bound [ 0 ]] * self . n_design , [ self . bound [ - 1 ]] * self . n_design ) self . bound = ( self . bound [ 0 ] + [ rot_bound [ 0 ]], self . bound [ - 1 ] + [ rot_bound [ - 1 ]]) self . n_design += 1 logger . info ( f \"effective n_design: { self . n_design } \" ) def set_gmsh_mesh_class ( self ): \"\"\" **Instantiates** the mesher class as custom if found, as one of the default meshers otherwise. \"\"\" self . MeshClass = ( get_custom_class ( self . custom_file , \"CustomMesh\" ) if self . custom_file else None ) if not self . MeshClass : if self . study_type == STUDY_TYPE [ 0 ]: self . MeshClass = NACABaseMesh elif self . study_type == STUDY_TYPE [ 1 ]: self . MeshClass = NACABlockMesh elif self . study_type == STUDY_TYPE [ 2 ]: self . MeshClass = CascadeMesh elif self . study_type == STUDY_TYPE [ 3 ]: self . MeshClass = MeshMusicaa else : raise Exception ( f \"ERROR -- incorrect study_type < { self . study_type } >\" ) def set_inner ( self ): \"\"\" **Sets** some use-case specific inner variables: \"\"\" logger . info ( \"set_inner not implemented\" ) def deform ( self , Delta : np . ndarray , gid : int , cid : int ) -> tuple [ str , np . ndarray ]: \"\"\" **Applies** FFD on a given candidate and returns its resulting file. \"\"\" ffd_dir = os . path . join ( self . outdir , \"FFD\" ) check_dir ( ffd_dir ) logger . info ( f \"g { gid } , c { cid } generate profile with deformation { Delta } \" ) profile : np . ndarray = self . ffd . apply_ffd ( Delta ) return self . ffd . write_ffd ( profile , Delta , ffd_dir , gid = gid , cid = cid ), profile def mesh ( self , ffdfile : str ) -> str : \"\"\" **Builds** mesh for a given candidate and returns its resulting file. Note: if a mesh file matching the pattern name already exists, it is not rebuilt. \"\"\" mesh_dir = os . path . join ( self . outdir , \"MESH\" ) check_dir ( mesh_dir ) gmsh_mesh = self . MeshClass ( self . config , ffdfile ) if os . path . isfile ( gmsh_mesh . get_meshfile ( mesh_dir )): return gmsh_mesh . get_meshfile ( mesh_dir ) gmsh_mesh . build_mesh () return gmsh_mesh . write_mesh ( mesh_dir ) def execute_candidates ( self , candidates : list [ Individual ] | np . ndarray , gid : int ): \"\"\" **Executes** all candidates and **waits** for them to finish. Note: this method is meant to be called in _evaluate. \"\"\" logger . info ( f \"evaluating candidates of generation { self . gen_ctr } ..\" ) self . ffd_profiles . append ([]) self . inputs . append ([]) for cid , cand in enumerate ( candidates ): self . inputs [ gid ] . append ( np . array ( cand )) ffd_file , ffd_profile = self . deform ( cand , gid , cid ) self . ffd_profiles [ gid ] . append ( ffd_profile ) # meshing with proper sigint management # see https://gitlab.onelab.info/gmsh/gmsh/-/issues/842 ORIGINAL_SIGINT_HANDLER = signal . signal ( signal . SIGINT , signal . SIG_DFL ) mesh_file = self . mesh ( ffd_file ) signal . signal ( signal . SIGINT , ORIGINAL_SIGINT_HANDLER ) while self . simulator . monitor_sim_progress () * self . nproc_per_sim >= self . budget : time . sleep ( 1 ) self . simulator . execute_sim ( meshfile = mesh_file , gid = gid , cid = cid ) # wait for last candidates to finish while self . simulator . monitor_sim_progress () > 0 : time . sleep ( 0.1 ) def compute_statistics ( self , gen_fitness : np . ndarray ): \"\"\" **Computes** generation statistics. Note: this method is meant to be called in `_observe`. \"\"\" self . mean . append ( np . mean ( gen_fitness )) self . median . append ( np . median ( gen_fitness )) self . min . append ( min ( gen_fitness )) self . max . append ( max ( gen_fitness )) def _observe ( self , * args , ** kwargs ): \"\"\" **Plots** generation data after each evaluation. \"\"\" logger . info ( \"_observe not implemented\" ) def plot_generation ( self , gid : int , sorted_idx : np . ndarray , gen_fitness : np . ndarray , fig_name : str ): \"\"\" **Plots** the results of the last evaluated generation. **Saves** the graph in the output directory. Note: this method is meant to be called in `_observe`. \"\"\" logger . info ( \"plot_generation not implemented\" ) def plot_progress ( self , gen_nbr : int , fig_name : str , baseline_value : float | None = None ): \"\"\" **Plots** and **saves** the overall progress of the optimization. Note: this method is meant to be called in `final_observe`. \"\"\" logger . info ( f \"plotting populations statistics after { gen_nbr } generations..\" ) # plot construction _ , ax = plt . subplots ( figsize = ( 8 , 8 )) psize = self . doe_size if baseline_value : ax . axhline ( y = baseline_value , color = 'k' , ls = \"--\" , label = \"baseline\" ) # plotting data best = self . max if self . maximize else self . min worst = self . min if self . maximize else self . max data = [ self . mean , self . median , best , worst ] colors = [ \"grey\" , \"blue\" , \"green\" , \"red\" ] labels = [ \"mean\" , \"median\" , \"best\" , \"worst\" ] for val , col , lab in zip ( data , colors , labels ): ax . plot ( range ( self . gen_ctr ), val , color = col , label = lab ) plt . fill_between ( range ( self . gen_ctr ), data [ 2 ], data [ 3 ], color = '#e6f2e6' ) plt . grid ( True ) ymin = min ([ min ( d ) for d in data ]) ymax = max ([ max ( d ) for d in data ]) yrange = ymax - ymin plt . ylim (( ymin - 0.1 * yrange , ymax + 0.1 * yrange )) ax . xaxis . set_major_locator ( MaxNLocator ( integer = True )) # legend and title ax . set_title ( f \"Optimization evolution ( { gen_nbr } g. x { psize } c.)\" ) ax . legend ( loc = \"center left\" , bbox_to_anchor = ( 1 , 0.5 )) ax . set_xlabel ( 'generation $[ \\\\ cdot]$' ) ax . set_ylabel ( 'fitness' ) # save figure as png logger . info ( f \"saving { fig_name } to { self . outdir } \" ) plt . savefig ( os . path . join ( self . outdir , fig_name ), bbox_inches = 'tight' ) plt . close () def save_results ( self ): \"\"\" **Saves** candidates and fitnesses to file. \"\"\" logger . info ( f \"optimization results saved to { self . outdir } \" ) np . savetxt ( os . path . join ( self . outdir , \"candidates.txt\" ), np . reshape ( self . inputs , ( - 1 , self . n_design )) ) np . savetxt ( os . path . join ( self . outdir , \"fitnesses.txt\" ), self . J ) @abstractmethod def set_simulator_class ( self ): \"\"\" Instantiates the simulator class with CustomSimulator if found. \"\"\" self . SimulatorClass = ( get_custom_class ( self . custom_file , \"CustomSimulator\" ) if self . custom_file else None ) @abstractmethod def _evaluate ( self , * args , ** kwargs ) -> list [ float | list [ float ]] | None : \"\"\" Computes all candidates outputs and return the optimizer list of QoIs. \"\"\" __init__ ( config : dict , debug : bool = False ) Instantiates the Optimizer object. Input config (dict): the config file dictionary. debug (bool): skip FFD and Mesh objects instantation for debugging purposes. Inner n_design (int): the number of design variables (dimensions of the problem). doe_size (int): the size of the initial and subsequent generations. max_generations (int): the number of generations before termination. dat_file (str): path to input_geometry.dat (baseline geometry). outdir (str): highest level optimization output directory. Note the result folder tree is structured as follows: outdir |__ FFD (contains <geom>_gXX_cYY.dat) |__ Figs (contains the figures generated during the optimization) |__ MESH (contains <geom>_gXX_cYY.mesh, .log, .geo_unrolled) |__ SOLVER |__ solver_gXX_cYY (contains the results of each simulation) study_type (str): use-case/meshing routine. ffd_type (str): deformation method. strategy (str): the optimization algorithm amongst inspyred's [ES, PSO] and pymoo's [GA, PSO] see https://pythonhosted.org/inspyred/examples.html#standard-algorithms and https://pymoo.org/algorithms/list.html#nb-algorithms-list maximize (bool): whether to maximize or minimize the objective QoIs. budget (int): maximum number of concurrent proc in use. nproc_per_sim (int): number of proc per simulation. bound (tuple[float]): design variables boundaries. custom_doe (str): path to a custom doe. sampler_name (str): name of the sampling algorithm used to generate samples. the initial generation. seed (int): seed number of the random processes involved in the optimization. prng (random.Random): pseudo-random generator passed to inspyred generator. ea_kwargs (dict): additional arguments to be passed to the evolution algorithm. gen_ctr (int): generation counter. generator (Generator): Generator object for the initial generation sampling. ffd (FFD_2D): FFD_2D object to generate deformed geometries. gmsh_mesh (Mesh): Mesh class to generate deformed geometries meshes. simulator (Simulator): Simulator object to perform simulations. mean (list[float]): list of populations mean fitness. median (list[float]): list of populations median fitness. max (list[float]): list of populations max fitness. min (list[float]): list of populations min fitness. J (list[float | list[float]]): the list of all generated candidates fitnesses. inputs (list[list[np.ndarray]]): all input candidates. ffd_profiles (list[list[np.ndarray]]): all deformed geometries {gid: {cid: ffd_profile}}. QoI (str): the quantity of intereset to minimize/maximize. n_plt (int): the number of best candidates results to display after each evaluation. cmap (str): the colormaps used for the observer plot see https://matplotlib.org/stable/users/explain/colors/colormaps.html. Source code in aero_optim/optim/optimizer.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def __init__ ( self , config : dict , debug : bool = False ): \"\"\" Instantiates the Optimizer object. **Input** - config (dict): the config file dictionary. - debug (bool): skip FFD and Mesh objects instantation for debugging purposes. **Inner** - n_design (int): the number of design variables (dimensions of the problem). - doe_size (int): the size of the initial and subsequent generations. - max_generations (int): the number of generations before termination. - dat_file (str): path to input_geometry.dat (baseline geometry). - outdir (str): highest level optimization output directory. Note: the result folder tree is structured as follows: ``` outdir |__ FFD (contains <geom>_gXX_cYY.dat) |__ Figs (contains the figures generated during the optimization) |__ MESH (contains <geom>_gXX_cYY.mesh, .log, .geo_unrolled) |__ SOLVER |__ solver_gXX_cYY (contains the results of each simulation) ``` - study_type (str): use-case/meshing routine. - ffd_type (str): deformation method. - strategy (str): the optimization algorithm amongst inspyred's [ES, PSO] and pymoo's [GA, PSO]</br> see https://pythonhosted.org/inspyred/examples.html#standard-algorithms</br> and https://pymoo.org/algorithms/list.html#nb-algorithms-list - maximize (bool): whether to maximize or minimize the objective QoIs. - budget (int): maximum number of concurrent proc in use. - nproc_per_sim (int): number of proc per simulation. - bound (tuple[float]): design variables boundaries. - custom_doe (str): path to a custom doe. - sampler_name (str): name of the sampling algorithm used to generate samples. the initial generation. - seed (int): seed number of the random processes involved in the optimization. - prng (random.Random): pseudo-random generator passed to inspyred generator. - ea_kwargs (dict): additional arguments to be passed to the evolution algorithm. - gen_ctr (int): generation counter. - generator (Generator): Generator object for the initial generation sampling. - ffd (FFD_2D): FFD_2D object to generate deformed geometries. - gmsh_mesh (Mesh): Mesh class to generate deformed geometries meshes. - simulator (Simulator): Simulator object to perform simulations. - mean (list[float]): list of populations mean fitness. - median (list[float]): list of populations median fitness. - max (list[float]): list of populations max fitness. - min (list[float]): list of populations min fitness. - J (list[float | list[float]]): the list of all generated candidates fitnesses. - inputs (list[list[np.ndarray]]): all input candidates. - ffd_profiles (list[list[np.ndarray]]): all deformed geometries {gid: {cid: ffd_profile}}. - QoI (str): the quantity of intereset to minimize/maximize. - n_plt (int): the number of best candidates results to display after each evaluation. - cmap (str): the colormaps used for the observer plot</br> see https://matplotlib.org/stable/users/explain/colors/colormaps.html. \"\"\" self . config = config self . process_config () # required entries self . n_design : int = config [ \"optim\" ][ \"n_design\" ] self . doe_size : int = config [ \"optim\" ][ \"doe_size\" ] self . max_generations : int = config [ \"optim\" ][ \"max_generations\" ] self . dat_file : str = config [ \"study\" ][ \"file\" ] self . outdir : str = config [ \"study\" ][ \"outdir\" ] self . study_type : str = config [ \"study\" ][ \"study_type\" ] # optional entries self . ffd_type : str = config [ \"study\" ] . get ( \"ffd_type\" , \"\" ) self . custom_file : str = config [ \"study\" ] . get ( \"custom_file\" , \"\" ) self . strategy : str = config [ \"optim\" ] . get ( \"strategy\" , \"PSO\" ) self . maximize : bool = config [ \"optim\" ] . get ( \"maximize\" , False ) self . budget : int = config [ \"optim\" ] . get ( \"budget\" , 4 ) self . nproc_per_sim : int = config [ \"optim\" ] . get ( \"nproc_per_sim\" , 1 ) self . bound : tuple [ Any , ... ] = tuple ( config [ \"optim\" ] . get ( \"bound\" , [ - 1 , 1 ])) self . custom_doe : str = config [ \"optim\" ] . get ( \"custom_doe\" , \"\" ) self . sampler_name : str = config [ \"optim\" ] . get ( \"sampler_name\" , \"lhs\" ) self . ea_kwargs : dict = config [ \"optim\" ] . get ( \"ea_kwargs\" , {}) # reproducibility variables self . seed : int = config [ \"optim\" ] . get ( \"seed\" , 123 ) self . prng : Random = Random () self . prng . seed ( self . seed ) # generation counter self . gen_ctr : int = 0 # optimization objects if not debug : self . set_ffd_class () self . set_gmsh_mesh_class () self . generator : Generator = Generator ( self . seed , self . n_design , self . doe_size , self . sampler_name , self . bound , self . custom_doe ) self . set_simulator_class () self . simulator = self . SimulatorClass ( self . config ) # population statistics self . mean : list [ float ] = [] self . median : list [ float ] = [] self . max : list [ float ] = [] self . min : list [ float ] = [] # set other inner optimization variables self . J : list [ float | list [ float ]] = [] self . inputs : list [ list [ np . ndarray ]] = [] self . ffd_profiles : list [ list [ np . ndarray ]] = [] self . QoI : str = self . config [ \"optim\" ] . get ( \"QoI\" , \"CD\" ) self . n_plt : int = self . config [ \"optim\" ] . get ( \"n_plt\" , 5 ) self . cmap : str = self . config [ \"optim\" ] . get ( \"cmap\" , \"viridis\" ) self . set_inner () # figure directory self . figdir : str = os . path . join ( self . outdir , \"Figs\" ) check_dir ( self . figdir ) _evaluate ( * args , ** kwargs ) -> list [ float | list [ float ]] | None abstractmethod Computes all candidates outputs and return the optimizer list of QoIs. Source code in aero_optim/optim/optimizer.py 401 402 403 404 405 @abstractmethod def _evaluate ( self , * args , ** kwargs ) -> list [ float | list [ float ]] | None : \"\"\" Computes all candidates outputs and return the optimizer list of QoIs. \"\"\" _observe ( * args , ** kwargs ) Plots generation data after each evaluation. Source code in aero_optim/optim/optimizer.py 318 319 320 321 322 def _observe ( self , * args , ** kwargs ): \"\"\" **Plots** generation data after each evaluation. \"\"\" logger . info ( \"_observe not implemented\" ) compute_statistics ( gen_fitness : np . ndarray ) Computes generation statistics. Note this method is meant to be called in _observe . Source code in aero_optim/optim/optimizer.py 306 307 308 309 310 311 312 313 314 315 316 def compute_statistics ( self , gen_fitness : np . ndarray ): \"\"\" **Computes** generation statistics. Note: this method is meant to be called in `_observe`. \"\"\" self . mean . append ( np . mean ( gen_fitness )) self . median . append ( np . median ( gen_fitness )) self . min . append ( min ( gen_fitness )) self . max . append ( max ( gen_fitness )) deform ( Delta : np . ndarray , gid : int , cid : int ) -> tuple [ str , np . ndarray ] Applies FFD on a given candidate and returns its resulting file. Source code in aero_optim/optim/optimizer.py 254 255 256 257 258 259 260 261 262 def deform ( self , Delta : np . ndarray , gid : int , cid : int ) -> tuple [ str , np . ndarray ]: \"\"\" **Applies** FFD on a given candidate and returns its resulting file. \"\"\" ffd_dir = os . path . join ( self . outdir , \"FFD\" ) check_dir ( ffd_dir ) logger . info ( f \"g { gid } , c { cid } generate profile with deformation { Delta } \" ) profile : np . ndarray = self . ffd . apply_ffd ( Delta ) return self . ffd . write_ffd ( profile , Delta , ffd_dir , gid = gid , cid = cid ), profile execute_candidates ( candidates : list [ Individual ] | np . ndarray , gid : int ) Executes all candidates and waits for them to finish. Note this method is meant to be called in _evaluate. Source code in aero_optim/optim/optimizer.py 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 def execute_candidates ( self , candidates : list [ Individual ] | np . ndarray , gid : int ): \"\"\" **Executes** all candidates and **waits** for them to finish. Note: this method is meant to be called in _evaluate. \"\"\" logger . info ( f \"evaluating candidates of generation { self . gen_ctr } ..\" ) self . ffd_profiles . append ([]) self . inputs . append ([]) for cid , cand in enumerate ( candidates ): self . inputs [ gid ] . append ( np . array ( cand )) ffd_file , ffd_profile = self . deform ( cand , gid , cid ) self . ffd_profiles [ gid ] . append ( ffd_profile ) # meshing with proper sigint management # see https://gitlab.onelab.info/gmsh/gmsh/-/issues/842 ORIGINAL_SIGINT_HANDLER = signal . signal ( signal . SIGINT , signal . SIG_DFL ) mesh_file = self . mesh ( ffd_file ) signal . signal ( signal . SIGINT , ORIGINAL_SIGINT_HANDLER ) while self . simulator . monitor_sim_progress () * self . nproc_per_sim >= self . budget : time . sleep ( 1 ) self . simulator . execute_sim ( meshfile = mesh_file , gid = gid , cid = cid ) # wait for last candidates to finish while self . simulator . monitor_sim_progress () > 0 : time . sleep ( 0.1 ) mesh ( ffdfile : str ) -> str Builds mesh for a given candidate and returns its resulting file. Note if a mesh file matching the pattern name already exists, it is not rebuilt. Source code in aero_optim/optim/optimizer.py 264 265 266 267 268 269 270 271 272 273 274 275 276 277 def mesh ( self , ffdfile : str ) -> str : \"\"\" **Builds** mesh for a given candidate and returns its resulting file. Note: if a mesh file matching the pattern name already exists, it is not rebuilt. \"\"\" mesh_dir = os . path . join ( self . outdir , \"MESH\" ) check_dir ( mesh_dir ) gmsh_mesh = self . MeshClass ( self . config , ffdfile ) if os . path . isfile ( gmsh_mesh . get_meshfile ( mesh_dir )): return gmsh_mesh . get_meshfile ( mesh_dir ) gmsh_mesh . build_mesh () return gmsh_mesh . write_mesh ( mesh_dir ) plot_generation ( gid : int , sorted_idx : np . ndarray , gen_fitness : np . ndarray , fig_name : str ) Plots the results of the last evaluated generation. Saves the graph in the output directory. Note this method is meant to be called in _observe . Source code in aero_optim/optim/optimizer.py 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 def plot_generation ( self , gid : int , sorted_idx : np . ndarray , gen_fitness : np . ndarray , fig_name : str ): \"\"\" **Plots** the results of the last evaluated generation. **Saves** the graph in the output directory. Note: this method is meant to be called in `_observe`. \"\"\" logger . info ( \"plot_generation not implemented\" ) plot_progress ( gen_nbr : int , fig_name : str , baseline_value : float | None = None ) Plots and saves the overall progress of the optimization. Note this method is meant to be called in final_observe . Source code in aero_optim/optim/optimizer.py 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 def plot_progress ( self , gen_nbr : int , fig_name : str , baseline_value : float | None = None ): \"\"\" **Plots** and **saves** the overall progress of the optimization. Note: this method is meant to be called in `final_observe`. \"\"\" logger . info ( f \"plotting populations statistics after { gen_nbr } generations..\" ) # plot construction _ , ax = plt . subplots ( figsize = ( 8 , 8 )) psize = self . doe_size if baseline_value : ax . axhline ( y = baseline_value , color = 'k' , ls = \"--\" , label = \"baseline\" ) # plotting data best = self . max if self . maximize else self . min worst = self . min if self . maximize else self . max data = [ self . mean , self . median , best , worst ] colors = [ \"grey\" , \"blue\" , \"green\" , \"red\" ] labels = [ \"mean\" , \"median\" , \"best\" , \"worst\" ] for val , col , lab in zip ( data , colors , labels ): ax . plot ( range ( self . gen_ctr ), val , color = col , label = lab ) plt . fill_between ( range ( self . gen_ctr ), data [ 2 ], data [ 3 ], color = '#e6f2e6' ) plt . grid ( True ) ymin = min ([ min ( d ) for d in data ]) ymax = max ([ max ( d ) for d in data ]) yrange = ymax - ymin plt . ylim (( ymin - 0.1 * yrange , ymax + 0.1 * yrange )) ax . xaxis . set_major_locator ( MaxNLocator ( integer = True )) # legend and title ax . set_title ( f \"Optimization evolution ( { gen_nbr } g. x { psize } c.)\" ) ax . legend ( loc = \"center left\" , bbox_to_anchor = ( 1 , 0.5 )) ax . set_xlabel ( 'generation $[ \\\\ cdot]$' ) ax . set_ylabel ( 'fitness' ) # save figure as png logger . info ( f \"saving { fig_name } to { self . outdir } \" ) plt . savefig ( os . path . join ( self . outdir , fig_name ), bbox_inches = 'tight' ) plt . close () process_config () Makes sure the config file contains the required information. Source code in aero_optim/optim/optimizer.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 def process_config ( self ): \"\"\" **Makes sure** the config file contains the required information. \"\"\" logger . info ( \"processing config..\" ) if \"n_design\" not in self . config [ \"optim\" ]: raise Exception ( f \"ERROR -- no <n_design> entry in { self . config [ 'optim' ] } \" ) if \"doe_size\" not in self . config [ \"optim\" ]: raise Exception ( f \"ERROR -- no <doe_size> entry in { self . config [ 'optim' ] } \" ) if \"max_generations\" not in self . config [ \"optim\" ]: raise Exception ( f \"ERROR -- no <max_generations> entry in { self . config [ 'optim' ] } \" ) if \"file\" not in self . config [ \"study\" ]: raise Exception ( f \"ERROR -- no <file> entry in { self . config [ 'study' ] } \" ) if \"budget\" not in self . config [ \"optim\" ]: logger . warning ( f \"no <budget> entry in { self . config [ 'optim' ] } \" ) if \"nproc_per_sim\" not in self . config [ \"optim\" ]: logger . warning ( f \"no <nproc_per_sim> entry in { self . config [ 'optim' ] } \" ) if \"bound\" not in self . config [ \"optim\" ]: logger . warning ( f \"no <bound> entry in { self . config [ 'optim' ] } \" ) if \"sampler_name\" not in self . config [ \"optim\" ]: logger . warning ( f \"no <sampler_name> entry in { self . config [ 'optim' ] } \" ) if \"seed\" not in self . config [ \"optim\" ]: logger . warning ( f \"no <seed> entry in { self . config [ 'optim' ] } \" ) # alter config for optimization purposes if \"outfile\" in self . config [ \"study\" ]: logger . warning ( f \"<outfile> entry in { self . config [ 'study' ] } will be ignored\" ) del self . config [ \"study\" ][ \"outfile\" ] if \"view\" in self . config [ \"gmsh\" ] and \"GUI\" in self . config [ \"gmsh\" ][ \"view\" ]: logger . warning ( f \"<GUI> entry in { self . config [ 'gmsh' ][ 'view' ] } forced to False\" ) self . config [ \"gmsh\" ][ \"view\" ][ \"GUI\" ] = False save_results () Saves candidates and fitnesses to file. Source code in aero_optim/optim/optimizer.py 381 382 383 384 385 386 387 388 389 390 def save_results ( self ): \"\"\" **Saves** candidates and fitnesses to file. \"\"\" logger . info ( f \"optimization results saved to { self . outdir } \" ) np . savetxt ( os . path . join ( self . outdir , \"candidates.txt\" ), np . reshape ( self . inputs , ( - 1 , self . n_design )) ) np . savetxt ( os . path . join ( self . outdir , \"fitnesses.txt\" ), self . J ) set_ffd_class () Instantiates the deformation class and object as custom if found, as one of the default classes otherwise. Source code in aero_optim/optim/optimizer.py 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 def set_ffd_class ( self ): \"\"\" **Instantiates** the deformation class and object as custom if found, as one of the default classes otherwise. \"\"\" self . FFDClass = ( get_custom_class ( self . custom_file , \"CustomFFD\" ) if self . custom_file else None ) ffd_config = self . config . get ( \"ffd\" , {}) rotation = ffd_config . get ( \"rotation\" , False ) if not self . FFDClass : # standard FFD 2D if self . ffd_type == FFD_TYPE [ 0 ]: self . FFDClass = FFD_2D self . ffd = self . FFDClass ( self . dat_file , self . n_design // 2 , ** ffd_config ) # POD coupled FFD 2D elif self . ffd_type == FFD_TYPE [ 1 ]: self . FFDClass = FFD_POD_2D ffd_config [ \"ffd_ncontrol\" ] = self . n_design ffd_config [ \"ffd_bound\" ] = self . bound logger . info ( f \"ffd bound: { self . bound } \" ) self . ffd = self . FFDClass ( self . dat_file , ** ffd_config ) self . n_design = ffd_config [ \"pod_ncontrol\" ] self . bound = ffd_config . get ( \"pod_bound\" , self . ffd . get_bound ()) logger . info ( f \"pod bound: { self . bound } \" ) else : raise Exception ( f \"ERROR -- incorrect ffd_type < { self . ffd_type } >\" ) else : self . ffd = self . FFDClass ( self . dat_file , self . n_design , ** ffd_config ) # rotation wrapper if rotation : logger . info ( f \"rotation: { rotation } \" ) self . ffd = RotationWrapper ( self . ffd ) rot_bound = ffd_config . get ( \"rot_bound\" , [ - 1 , 1 ]) # convert bound from tuple of floats to tuple of lists if not isinstance ( self . bound [ 0 ], list ): self . bound = ([ self . bound [ 0 ]] * self . n_design , [ self . bound [ - 1 ]] * self . n_design ) self . bound = ( self . bound [ 0 ] + [ rot_bound [ 0 ]], self . bound [ - 1 ] + [ rot_bound [ - 1 ]]) self . n_design += 1 logger . info ( f \"effective n_design: { self . n_design } \" ) set_gmsh_mesh_class () Instantiates the mesher class as custom if found, as one of the default meshers otherwise. Source code in aero_optim/optim/optimizer.py 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 def set_gmsh_mesh_class ( self ): \"\"\" **Instantiates** the mesher class as custom if found, as one of the default meshers otherwise. \"\"\" self . MeshClass = ( get_custom_class ( self . custom_file , \"CustomMesh\" ) if self . custom_file else None ) if not self . MeshClass : if self . study_type == STUDY_TYPE [ 0 ]: self . MeshClass = NACABaseMesh elif self . study_type == STUDY_TYPE [ 1 ]: self . MeshClass = NACABlockMesh elif self . study_type == STUDY_TYPE [ 2 ]: self . MeshClass = CascadeMesh elif self . study_type == STUDY_TYPE [ 3 ]: self . MeshClass = MeshMusicaa else : raise Exception ( f \"ERROR -- incorrect study_type < { self . study_type } >\" ) set_inner () Sets some use-case specific inner variables: Source code in aero_optim/optim/optimizer.py 248 249 250 251 252 def set_inner ( self ): \"\"\" **Sets** some use-case specific inner variables: \"\"\" logger . info ( \"set_inner not implemented\" ) set_simulator_class () abstractmethod Instantiates the simulator class with CustomSimulator if found. Source code in aero_optim/optim/optimizer.py 392 393 394 395 396 397 398 399 @abstractmethod def set_simulator_class ( self ): \"\"\" Instantiates the simulator class with CustomSimulator if found. \"\"\" self . SimulatorClass = ( get_custom_class ( self . custom_file , \"CustomSimulator\" ) if self . custom_file else None ) optim.optimizer.WolfOptimizer Bases: Optimizer , ABC This class implements a Wolf based Optimizer. Source code in aero_optim/optim/optimizer.py 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 class WolfOptimizer ( Optimizer , ABC ): \"\"\" This class implements a Wolf based Optimizer. \"\"\" def __init__ ( self , config : dict ): \"\"\" Instantiates the WolfOptimizer object. **Input** - config (dict): the config file dictionary. \"\"\" super () . __init__ ( config ) def set_simulator_class ( self ): \"\"\" **Sets** the simulator class as custom if found, as WolfSimulator otherwise. \"\"\" super () . set_simulator_class () if not self . SimulatorClass : self . SimulatorClass = WolfSimulator def set_inner ( self ): \"\"\" **Sets** some use-case specific inner variables: - baseline_CD (float): the drag coefficient of the baseline geometry. - baseline_CL (float): the lift coefficient of the baseline geometry. - baseline_area (float): the baseline area that is used as a structural constraint. - area_margin (float): area tolerance margin given as a percentage wrt baseline_area</br> i.e. a candidate with an area greater/smaller than +/- area_margin % of the baseline_area will be penalized. - penalty (list): a [key, value] constraint not to be worsen by the optimization. - constraint (bool): constraints are applied (True) or not (False) \"\"\" self . baseline_CD = self . config [ \"optim\" ] . get ( \"baseline_CD\" , 0.15 ) self . baseline_CL = self . config [ \"optim\" ] . get ( \"baseline_CL\" , 0.36 ) self . baseline_area = abs ( get_area ( self . ffd . pts )) self . area_margin = self . config [ \"optim\" ] . get ( \"area_margin\" , 40. ) / 100. self . penalty = self . config [ \"optim\" ] . get ( \"penalty\" , [ \"CL\" , self . baseline_CL ]) self . constraint = self . config [ \"optim\" ] . get ( \"constraint\" , True ) def plot_generation ( self , gid : int , sorted_idx : np . ndarray , gen_fitness : np . ndarray , fig_name : str ): \"\"\" **Plots** the results of the last evaluated generation. **Saves** the graph in the output directory. \"\"\" baseline : np . ndarray = self . ffd . pts profiles : list [ np . ndarray ] = self . ffd_profiles [ gid ] res_dict = self . simulator . df_dict [ gid ] df_key = res_dict [ 0 ] . columns # \"ResTot\", \"CD\", \"CL\", \"ResCD\", \"ResCL\", \"x\", \"y\", \"Cp\" cmap = mpl . colormaps [ self . cmap ] . resampled ( self . n_plt ) colors = cmap ( np . linspace ( 0 , 1 , self . n_plt )) # subplot construction fig = plt . figure ( figsize = ( 16 , 12 )) ax1 = plt . subplot ( 2 , 1 , 1 ) # profiles ax2 = plt . subplot ( 2 , 3 , 4 ) # ResTot ax3 = plt . subplot ( 2 , 3 , 5 ) # CD & CL ax4 = plt . subplot ( 2 , 3 , 6 ) # fitness (CD) plt . subplots_adjust ( wspace = 0.25 ) ax1 . plot ( baseline [:, 0 ], baseline [:, 1 ], color = \"k\" , lw = 2 , ls = \"--\" , label = \"baseline\" ) ax3 . axhline ( y = self . baseline_CD , color = 'k' , label = \"baseline\" ) ax3 . axhline ( y = self . baseline_CL , color = 'k' , linestyle = \"--\" , label = \"baseline\" ) ax4 . axhline ( y = self . baseline_CD , color = 'k' , linestyle = \"--\" , label = \"baseline\" ) # loop over candidates through the last generated profiles for color , cid in enumerate ( sorted_idx ): ax1 . plot ( profiles [ cid ][:, 0 ], profiles [ cid ][:, 1 ], color = colors [ color ], label = f \"c { cid } \" ) res_dict [ cid ][ df_key [ 0 ]] . plot ( ax = ax2 , color = colors [ color ], label = f \"c { cid } \" ) # ResTot res_dict [ cid ][ df_key [ 1 ]] . plot ( ax = ax3 , color = colors [ color ], label = f \" { df_key [ 1 ] } c { cid } \" ) res_dict [ cid ][ df_key [ 2 ]] . plot ( ax = ax3 , color = colors [ color ], ls = \"--\" , label = f \" { df_key [ 2 ] } c { cid } \" ) ax4 . scatter ( cid , gen_fitness [ cid ], color = colors [ color ], label = f \"c { cid } \" ) # legend and title fig . suptitle ( f \"Generation { gid } - { self . n_plt } top candidates\" , size = \"x-large\" , weight = \"bold\" , y = 0.93 ) # top ax1 . set_title ( \"FFD profiles\" , weight = \"bold\" ) ax1 . legend ( loc = \"center left\" , bbox_to_anchor = ( 1 , 0.5 )) ax1 . set_xlabel ( '$x$ $[m]$' ) ax1 . set_ylabel ( '$y$ $[m]$' ) # bottom left ax2 . set_title ( f \" { df_key [ 0 ] } \" , weight = \"bold\" ) ax2 . set_yscale ( \"log\" ) ax2 . set_xlabel ( 'iteration $[ \\\\ cdot]$' ) ax2 . set_ylabel ( 'residual $[ \\\\ cdot]$' ) # bottom center ax3 . set_title ( f \" { df_key [ 1 ] } & { df_key [ 2 ] } \" , weight = \"bold\" ) ax3 . set_xlabel ( 'iteration $[ \\\\ cdot]$' ) ax3 . set_ylabel ( 'aerodynamic coefficients $[ \\\\ cdot]$' ) # bottom right ax4 . xaxis . set_major_locator ( MaxNLocator ( integer = True )) ax4 . set_title ( f \"fitness: { self . QoI } \" , weight = \"bold\" ) ax4 . legend ( loc = \"center left\" , bbox_to_anchor = ( 1 , 0.5 )) ax4 . set_xlabel ( 'candidate $[ \\\\ cdot]$' ) ax4 . set_ylabel ( \"fitness\" ) # save figure as png logger . info ( f \"saving { fig_name } to { self . outdir } \" ) plt . savefig ( os . path . join ( self . figdir , fig_name ), bbox_inches = 'tight' ) plt . close () def save_results ( self ): super () . save_results () with open ( os . path . join ( self . outdir , \"df_dict.pkl\" ), \"wb\" ) as handle : pickle . dump ( self . simulator . df_dict , handle ) logger . info ( f \"results dictionary saved to { self . outdir } \" ) @abstractmethod def apply_constraints ( self , * args , ** kwargs ): \"\"\" Looks for constraints violations. \"\"\" @abstractmethod def final_observe ( self , * args , ** kwargs ): \"\"\" Plots convergence progress by plotting the fitness values obtained with the successive generations. \"\"\" __init__ ( config : dict ) Instantiates the WolfOptimizer object. Input config (dict): the config file dictionary. Source code in aero_optim/optim/optimizer.py 412 413 414 415 416 417 418 419 420 def __init__ ( self , config : dict ): \"\"\" Instantiates the WolfOptimizer object. **Input** - config (dict): the config file dictionary. \"\"\" super () . __init__ ( config ) apply_constraints ( * args , ** kwargs ) abstractmethod Looks for constraints violations. Source code in aero_optim/optim/optimizer.py 523 524 525 526 527 @abstractmethod def apply_constraints ( self , * args , ** kwargs ): \"\"\" Looks for constraints violations. \"\"\" final_observe ( * args , ** kwargs ) abstractmethod Plots convergence progress by plotting the fitness values obtained with the successive generations. Source code in aero_optim/optim/optimizer.py 529 530 531 532 533 534 @abstractmethod def final_observe ( self , * args , ** kwargs ): \"\"\" Plots convergence progress by plotting the fitness values obtained with the successive generations. \"\"\" plot_generation ( gid : int , sorted_idx : np . ndarray , gen_fitness : np . ndarray , fig_name : str ) Plots the results of the last evaluated generation. Saves the graph in the output directory. Source code in aero_optim/optim/optimizer.py 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 def plot_generation ( self , gid : int , sorted_idx : np . ndarray , gen_fitness : np . ndarray , fig_name : str ): \"\"\" **Plots** the results of the last evaluated generation. **Saves** the graph in the output directory. \"\"\" baseline : np . ndarray = self . ffd . pts profiles : list [ np . ndarray ] = self . ffd_profiles [ gid ] res_dict = self . simulator . df_dict [ gid ] df_key = res_dict [ 0 ] . columns # \"ResTot\", \"CD\", \"CL\", \"ResCD\", \"ResCL\", \"x\", \"y\", \"Cp\" cmap = mpl . colormaps [ self . cmap ] . resampled ( self . n_plt ) colors = cmap ( np . linspace ( 0 , 1 , self . n_plt )) # subplot construction fig = plt . figure ( figsize = ( 16 , 12 )) ax1 = plt . subplot ( 2 , 1 , 1 ) # profiles ax2 = plt . subplot ( 2 , 3 , 4 ) # ResTot ax3 = plt . subplot ( 2 , 3 , 5 ) # CD & CL ax4 = plt . subplot ( 2 , 3 , 6 ) # fitness (CD) plt . subplots_adjust ( wspace = 0.25 ) ax1 . plot ( baseline [:, 0 ], baseline [:, 1 ], color = \"k\" , lw = 2 , ls = \"--\" , label = \"baseline\" ) ax3 . axhline ( y = self . baseline_CD , color = 'k' , label = \"baseline\" ) ax3 . axhline ( y = self . baseline_CL , color = 'k' , linestyle = \"--\" , label = \"baseline\" ) ax4 . axhline ( y = self . baseline_CD , color = 'k' , linestyle = \"--\" , label = \"baseline\" ) # loop over candidates through the last generated profiles for color , cid in enumerate ( sorted_idx ): ax1 . plot ( profiles [ cid ][:, 0 ], profiles [ cid ][:, 1 ], color = colors [ color ], label = f \"c { cid } \" ) res_dict [ cid ][ df_key [ 0 ]] . plot ( ax = ax2 , color = colors [ color ], label = f \"c { cid } \" ) # ResTot res_dict [ cid ][ df_key [ 1 ]] . plot ( ax = ax3 , color = colors [ color ], label = f \" { df_key [ 1 ] } c { cid } \" ) res_dict [ cid ][ df_key [ 2 ]] . plot ( ax = ax3 , color = colors [ color ], ls = \"--\" , label = f \" { df_key [ 2 ] } c { cid } \" ) ax4 . scatter ( cid , gen_fitness [ cid ], color = colors [ color ], label = f \"c { cid } \" ) # legend and title fig . suptitle ( f \"Generation { gid } - { self . n_plt } top candidates\" , size = \"x-large\" , weight = \"bold\" , y = 0.93 ) # top ax1 . set_title ( \"FFD profiles\" , weight = \"bold\" ) ax1 . legend ( loc = \"center left\" , bbox_to_anchor = ( 1 , 0.5 )) ax1 . set_xlabel ( '$x$ $[m]$' ) ax1 . set_ylabel ( '$y$ $[m]$' ) # bottom left ax2 . set_title ( f \" { df_key [ 0 ] } \" , weight = \"bold\" ) ax2 . set_yscale ( \"log\" ) ax2 . set_xlabel ( 'iteration $[ \\\\ cdot]$' ) ax2 . set_ylabel ( 'residual $[ \\\\ cdot]$' ) # bottom center ax3 . set_title ( f \" { df_key [ 1 ] } & { df_key [ 2 ] } \" , weight = \"bold\" ) ax3 . set_xlabel ( 'iteration $[ \\\\ cdot]$' ) ax3 . set_ylabel ( 'aerodynamic coefficients $[ \\\\ cdot]$' ) # bottom right ax4 . xaxis . set_major_locator ( MaxNLocator ( integer = True )) ax4 . set_title ( f \"fitness: { self . QoI } \" , weight = \"bold\" ) ax4 . legend ( loc = \"center left\" , bbox_to_anchor = ( 1 , 0.5 )) ax4 . set_xlabel ( 'candidate $[ \\\\ cdot]$' ) ax4 . set_ylabel ( \"fitness\" ) # save figure as png logger . info ( f \"saving { fig_name } to { self . outdir } \" ) plt . savefig ( os . path . join ( self . figdir , fig_name ), bbox_inches = 'tight' ) plt . close () set_inner () Sets some use-case specific inner variables: baseline_CD (float): the drag coefficient of the baseline geometry. baseline_CL (float): the lift coefficient of the baseline geometry. baseline_area (float): the baseline area that is used as a structural constraint. area_margin (float): area tolerance margin given as a percentage wrt baseline_area i.e. a candidate with an area greater/smaller than +/- area_margin % of the baseline_area will be penalized. penalty (list): a [key, value] constraint not to be worsen by the optimization. constraint (bool): constraints are applied (True) or not (False) Source code in aero_optim/optim/optimizer.py 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 def set_inner ( self ): \"\"\" **Sets** some use-case specific inner variables: - baseline_CD (float): the drag coefficient of the baseline geometry. - baseline_CL (float): the lift coefficient of the baseline geometry. - baseline_area (float): the baseline area that is used as a structural constraint. - area_margin (float): area tolerance margin given as a percentage wrt baseline_area</br> i.e. a candidate with an area greater/smaller than +/- area_margin % of the baseline_area will be penalized. - penalty (list): a [key, value] constraint not to be worsen by the optimization. - constraint (bool): constraints are applied (True) or not (False) \"\"\" self . baseline_CD = self . config [ \"optim\" ] . get ( \"baseline_CD\" , 0.15 ) self . baseline_CL = self . config [ \"optim\" ] . get ( \"baseline_CL\" , 0.36 ) self . baseline_area = abs ( get_area ( self . ffd . pts )) self . area_margin = self . config [ \"optim\" ] . get ( \"area_margin\" , 40. ) / 100. self . penalty = self . config [ \"optim\" ] . get ( \"penalty\" , [ \"CL\" , self . baseline_CL ]) self . constraint = self . config [ \"optim\" ] . get ( \"constraint\" , True ) set_simulator_class () Sets the simulator class as custom if found, as WolfSimulator otherwise. Source code in aero_optim/optim/optimizer.py 422 423 424 425 426 427 428 def set_simulator_class ( self ): \"\"\" **Sets** the simulator class as custom if found, as WolfSimulator otherwise. \"\"\" super () . set_simulator_class () if not self . SimulatorClass : self . SimulatorClass = WolfSimulator optim.optimizer.DebugOptimizer Bases: Optimizer , ABC Source code in aero_optim/optim/optimizer.py 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 class DebugOptimizer ( Optimizer , ABC ): def __init__ ( self , config : dict ): \"\"\" Dummy init. \"\"\" super () . __init__ ( config , debug = True ) def set_simulator_class ( self ): \"\"\" **Sets** the simulator class as custom if found, as DebugSimulator otherwise. \"\"\" super () . set_simulator_class () if not self . SimulatorClass : self . SimulatorClass = DebugSimulator def set_inner ( self ): return def execute_candidates ( self , candidates : list [ Individual ] | np . ndarray , gid : int ): \"\"\" **Executes** all candidates and **waits** for them to finish. \"\"\" logger . info ( f \"evaluating candidates of generation { self . gen_ctr } ..\" ) self . inputs . append ([]) for cid , cand in enumerate ( candidates ): self . inputs [ gid ] . append ( np . array ( cand )) logger . debug ( f \"g { gid } , c { cid } cand { cand } \" ) self . simulator . execute_sim ( cand , gid , cid ) logger . debug ( f \"g { gid } , c { cid } cand { cand } , \" f \"fitness { self . simulator . df_dict [ gid ][ cid ][ 'result' ] . iloc [ - 1 ] } \" ) __init__ ( config : dict ) Dummy init. Source code in aero_optim/optim/optimizer.py 538 539 540 541 542 def __init__ ( self , config : dict ): \"\"\" Dummy init. \"\"\" super () . __init__ ( config , debug = True ) execute_candidates ( candidates : list [ Individual ] | np . ndarray , gid : int ) Executes all candidates and waits for them to finish. Source code in aero_optim/optim/optimizer.py 555 556 557 558 559 560 561 562 563 564 565 566 def execute_candidates ( self , candidates : list [ Individual ] | np . ndarray , gid : int ): \"\"\" **Executes** all candidates and **waits** for them to finish. \"\"\" logger . info ( f \"evaluating candidates of generation { self . gen_ctr } ..\" ) self . inputs . append ([]) for cid , cand in enumerate ( candidates ): self . inputs [ gid ] . append ( np . array ( cand )) logger . debug ( f \"g { gid } , c { cid } cand { cand } \" ) self . simulator . execute_sim ( cand , gid , cid ) logger . debug ( f \"g { gid } , c { cid } cand { cand } , \" f \"fitness { self . simulator . df_dict [ gid ][ cid ][ 'result' ] . iloc [ - 1 ] } \" ) set_simulator_class () Sets the simulator class as custom if found, as DebugSimulator otherwise. Source code in aero_optim/optim/optimizer.py 544 545 546 547 548 549 550 def set_simulator_class ( self ): \"\"\" **Sets** the simulator class as custom if found, as DebugSimulator otherwise. \"\"\" super () . set_simulator_class () if not self . SimulatorClass : self . SimulatorClass = DebugSimulator inspyred Optimizers optim.inspyred_optimizer.InspyredWolfOptimizer Bases: WolfOptimizer This class implements a Wolf based Optimizer. Source code in aero_optim/optim/inspyred_optimizer.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 class InspyredWolfOptimizer ( WolfOptimizer ): \"\"\" This class implements a Wolf based Optimizer. \"\"\" def _evaluate ( self , candidates : list [ Individual ], args : dict ) -> list [ float | list [ float ]]: \"\"\" **Executes** Wolf simulations, **extracts** results and **returns** the list of candidates QoIs. Note: __candidates__ and __args__ are inspyred mandatory arguments</br> see https://pythonhosted.org/inspyred/tutorial.html#the-evaluator \"\"\" gid = self . gen_ctr # execute all candidates self . execute_candidates ( candidates , gid ) # add penalty to the candidates fitness for cid , _ in enumerate ( candidates ): self . J . append ( self . apply_constraints ( gid , cid , self . ffd_profiles [ gid ][ cid ], self . simulator . df_dict [ gid ][ cid ][ self . penalty [ 0 ]] . iloc [ - 1 ] ) ) self . J [ - 1 ] += self . simulator . df_dict [ gid ][ cid ][ self . QoI ] . iloc [ - 1 ] self . gen_ctr += 1 return self . J [ - self . doe_size :] def apply_constraints ( self , gid : int , cid : int , ffd_profile : np . ndarray , pen_value : float ) -> float : \"\"\" **Returns** a penalty value based on some specific constraints</br> see https://inspyred.readthedocs.io/en/latest/recipes.html#constraint-selection \"\"\" if not self . constraint : return 0. area_cond : bool = ( abs ( get_area ( ffd_profile )) > ( 1. + self . area_margin ) * self . baseline_area or abs ( get_area ( ffd_profile )) < ( 1. - self . area_margin ) * self . baseline_area ) penalty_cond : bool = pen_value < self . penalty [ - 1 ] if area_cond or penalty_cond : logger . info ( f \"penalized candidate g { gid } , c { cid } \" f \"with area { abs ( get_area ( ffd_profile )) } and CL { pen_value } \" ) return 1. return 0. def _observe ( self , population : list [ Individual ], num_generations : int , num_evaluations : int , args : dict ): \"\"\" **Plots** the n_plt best results each time a generation has been evaluated:</br> > the simulations residuals,</br> > the simulations CD & CL,</br> > the candidates fitness,</br> > the baseline and deformed profiles. Note: __num_generations__, __num_evaluations__ and __args__ are inspyred mandatory arguments</br> see https://pythonhosted.org/inspyred/examples.html#custom-observer \"\"\" gid = num_generations # extract generation best profiles fitness : np . ndarray = np . array ( self . J [ - self . doe_size :]) sorted_idx = ( np . argsort ( fitness )[ - self . n_plt :] if self . maximize else np . argsort ( fitness )[: self . n_plt ] ) # compute population statistics self . compute_statistics ( np . array ([ ind . fitness for ind in population ])) logger . info ( f \"extracting { self . n_plt } best profiles in g { gid } : { sorted_idx } ..\" ) logger . debug ( f \"g { gid } J-fitnesses (candidates): { fitness } \" ) logger . debug ( f \"g { gid } P-fitness (population) { [ ind . fitness for ind in population ] } \" ) # plot settings fig_name = f \"inspyred_g { num_generations } .png\" self . plot_generation ( gid , sorted_idx , fitness , fig_name ) def final_observe ( self , * args , ** kwargs ): \"\"\" **Plots** convergence progress by plotting the fitness values obtained with the successive generations</br> see https://pythonhosted.org/inspyred/reference.html#inspyred.ec.analysis.generation_plot \"\"\" fig_name = f \"inspyred_optim_g { self . gen_ctr - 1 } _c { self . doe_size } .png\" self . plot_progress ( self . gen_ctr - 1 , fig_name , baseline_value = self . baseline_CD ) _evaluate ( candidates : list [ Individual ], args : dict ) -> list [ float | list [ float ]] Executes Wolf simulations, extracts results and returns the list of candidates QoIs. Note candidates and args are inspyred mandatory arguments see https://pythonhosted.org/inspyred/tutorial.html#the-evaluator Source code in aero_optim/optim/inspyred_optimizer.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def _evaluate ( self , candidates : list [ Individual ], args : dict ) -> list [ float | list [ float ]]: \"\"\" **Executes** Wolf simulations, **extracts** results and **returns** the list of candidates QoIs. Note: __candidates__ and __args__ are inspyred mandatory arguments</br> see https://pythonhosted.org/inspyred/tutorial.html#the-evaluator \"\"\" gid = self . gen_ctr # execute all candidates self . execute_candidates ( candidates , gid ) # add penalty to the candidates fitness for cid , _ in enumerate ( candidates ): self . J . append ( self . apply_constraints ( gid , cid , self . ffd_profiles [ gid ][ cid ], self . simulator . df_dict [ gid ][ cid ][ self . penalty [ 0 ]] . iloc [ - 1 ] ) ) self . J [ - 1 ] += self . simulator . df_dict [ gid ][ cid ][ self . QoI ] . iloc [ - 1 ] self . gen_ctr += 1 return self . J [ - self . doe_size :] _observe ( population : list [ Individual ], num_generations : int , num_evaluations : int , args : dict ) Plots the n_plt best results each time a generation has been evaluated: the simulations residuals, the simulations CD & CL, the candidates fitness, the baseline and deformed profiles. Note num_generations , num_evaluations and args are inspyred mandatory arguments see https://pythonhosted.org/inspyred/examples.html#custom-observer Source code in aero_optim/optim/inspyred_optimizer.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 def _observe ( self , population : list [ Individual ], num_generations : int , num_evaluations : int , args : dict ): \"\"\" **Plots** the n_plt best results each time a generation has been evaluated:</br> > the simulations residuals,</br> > the simulations CD & CL,</br> > the candidates fitness,</br> > the baseline and deformed profiles. Note: __num_generations__, __num_evaluations__ and __args__ are inspyred mandatory arguments</br> see https://pythonhosted.org/inspyred/examples.html#custom-observer \"\"\" gid = num_generations # extract generation best profiles fitness : np . ndarray = np . array ( self . J [ - self . doe_size :]) sorted_idx = ( np . argsort ( fitness )[ - self . n_plt :] if self . maximize else np . argsort ( fitness )[: self . n_plt ] ) # compute population statistics self . compute_statistics ( np . array ([ ind . fitness for ind in population ])) logger . info ( f \"extracting { self . n_plt } best profiles in g { gid } : { sorted_idx } ..\" ) logger . debug ( f \"g { gid } J-fitnesses (candidates): { fitness } \" ) logger . debug ( f \"g { gid } P-fitness (population) { [ ind . fitness for ind in population ] } \" ) # plot settings fig_name = f \"inspyred_g { num_generations } .png\" self . plot_generation ( gid , sorted_idx , fitness , fig_name ) apply_constraints ( gid : int , cid : int , ffd_profile : np . ndarray , pen_value : float ) -> float Returns a penalty value based on some specific constraints see https://inspyred.readthedocs.io/en/latest/recipes.html#constraint-selection Source code in aero_optim/optim/inspyred_optimizer.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def apply_constraints ( self , gid : int , cid : int , ffd_profile : np . ndarray , pen_value : float ) -> float : \"\"\" **Returns** a penalty value based on some specific constraints</br> see https://inspyred.readthedocs.io/en/latest/recipes.html#constraint-selection \"\"\" if not self . constraint : return 0. area_cond : bool = ( abs ( get_area ( ffd_profile )) > ( 1. + self . area_margin ) * self . baseline_area or abs ( get_area ( ffd_profile )) < ( 1. - self . area_margin ) * self . baseline_area ) penalty_cond : bool = pen_value < self . penalty [ - 1 ] if area_cond or penalty_cond : logger . info ( f \"penalized candidate g { gid } , c { cid } \" f \"with area { abs ( get_area ( ffd_profile )) } and CL { pen_value } \" ) return 1. return 0. final_observe ( * args , ** kwargs ) Plots convergence progress by plotting the fitness values obtained with the successive generations see https://pythonhosted.org/inspyred/reference.html#inspyred.ec.analysis.generation_plot Source code in aero_optim/optim/inspyred_optimizer.py 119 120 121 122 123 124 125 126 def final_observe ( self , * args , ** kwargs ): \"\"\" **Plots** convergence progress by plotting the fitness values obtained with the successive generations</br> see https://pythonhosted.org/inspyred/reference.html#inspyred.ec.analysis.generation_plot \"\"\" fig_name = f \"inspyred_optim_g { self . gen_ctr - 1 } _c { self . doe_size } .png\" self . plot_progress ( self . gen_ctr - 1 , fig_name , baseline_value = self . baseline_CD ) optim.inspyred_optimizer.InspyredDebugOptimizer Bases: DebugOptimizer Source code in aero_optim/optim/inspyred_optimizer.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 class InspyredDebugOptimizer ( DebugOptimizer ): def _evaluate ( self , candidates : list [ Individual ], args : dict ) -> list [ float | list [ float ]]: \"\"\" **Executes** dummy simulations, **extracts** results and **returns** the list of candidates QoIs. \"\"\" gid = self . gen_ctr # execute all candidates self . execute_candidates ( candidates , gid ) for cid , _ in enumerate ( candidates ): self . J . append ( self . simulator . df_dict [ gid ][ cid ][ \"result\" ] . iloc [ - 1 ]) self . gen_ctr += 1 return self . J [ - self . doe_size :] def _observe ( self , population : list [ Individual ], num_generations : int , num_evaluations : int , args : dict ): \"\"\" Dummy _observe function. \"\"\" # extract best profiles gid = num_generations fitness : np . ndarray = np . array ( self . J [ - self . doe_size :]) sorted_idx = np . argsort ( fitness , kind = \"stable\" )[: self . n_plt ] logger . info ( f \"extracting { self . n_plt } best profiles in g { gid } : { sorted_idx } ..\" ) logger . debug ( f \"g { gid } J-fitnesses (candidates): { fitness } \" ) logger . debug ( f \"g { gid } P-fitness (population) { [ ind . fitness for ind in population ] } \" ) # compute population statistics self . compute_statistics ( np . array ([ ind . fitness for ind in population ])) def final_observe ( self ): \"\"\" Dummy final_observe function. \"\"\" fig_name = f \"inspyred_optim_g { self . gen_ctr - 1 } _c { self . doe_size } .png\" self . plot_progress ( self . gen_ctr - 1 , fig_name ) _evaluate ( candidates : list [ Individual ], args : dict ) -> list [ float | list [ float ]] Executes dummy simulations, extracts results and returns the list of candidates QoIs. Source code in aero_optim/optim/inspyred_optimizer.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 def _evaluate ( self , candidates : list [ Individual ], args : dict ) -> list [ float | list [ float ]]: \"\"\" **Executes** dummy simulations, **extracts** results and **returns** the list of candidates QoIs. \"\"\" gid = self . gen_ctr # execute all candidates self . execute_candidates ( candidates , gid ) for cid , _ in enumerate ( candidates ): self . J . append ( self . simulator . df_dict [ gid ][ cid ][ \"result\" ] . iloc [ - 1 ]) self . gen_ctr += 1 return self . J [ - self . doe_size :] _observe ( population : list [ Individual ], num_generations : int , num_evaluations : int , args : dict ) Dummy _observe function. Source code in aero_optim/optim/inspyred_optimizer.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 def _observe ( self , population : list [ Individual ], num_generations : int , num_evaluations : int , args : dict ): \"\"\" Dummy _observe function. \"\"\" # extract best profiles gid = num_generations fitness : np . ndarray = np . array ( self . J [ - self . doe_size :]) sorted_idx = np . argsort ( fitness , kind = \"stable\" )[: self . n_plt ] logger . info ( f \"extracting { self . n_plt } best profiles in g { gid } : { sorted_idx } ..\" ) logger . debug ( f \"g { gid } J-fitnesses (candidates): { fitness } \" ) logger . debug ( f \"g { gid } P-fitness (population) { [ ind . fitness for ind in population ] } \" ) # compute population statistics self . compute_statistics ( np . array ([ ind . fitness for ind in population ])) final_observe () Dummy final_observe function. Source code in aero_optim/optim/inspyred_optimizer.py 167 168 169 170 171 172 def final_observe ( self ): \"\"\" Dummy final_observe function. \"\"\" fig_name = f \"inspyred_optim_g { self . gen_ctr - 1 } _c { self . doe_size } .png\" self . plot_progress ( self . gen_ctr - 1 , fig_name ) pymoo Optimizers optim.pymoo_optimizer.PymooWolfOptimizer Bases: WolfOptimizer , Problem This class implements a Wolf based Optimizer. Source code in aero_optim/optim/pymoo_optimizer.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 class PymooWolfOptimizer ( WolfOptimizer , Problem ): \"\"\" This class implements a Wolf based Optimizer. \"\"\" def __init__ ( self , config : dict ): \"\"\" Instantiates the WolfOptimizer object. **Input** - config (dict): the config file dictionary. \"\"\" WolfOptimizer . __init__ ( self , config ) Problem . __init__ ( self , n_var = self . n_design , n_obj = 1 , n_ieq_constr = 2 , xl = self . bound [ 0 ], xu = self . bound [ 1 ] ) def _evaluate ( self , X : np . ndarray , out : np . ndarray , * args , ** kwargs ): \"\"\" **Executes** Wolf simulations, **extracts** results and **returns** arrays of candidates QoIs and constraints. \"\"\" gid = self . gen_ctr # execute all candidates self . execute_candidates ( X , gid ) # update candidates fitness self . J . extend ([ self . simulator . df_dict [ gid ][ cid ][ self . QoI ] . iloc [ - 1 ] for cid in range ( len ( X )) ]) out [ \"F\" ] = np . array ( self . J [ - self . doe_size :]) out [ \"G\" ] = self . apply_constraints ( gid ) self . _observe ( out [ \"F\" ]) self . gen_ctr += 1 def apply_constraints ( self , gid : int ) -> np . ndarray : \"\"\" **Returns** a constraint array ensuring negative inequality</br> see https://pymoo.org/constraints/index.html \"\"\" out = [] if not self . constraint : return np . row_stack ([[ - 1 , - 1 ] for _ in range ( len ( self . ffd_profiles [ gid ]))]) for cid , pro in enumerate ( self . ffd_profiles [ gid ]): ieq_1 = ( abs ( abs ( get_area ( pro )) - self . baseline_area ) / self . baseline_area - self . area_margin ) ieq_2 = self . penalty [ - 1 ] - self . simulator . df_dict [ gid ][ cid ][ self . penalty [ 0 ]] . iloc [ - 1 ] if ieq_1 > 0 or ieq_2 > 0 : logger . info ( f \"penalized candidate g { gid } , c { cid } \" f \"with area { abs ( get_area ( pro )) } \" f \"and CL { self . simulator . df_dict [ gid ][ cid ][ self . penalty [ 0 ]] . iloc [ - 1 ] } \" ) out . append ([ ieq_1 , ieq_2 ]) return np . row_stack ( out ) def _observe ( self , pop_fitness : np . ndarray ): \"\"\" **Plots** the n_plt best results each time a generation has been evaluated:</br> > the simulations residuals,</br> > the simulations CD & CL,</br> > the candidates fitness,</br> > the baseline and deformed profiles. \"\"\" gid = self . gen_ctr # extract generation best profiles sorted_idx = np . argsort ( pop_fitness , kind = \"stable\" )[: self . n_plt ] # compute population statistics self . compute_statistics ( pop_fitness ) logger . info ( f \"extracting { self . n_plt } best profiles in g { gid } : { sorted_idx } ..\" ) logger . debug ( f \"g { gid } J-fitnesses: { pop_fitness } \" ) # plot settings fig_name = f \"pymoo_g { gid } .png\" self . plot_generation ( gid , sorted_idx , pop_fitness , fig_name ) def final_observe ( self , * args , ** kwargs ): \"\"\" **Plots** convergence progress by plotting the fitness values obtained with the successive generations \"\"\" fig_name = f \"pymoo_optim_g { self . gen_ctr } _c { self . doe_size } .png\" self . plot_progress ( self . gen_ctr , fig_name , baseline_value = self . baseline_CD ) __init__ ( config : dict ) Instantiates the WolfOptimizer object. Input config (dict): the config file dictionary. Source code in aero_optim/optim/pymoo_optimizer.py 34 35 36 37 38 39 40 41 42 43 44 45 def __init__ ( self , config : dict ): \"\"\" Instantiates the WolfOptimizer object. **Input** - config (dict): the config file dictionary. \"\"\" WolfOptimizer . __init__ ( self , config ) Problem . __init__ ( self , n_var = self . n_design , n_obj = 1 , n_ieq_constr = 2 , xl = self . bound [ 0 ], xu = self . bound [ 1 ] ) _evaluate ( X : np . ndarray , out : np . ndarray , * args , ** kwargs ) Executes Wolf simulations, extracts results and returns arrays of candidates QoIs and constraints. Source code in aero_optim/optim/pymoo_optimizer.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def _evaluate ( self , X : np . ndarray , out : np . ndarray , * args , ** kwargs ): \"\"\" **Executes** Wolf simulations, **extracts** results and **returns** arrays of candidates QoIs and constraints. \"\"\" gid = self . gen_ctr # execute all candidates self . execute_candidates ( X , gid ) # update candidates fitness self . J . extend ([ self . simulator . df_dict [ gid ][ cid ][ self . QoI ] . iloc [ - 1 ] for cid in range ( len ( X )) ]) out [ \"F\" ] = np . array ( self . J [ - self . doe_size :]) out [ \"G\" ] = self . apply_constraints ( gid ) self . _observe ( out [ \"F\" ]) self . gen_ctr += 1 _observe ( pop_fitness : np . ndarray ) Plots the n_plt best results each time a generation has been evaluated: the simulations residuals, the simulations CD & CL, the candidates fitness, the baseline and deformed profiles. Source code in aero_optim/optim/pymoo_optimizer.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def _observe ( self , pop_fitness : np . ndarray ): \"\"\" **Plots** the n_plt best results each time a generation has been evaluated:</br> > the simulations residuals,</br> > the simulations CD & CL,</br> > the candidates fitness,</br> > the baseline and deformed profiles. \"\"\" gid = self . gen_ctr # extract generation best profiles sorted_idx = np . argsort ( pop_fitness , kind = \"stable\" )[: self . n_plt ] # compute population statistics self . compute_statistics ( pop_fitness ) logger . info ( f \"extracting { self . n_plt } best profiles in g { gid } : { sorted_idx } ..\" ) logger . debug ( f \"g { gid } J-fitnesses: { pop_fitness } \" ) # plot settings fig_name = f \"pymoo_g { gid } .png\" self . plot_generation ( gid , sorted_idx , pop_fitness , fig_name ) apply_constraints ( gid : int ) -> np . ndarray Returns a constraint array ensuring negative inequality see https://pymoo.org/constraints/index.html Source code in aero_optim/optim/pymoo_optimizer.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def apply_constraints ( self , gid : int ) -> np . ndarray : \"\"\" **Returns** a constraint array ensuring negative inequality</br> see https://pymoo.org/constraints/index.html \"\"\" out = [] if not self . constraint : return np . row_stack ([[ - 1 , - 1 ] for _ in range ( len ( self . ffd_profiles [ gid ]))]) for cid , pro in enumerate ( self . ffd_profiles [ gid ]): ieq_1 = ( abs ( abs ( get_area ( pro )) - self . baseline_area ) / self . baseline_area - self . area_margin ) ieq_2 = self . penalty [ - 1 ] - self . simulator . df_dict [ gid ][ cid ][ self . penalty [ 0 ]] . iloc [ - 1 ] if ieq_1 > 0 or ieq_2 > 0 : logger . info ( f \"penalized candidate g { gid } , c { cid } \" f \"with area { abs ( get_area ( pro )) } \" f \"and CL { self . simulator . df_dict [ gid ][ cid ][ self . penalty [ 0 ]] . iloc [ - 1 ] } \" ) out . append ([ ieq_1 , ieq_2 ]) return np . row_stack ( out ) final_observe ( * args , ** kwargs ) Plots convergence progress by plotting the fitness values obtained with the successive generations Source code in aero_optim/optim/pymoo_optimizer.py 110 111 112 113 114 115 116 def final_observe ( self , * args , ** kwargs ): \"\"\" **Plots** convergence progress by plotting the fitness values obtained with the successive generations \"\"\" fig_name = f \"pymoo_optim_g { self . gen_ctr } _c { self . doe_size } .png\" self . plot_progress ( self . gen_ctr , fig_name , baseline_value = self . baseline_CD ) optim.pymoo_optimizer.PymooDebugOptimizer Bases: DebugOptimizer , Problem Source code in aero_optim/optim/pymoo_optimizer.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 class PymooDebugOptimizer ( DebugOptimizer , Problem ): def __init__ ( self , config : dict ): \"\"\" Dummy init. \"\"\" DebugOptimizer . __init__ ( self , config ) Problem . __init__ ( self , n_var = self . n_design , n_obj = 1 , n_ieq_constr = 0 , xl = self . bound [ 0 ], xu = self . bound [ 1 ] ) def _evaluate ( self , X : np . ndarray , out : np . ndarray , * args , ** kwargs ): \"\"\" **Executes** dummy simulations, **extracts** results and **returns** the list of candidates QoIs. \"\"\" gid = self . gen_ctr # execute all candidates self . execute_candidates ( X , gid ) for cid , _ in enumerate ( X ): self . J . append ( self . simulator . df_dict [ gid ][ cid ][ \"result\" ] . iloc [ - 1 ]) out [ \"F\" ] = np . array ( self . J [ - self . doe_size :]) self . _observe ( out [ \"F\" ]) self . gen_ctr += 1 def _observe ( self , pop_fitness : np . ndarray ): \"\"\" Dummy _observe function. \"\"\" # extract best profiles gid = self . gen_ctr sorted_idx = np . argsort ( pop_fitness , kind = \"stable\" )[: self . n_plt ] logger . info ( f \"extracting { self . n_plt } best profiles in g { gid } : { sorted_idx } ..\" ) logger . debug ( f \"g { gid } J-fitnesses (candidates): { pop_fitness } \" ) # compute population statistics self . compute_statistics ( pop_fitness ) def final_observe ( self ): \"\"\" Dummy final_observe function. \"\"\" logger . info ( f \"plotting populations statistics after { self . gen_ctr } generations..\" ) fig_name = f \"pymoo_optim_g { self . gen_ctr } _c { self . doe_size } .png\" self . plot_progress ( self . gen_ctr , fig_name ) __init__ ( config : dict ) Dummy init. Source code in aero_optim/optim/pymoo_optimizer.py 209 210 211 212 213 214 215 216 def __init__ ( self , config : dict ): \"\"\" Dummy init. \"\"\" DebugOptimizer . __init__ ( self , config ) Problem . __init__ ( self , n_var = self . n_design , n_obj = 1 , n_ieq_constr = 0 , xl = self . bound [ 0 ], xu = self . bound [ 1 ] ) _evaluate ( X : np . ndarray , out : np . ndarray , * args , ** kwargs ) Executes dummy simulations, extracts results and returns the list of candidates QoIs. Source code in aero_optim/optim/pymoo_optimizer.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 def _evaluate ( self , X : np . ndarray , out : np . ndarray , * args , ** kwargs ): \"\"\" **Executes** dummy simulations, **extracts** results and **returns** the list of candidates QoIs. \"\"\" gid = self . gen_ctr # execute all candidates self . execute_candidates ( X , gid ) for cid , _ in enumerate ( X ): self . J . append ( self . simulator . df_dict [ gid ][ cid ][ \"result\" ] . iloc [ - 1 ]) out [ \"F\" ] = np . array ( self . J [ - self . doe_size :]) self . _observe ( out [ \"F\" ]) self . gen_ctr += 1 _observe ( pop_fitness : np . ndarray ) Dummy _observe function. Source code in aero_optim/optim/pymoo_optimizer.py 235 236 237 238 239 240 241 242 243 244 245 246 def _observe ( self , pop_fitness : np . ndarray ): \"\"\" Dummy _observe function. \"\"\" # extract best profiles gid = self . gen_ctr sorted_idx = np . argsort ( pop_fitness , kind = \"stable\" )[: self . n_plt ] logger . info ( f \"extracting { self . n_plt } best profiles in g { gid } : { sorted_idx } ..\" ) logger . debug ( f \"g { gid } J-fitnesses (candidates): { pop_fitness } \" ) # compute population statistics self . compute_statistics ( pop_fitness ) final_observe () Dummy final_observe function. Source code in aero_optim/optim/pymoo_optimizer.py 248 249 250 251 252 253 254 def final_observe ( self ): \"\"\" Dummy final_observe function. \"\"\" logger . info ( f \"plotting populations statistics after { self . gen_ctr } generations..\" ) fig_name = f \"pymoo_optim_g { self . gen_ctr } _c { self . doe_size } .png\" self . plot_progress ( self . gen_ctr , fig_name ) Generator class optim.generator.Generator This class defines a custom generator based on scipy.qmc samplers. Source code in aero_optim/optim/generator.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 class Generator : \"\"\" This class defines a custom generator based on scipy.qmc samplers. \"\"\" # some samplers available from scipy.qmc # see https://docs.scipy.org/doc/scipy/reference/stats.qmc.html sampler_list : list [ str ] = [ \"lhs\" , \"halton\" , \"sobol\" , \"custom\" ] def __init__ ( self , seed : int , ndesign : int , doe_size : int , sampler_name : str , bound : tuple [ Any , ... ], custom_doe : str = \"\" ): \"\"\" Instantiates the Generator class with some optimization parameters and the sampler name. **Input** - seed (int): seed number of the sampler random number generator. - ndesign (int): the number of design variables (dimensions of the problem). - doe_size (int): the size of the initial and subsequent generations. - sampler_name (str): name of the sampling algorithm used to generate samples. - bound (tuple[Any, ...]): design variables boundaries. - custom_doe (str): path to the text file containing a custom doe. **Inner** - initial_doe (list[list[float]]): the initial generation sampled from the generator. \"\"\" self . seed : int = seed self . ndesign : int = ndesign self . doe_size : int = doe_size self . sampler : Optional [ qmc . QMCEngine ] = self . get_sampler ( \"custom\" if custom_doe else sampler_name ) self . bound : tuple [ Any , ... ] = bound self . initial_doe : list [ list [ float ]] = self . sample_doe ( custom_doe ) def get_sampler ( self , sampler_name : str ) -> Optional [ qmc . QMCEngine ]: \"\"\" **Returns** scipy qmc sampler. \"\"\" if sampler_name not in self . sampler_list : raise Exception ( f \"Unrecognized sampler { sampler_name } \" ) else : return ( qmc . LatinHypercube ( d = self . ndesign , seed = self . seed ) if sampler_name == \"lhs\" else qmc . Halton ( d = self . ndesign , seed = self . seed ) if sampler_name == \"halton\" else qmc . Sobol ( d = self . ndesign , seed = self . seed ) if sampler_name == \"sobol\" else None ) def sample_doe ( self , custom_doe : str ) -> list [ list [ float ]]: return ( self . sampler . random ( n = self . doe_size ) . tolist () if self . sampler else [ [ float ( xi ) for xi in X . strip () . split ()] for X in open ( custom_doe , \"r\" ) . read () . splitlines () ] ) def _ins_generator ( self , random : Random , args : dict ) -> list [ float ]: \"\"\" **Returns** a single sample from the initial generation. Note: __random__ and __args__ are inspyred mandatory arguments</br> see https://pythonhosted.org/inspyred/tutorial.html#the-generator \"\"\" element = self . initial_doe . pop ( 0 ) return qmc . scale ([ element ], * self . bound ) . tolist ()[ 0 ] if self . sampler else element def _pymoo_generator ( self ) -> np . ndarray : \"\"\" **Returns** all samples from the initial generation. \"\"\" return ( qmc . scale ( self . initial_doe , * self . bound ) if self . sampler else np . array ( self . initial_doe ) ) __init__ ( seed : int , ndesign : int , doe_size : int , sampler_name : str , bound : tuple [ Any , ... ], custom_doe : str = '' ) Instantiates the Generator class with some optimization parameters and the sampler name. Input seed (int): seed number of the sampler random number generator. ndesign (int): the number of design variables (dimensions of the problem). doe_size (int): the size of the initial and subsequent generations. sampler_name (str): name of the sampling algorithm used to generate samples. bound (tuple[Any, ...]): design variables boundaries. custom_doe (str): path to the text file containing a custom doe. Inner initial_doe (list[list[float]]): the initial generation sampled from the generator. Source code in aero_optim/optim/generator.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def __init__ ( self , seed : int , ndesign : int , doe_size : int , sampler_name : str , bound : tuple [ Any , ... ], custom_doe : str = \"\" ): \"\"\" Instantiates the Generator class with some optimization parameters and the sampler name. **Input** - seed (int): seed number of the sampler random number generator. - ndesign (int): the number of design variables (dimensions of the problem). - doe_size (int): the size of the initial and subsequent generations. - sampler_name (str): name of the sampling algorithm used to generate samples. - bound (tuple[Any, ...]): design variables boundaries. - custom_doe (str): path to the text file containing a custom doe. **Inner** - initial_doe (list[list[float]]): the initial generation sampled from the generator. \"\"\" self . seed : int = seed self . ndesign : int = ndesign self . doe_size : int = doe_size self . sampler : Optional [ qmc . QMCEngine ] = self . get_sampler ( \"custom\" if custom_doe else sampler_name ) self . bound : tuple [ Any , ... ] = bound self . initial_doe : list [ list [ float ]] = self . sample_doe ( custom_doe ) _ins_generator ( random : Random , args : dict ) -> list [ float ] Returns a single sample from the initial generation. Note random and args are inspyred mandatory arguments see https://pythonhosted.org/inspyred/tutorial.html#the-generator Source code in aero_optim/optim/generator.py 71 72 73 74 75 76 77 78 79 80 def _ins_generator ( self , random : Random , args : dict ) -> list [ float ]: \"\"\" **Returns** a single sample from the initial generation. Note: __random__ and __args__ are inspyred mandatory arguments</br> see https://pythonhosted.org/inspyred/tutorial.html#the-generator \"\"\" element = self . initial_doe . pop ( 0 ) return qmc . scale ([ element ], * self . bound ) . tolist ()[ 0 ] if self . sampler else element _pymoo_generator () -> np . ndarray Returns all samples from the initial generation. Source code in aero_optim/optim/generator.py 82 83 84 85 86 87 88 def _pymoo_generator ( self ) -> np . ndarray : \"\"\" **Returns** all samples from the initial generation. \"\"\" return ( qmc . scale ( self . initial_doe , * self . bound ) if self . sampler else np . array ( self . initial_doe ) ) get_sampler ( sampler_name : str ) -> Optional [ qmc . QMCEngine ] Returns scipy qmc sampler. Source code in aero_optim/optim/generator.py 48 49 50 51 52 53 54 55 56 57 58 59 60 def get_sampler ( self , sampler_name : str ) -> Optional [ qmc . QMCEngine ]: \"\"\" **Returns** scipy qmc sampler. \"\"\" if sampler_name not in self . sampler_list : raise Exception ( f \"Unrecognized sampler { sampler_name } \" ) else : return ( qmc . LatinHypercube ( d = self . ndesign , seed = self . seed ) if sampler_name == \"lhs\" else qmc . Halton ( d = self . ndesign , seed = self . seed ) if sampler_name == \"halton\" else qmc . Sobol ( d = self . ndesign , seed = self . seed ) if sampler_name == \"sobol\" else None )","title":"Evolution and Optimizer Modules"},{"location":"dev_optimizer/#evolution-and-optimizer-source-code","text":"","title":"Evolution and Optimizer Source Code"},{"location":"dev_optimizer/#evolution-classes","text":"","title":"Evolution classes"},{"location":"dev_optimizer/#optim.evolution.Evolution","text":"Bases: ABC This class implements an abstract evolution object. Source code in aero_optim/optim/evolution.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 class Evolution ( ABC ): \"\"\" This class implements an abstract evolution object. \"\"\" def __init__ ( self , config : dict , debug : bool ): self . custom_file : str = config [ \"study\" ] . get ( \"custom_file\" , \"\" ) self . set_optimizer ( debug = debug ) self . optimizer : Type [ Optimizer ] = self . OptimizerClass ( config ) self . set_ea () @abstractmethod def set_optimizer ( self , * args , ** kwargs ): \"\"\" Sets the optimizer object. \"\"\" self . OptimizerClass = ( get_custom_class ( self . custom_file , \"CustomOptimizer\" ) if self . custom_file else None ) @abstractmethod def set_ea ( self , * args , ** kwargs ): \"\"\" Sets the evolutionary computation algorithm. \"\"\" @abstractmethod def evolve ( self , * args , ** kwargs ): \"\"\" Defines how to execute the optimization. \"\"\"","title":"Evolution"},{"location":"dev_optimizer/#optim.evolution.Evolution.evolve","text":"Defines how to execute the optimization. Source code in aero_optim/optim/evolution.py 49 50 51 52 53 @abstractmethod def evolve ( self , * args , ** kwargs ): \"\"\" Defines how to execute the optimization. \"\"\"","title":"evolve"},{"location":"dev_optimizer/#optim.evolution.Evolution.set_ea","text":"Sets the evolutionary computation algorithm. Source code in aero_optim/optim/evolution.py 43 44 45 46 47 @abstractmethod def set_ea ( self , * args , ** kwargs ): \"\"\" Sets the evolutionary computation algorithm. \"\"\"","title":"set_ea"},{"location":"dev_optimizer/#optim.evolution.Evolution.set_optimizer","text":"Sets the optimizer object. Source code in aero_optim/optim/evolution.py 34 35 36 37 38 39 40 41 @abstractmethod def set_optimizer ( self , * args , ** kwargs ): \"\"\" Sets the optimizer object. \"\"\" self . OptimizerClass = ( get_custom_class ( self . custom_file , \"CustomOptimizer\" ) if self . custom_file else None )","title":"set_optimizer"},{"location":"dev_optimizer/#inspyred-evolution","text":"","title":"inspyred Evolution"},{"location":"dev_optimizer/#optim.evolution.InspyredEvolution","text":"Bases: Evolution This class implements a default inspyred based evolution object. Source code in aero_optim/optim/evolution.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 class InspyredEvolution ( Evolution ): \"\"\" This class implements a default inspyred based evolution object. \"\"\" def __init__ ( self , config : dict , debug : bool = False ): super () . __init__ ( config , debug ) self . algorithm . observer = self . optimizer . _observe self . algorithm . terminator = terminators . generation_termination def set_optimizer ( self , debug : bool = False ): \"\"\" **Instantiates** the optimizer attribute as custom if any or from default classes. \"\"\" super () . set_optimizer () if not self . OptimizerClass : if debug : self . OptimizerClass = InspyredDebugOptimizer else : self . OptimizerClass = InspyredWolfOptimizer logger . info ( f \"optimizer set to { self . OptimizerClass } \" ) def set_ea ( self ): \"\"\" **Instantiates** the default algorithm attribute. \"\"\" self . algorithm = inspyred_select_strategy ( self . optimizer . strategy , self . optimizer . prng ) def evolve ( self ): \"\"\" **Executes** the default evolution method. \"\"\" final_pop = self . algorithm . evolve ( generator = self . optimizer . generator . _ins_generator , evaluator = self . optimizer . _evaluate , pop_size = self . optimizer . doe_size , max_generations = self . optimizer . max_generations , bounder = Bounder ( * self . optimizer . bound ), maximize = self . optimizer . maximize , ** self . optimizer . ea_kwargs ) self . optimizer . final_observe () # output results best = max ( final_pop ) index , opt_J = ( max ( enumerate ( self . optimizer . J ), key = ope . itemgetter ( 1 )) if self . optimizer . maximize else min ( enumerate ( self . optimizer . J ), key = ope . itemgetter ( 1 )) ) gid , cid = ( index // self . optimizer . doe_size , index % self . optimizer . doe_size ) logger . info ( f \"optimal J: { opt_J } (J_ins: { best . fitness } ), \\n \" f \"D: { ' ' . join ([ str ( d ) for d in self . optimizer . inputs [ gid ][ cid ]]) } \\n \" f \"D_ins: { ' ' . join ([ str ( d ) for d in best . candidate [: self . optimizer . n_design ]]) } \" f \" \\n [g { gid } , c { cid } ]\" )","title":"InspyredEvolution"},{"location":"dev_optimizer/#optim.evolution.InspyredEvolution.evolve","text":"Executes the default evolution method. Source code in aero_optim/optim/evolution.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def evolve ( self ): \"\"\" **Executes** the default evolution method. \"\"\" final_pop = self . algorithm . evolve ( generator = self . optimizer . generator . _ins_generator , evaluator = self . optimizer . _evaluate , pop_size = self . optimizer . doe_size , max_generations = self . optimizer . max_generations , bounder = Bounder ( * self . optimizer . bound ), maximize = self . optimizer . maximize , ** self . optimizer . ea_kwargs ) self . optimizer . final_observe () # output results best = max ( final_pop ) index , opt_J = ( max ( enumerate ( self . optimizer . J ), key = ope . itemgetter ( 1 )) if self . optimizer . maximize else min ( enumerate ( self . optimizer . J ), key = ope . itemgetter ( 1 )) ) gid , cid = ( index // self . optimizer . doe_size , index % self . optimizer . doe_size ) logger . info ( f \"optimal J: { opt_J } (J_ins: { best . fitness } ), \\n \" f \"D: { ' ' . join ([ str ( d ) for d in self . optimizer . inputs [ gid ][ cid ]]) } \\n \" f \"D_ins: { ' ' . join ([ str ( d ) for d in best . candidate [: self . optimizer . n_design ]]) } \" f \" \\n [g { gid } , c { cid } ]\" )","title":"evolve"},{"location":"dev_optimizer/#optim.evolution.InspyredEvolution.set_ea","text":"Instantiates the default algorithm attribute. Source code in aero_optim/optim/evolution.py 129 130 131 132 133 def set_ea ( self ): \"\"\" **Instantiates** the default algorithm attribute. \"\"\" self . algorithm = inspyred_select_strategy ( self . optimizer . strategy , self . optimizer . prng )","title":"set_ea"},{"location":"dev_optimizer/#optim.evolution.InspyredEvolution.set_optimizer","text":"Instantiates the optimizer attribute as custom if any or from default classes. Source code in aero_optim/optim/evolution.py 117 118 119 120 121 122 123 124 125 126 127 def set_optimizer ( self , debug : bool = False ): \"\"\" **Instantiates** the optimizer attribute as custom if any or from default classes. \"\"\" super () . set_optimizer () if not self . OptimizerClass : if debug : self . OptimizerClass = InspyredDebugOptimizer else : self . OptimizerClass = InspyredWolfOptimizer logger . info ( f \"optimizer set to { self . OptimizerClass } \" )","title":"set_optimizer"},{"location":"dev_optimizer/#pymoo-evolution","text":"","title":"pymoo Evolution"},{"location":"dev_optimizer/#optim.evolution.PymooEvolution","text":"Bases: Evolution This class implements a default pymoo based evolution object. Source code in aero_optim/optim/evolution.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 class PymooEvolution ( Evolution ): \"\"\" This class implements a default pymoo based evolution object. \"\"\" def __init__ ( self , config : dict , debug : bool = False ): super () . __init__ ( config , debug ) def set_optimizer ( self , debug : bool = False ): \"\"\" **Instantiates** the optimizer attribute as custom if any or from default classes. \"\"\" super () . set_optimizer () if not self . OptimizerClass : if debug : self . OptimizerClass = PymooDebugOptimizer else : self . OptimizerClass = PymooWolfOptimizer logger . info ( f \"optimizer set to { self . OptimizerClass } \" ) def set_ea ( self ): \"\"\" **Instantiates** the default algorithm attribute. \"\"\" self . algorithm = pymoo_select_strategy ( self . optimizer . strategy , self . optimizer . doe_size , self . optimizer . generator . _pymoo_generator (), self . optimizer . ea_kwargs ) def evolve ( self ): \"\"\" **Executes** the default evolution method. \"\"\" res = minimize ( problem = self . optimizer , algorithm = self . algorithm , termination = get_termination ( \"n_gen\" , self . optimizer . max_generations ), seed = self . optimizer . seed , verbose = True ) self . optimizer . final_observe () # output results best = res . F index , opt_J = min ( enumerate ( self . optimizer . J ), key = lambda x : abs ( best - x [ 1 ])) gid , cid = ( index // self . optimizer . doe_size , index % self . optimizer . doe_size ) logger . info ( f \"optimal J: { opt_J } (J_pymoo: { best } ), \\n \" f \"D: { ' ' . join ([ str ( d ) for d in self . optimizer . inputs [ gid ][ cid ]]) } \\n \" f \"D_pymoo: { ' ' . join ([ str ( d ) for d in res . X ]) } \\n \" f \"[g { gid } , c { cid } ]\" )","title":"PymooEvolution"},{"location":"dev_optimizer/#optim.evolution.PymooEvolution.evolve","text":"Executes the default evolution method. Source code in aero_optim/optim/evolution.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def evolve ( self ): \"\"\" **Executes** the default evolution method. \"\"\" res = minimize ( problem = self . optimizer , algorithm = self . algorithm , termination = get_termination ( \"n_gen\" , self . optimizer . max_generations ), seed = self . optimizer . seed , verbose = True ) self . optimizer . final_observe () # output results best = res . F index , opt_J = min ( enumerate ( self . optimizer . J ), key = lambda x : abs ( best - x [ 1 ])) gid , cid = ( index // self . optimizer . doe_size , index % self . optimizer . doe_size ) logger . info ( f \"optimal J: { opt_J } (J_pymoo: { best } ), \\n \" f \"D: { ' ' . join ([ str ( d ) for d in self . optimizer . inputs [ gid ][ cid ]]) } \\n \" f \"D_pymoo: { ' ' . join ([ str ( d ) for d in res . X ]) } \\n \" f \"[g { gid } , c { cid } ]\" )","title":"evolve"},{"location":"dev_optimizer/#optim.evolution.PymooEvolution.set_ea","text":"Instantiates the default algorithm attribute. Source code in aero_optim/optim/evolution.py 75 76 77 78 79 80 81 82 83 84 def set_ea ( self ): \"\"\" **Instantiates** the default algorithm attribute. \"\"\" self . algorithm = pymoo_select_strategy ( self . optimizer . strategy , self . optimizer . doe_size , self . optimizer . generator . _pymoo_generator (), self . optimizer . ea_kwargs )","title":"set_ea"},{"location":"dev_optimizer/#optim.evolution.PymooEvolution.set_optimizer","text":"Instantiates the optimizer attribute as custom if any or from default classes. Source code in aero_optim/optim/evolution.py 63 64 65 66 67 68 69 70 71 72 73 def set_optimizer ( self , debug : bool = False ): \"\"\" **Instantiates** the optimizer attribute as custom if any or from default classes. \"\"\" super () . set_optimizer () if not self . OptimizerClass : if debug : self . OptimizerClass = PymooDebugOptimizer else : self . OptimizerClass = PymooWolfOptimizer logger . info ( f \"optimizer set to { self . OptimizerClass } \" )","title":"set_optimizer"},{"location":"dev_optimizer/#optimizer-classes","text":"","title":"Optimizer classes"},{"location":"dev_optimizer/#optim.optimizer.Optimizer","text":"Bases: ABC This class implements an abstract optimizer. Source code in aero_optim/optim/optimizer.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 class Optimizer ( ABC ): \"\"\" This class implements an abstract optimizer. \"\"\" def __init__ ( self , config : dict , debug : bool = False ): \"\"\" Instantiates the Optimizer object. **Input** - config (dict): the config file dictionary. - debug (bool): skip FFD and Mesh objects instantation for debugging purposes. **Inner** - n_design (int): the number of design variables (dimensions of the problem). - doe_size (int): the size of the initial and subsequent generations. - max_generations (int): the number of generations before termination. - dat_file (str): path to input_geometry.dat (baseline geometry). - outdir (str): highest level optimization output directory. Note: the result folder tree is structured as follows: ``` outdir |__ FFD (contains <geom>_gXX_cYY.dat) |__ Figs (contains the figures generated during the optimization) |__ MESH (contains <geom>_gXX_cYY.mesh, .log, .geo_unrolled) |__ SOLVER |__ solver_gXX_cYY (contains the results of each simulation) ``` - study_type (str): use-case/meshing routine. - ffd_type (str): deformation method. - strategy (str): the optimization algorithm amongst inspyred's [ES, PSO] and pymoo's [GA, PSO]</br> see https://pythonhosted.org/inspyred/examples.html#standard-algorithms</br> and https://pymoo.org/algorithms/list.html#nb-algorithms-list - maximize (bool): whether to maximize or minimize the objective QoIs. - budget (int): maximum number of concurrent proc in use. - nproc_per_sim (int): number of proc per simulation. - bound (tuple[float]): design variables boundaries. - custom_doe (str): path to a custom doe. - sampler_name (str): name of the sampling algorithm used to generate samples. the initial generation. - seed (int): seed number of the random processes involved in the optimization. - prng (random.Random): pseudo-random generator passed to inspyred generator. - ea_kwargs (dict): additional arguments to be passed to the evolution algorithm. - gen_ctr (int): generation counter. - generator (Generator): Generator object for the initial generation sampling. - ffd (FFD_2D): FFD_2D object to generate deformed geometries. - gmsh_mesh (Mesh): Mesh class to generate deformed geometries meshes. - simulator (Simulator): Simulator object to perform simulations. - mean (list[float]): list of populations mean fitness. - median (list[float]): list of populations median fitness. - max (list[float]): list of populations max fitness. - min (list[float]): list of populations min fitness. - J (list[float | list[float]]): the list of all generated candidates fitnesses. - inputs (list[list[np.ndarray]]): all input candidates. - ffd_profiles (list[list[np.ndarray]]): all deformed geometries {gid: {cid: ffd_profile}}. - QoI (str): the quantity of intereset to minimize/maximize. - n_plt (int): the number of best candidates results to display after each evaluation. - cmap (str): the colormaps used for the observer plot</br> see https://matplotlib.org/stable/users/explain/colors/colormaps.html. \"\"\" self . config = config self . process_config () # required entries self . n_design : int = config [ \"optim\" ][ \"n_design\" ] self . doe_size : int = config [ \"optim\" ][ \"doe_size\" ] self . max_generations : int = config [ \"optim\" ][ \"max_generations\" ] self . dat_file : str = config [ \"study\" ][ \"file\" ] self . outdir : str = config [ \"study\" ][ \"outdir\" ] self . study_type : str = config [ \"study\" ][ \"study_type\" ] # optional entries self . ffd_type : str = config [ \"study\" ] . get ( \"ffd_type\" , \"\" ) self . custom_file : str = config [ \"study\" ] . get ( \"custom_file\" , \"\" ) self . strategy : str = config [ \"optim\" ] . get ( \"strategy\" , \"PSO\" ) self . maximize : bool = config [ \"optim\" ] . get ( \"maximize\" , False ) self . budget : int = config [ \"optim\" ] . get ( \"budget\" , 4 ) self . nproc_per_sim : int = config [ \"optim\" ] . get ( \"nproc_per_sim\" , 1 ) self . bound : tuple [ Any , ... ] = tuple ( config [ \"optim\" ] . get ( \"bound\" , [ - 1 , 1 ])) self . custom_doe : str = config [ \"optim\" ] . get ( \"custom_doe\" , \"\" ) self . sampler_name : str = config [ \"optim\" ] . get ( \"sampler_name\" , \"lhs\" ) self . ea_kwargs : dict = config [ \"optim\" ] . get ( \"ea_kwargs\" , {}) # reproducibility variables self . seed : int = config [ \"optim\" ] . get ( \"seed\" , 123 ) self . prng : Random = Random () self . prng . seed ( self . seed ) # generation counter self . gen_ctr : int = 0 # optimization objects if not debug : self . set_ffd_class () self . set_gmsh_mesh_class () self . generator : Generator = Generator ( self . seed , self . n_design , self . doe_size , self . sampler_name , self . bound , self . custom_doe ) self . set_simulator_class () self . simulator = self . SimulatorClass ( self . config ) # population statistics self . mean : list [ float ] = [] self . median : list [ float ] = [] self . max : list [ float ] = [] self . min : list [ float ] = [] # set other inner optimization variables self . J : list [ float | list [ float ]] = [] self . inputs : list [ list [ np . ndarray ]] = [] self . ffd_profiles : list [ list [ np . ndarray ]] = [] self . QoI : str = self . config [ \"optim\" ] . get ( \"QoI\" , \"CD\" ) self . n_plt : int = self . config [ \"optim\" ] . get ( \"n_plt\" , 5 ) self . cmap : str = self . config [ \"optim\" ] . get ( \"cmap\" , \"viridis\" ) self . set_inner () # figure directory self . figdir : str = os . path . join ( self . outdir , \"Figs\" ) check_dir ( self . figdir ) def process_config ( self ): \"\"\" **Makes sure** the config file contains the required information. \"\"\" logger . info ( \"processing config..\" ) if \"n_design\" not in self . config [ \"optim\" ]: raise Exception ( f \"ERROR -- no <n_design> entry in { self . config [ 'optim' ] } \" ) if \"doe_size\" not in self . config [ \"optim\" ]: raise Exception ( f \"ERROR -- no <doe_size> entry in { self . config [ 'optim' ] } \" ) if \"max_generations\" not in self . config [ \"optim\" ]: raise Exception ( f \"ERROR -- no <max_generations> entry in { self . config [ 'optim' ] } \" ) if \"file\" not in self . config [ \"study\" ]: raise Exception ( f \"ERROR -- no <file> entry in { self . config [ 'study' ] } \" ) if \"budget\" not in self . config [ \"optim\" ]: logger . warning ( f \"no <budget> entry in { self . config [ 'optim' ] } \" ) if \"nproc_per_sim\" not in self . config [ \"optim\" ]: logger . warning ( f \"no <nproc_per_sim> entry in { self . config [ 'optim' ] } \" ) if \"bound\" not in self . config [ \"optim\" ]: logger . warning ( f \"no <bound> entry in { self . config [ 'optim' ] } \" ) if \"sampler_name\" not in self . config [ \"optim\" ]: logger . warning ( f \"no <sampler_name> entry in { self . config [ 'optim' ] } \" ) if \"seed\" not in self . config [ \"optim\" ]: logger . warning ( f \"no <seed> entry in { self . config [ 'optim' ] } \" ) # alter config for optimization purposes if \"outfile\" in self . config [ \"study\" ]: logger . warning ( f \"<outfile> entry in { self . config [ 'study' ] } will be ignored\" ) del self . config [ \"study\" ][ \"outfile\" ] if \"view\" in self . config [ \"gmsh\" ] and \"GUI\" in self . config [ \"gmsh\" ][ \"view\" ]: logger . warning ( f \"<GUI> entry in { self . config [ 'gmsh' ][ 'view' ] } forced to False\" ) self . config [ \"gmsh\" ][ \"view\" ][ \"GUI\" ] = False def set_ffd_class ( self ): \"\"\" **Instantiates** the deformation class and object as custom if found, as one of the default classes otherwise. \"\"\" self . FFDClass = ( get_custom_class ( self . custom_file , \"CustomFFD\" ) if self . custom_file else None ) ffd_config = self . config . get ( \"ffd\" , {}) rotation = ffd_config . get ( \"rotation\" , False ) if not self . FFDClass : # standard FFD 2D if self . ffd_type == FFD_TYPE [ 0 ]: self . FFDClass = FFD_2D self . ffd = self . FFDClass ( self . dat_file , self . n_design // 2 , ** ffd_config ) # POD coupled FFD 2D elif self . ffd_type == FFD_TYPE [ 1 ]: self . FFDClass = FFD_POD_2D ffd_config [ \"ffd_ncontrol\" ] = self . n_design ffd_config [ \"ffd_bound\" ] = self . bound logger . info ( f \"ffd bound: { self . bound } \" ) self . ffd = self . FFDClass ( self . dat_file , ** ffd_config ) self . n_design = ffd_config [ \"pod_ncontrol\" ] self . bound = ffd_config . get ( \"pod_bound\" , self . ffd . get_bound ()) logger . info ( f \"pod bound: { self . bound } \" ) else : raise Exception ( f \"ERROR -- incorrect ffd_type < { self . ffd_type } >\" ) else : self . ffd = self . FFDClass ( self . dat_file , self . n_design , ** ffd_config ) # rotation wrapper if rotation : logger . info ( f \"rotation: { rotation } \" ) self . ffd = RotationWrapper ( self . ffd ) rot_bound = ffd_config . get ( \"rot_bound\" , [ - 1 , 1 ]) # convert bound from tuple of floats to tuple of lists if not isinstance ( self . bound [ 0 ], list ): self . bound = ([ self . bound [ 0 ]] * self . n_design , [ self . bound [ - 1 ]] * self . n_design ) self . bound = ( self . bound [ 0 ] + [ rot_bound [ 0 ]], self . bound [ - 1 ] + [ rot_bound [ - 1 ]]) self . n_design += 1 logger . info ( f \"effective n_design: { self . n_design } \" ) def set_gmsh_mesh_class ( self ): \"\"\" **Instantiates** the mesher class as custom if found, as one of the default meshers otherwise. \"\"\" self . MeshClass = ( get_custom_class ( self . custom_file , \"CustomMesh\" ) if self . custom_file else None ) if not self . MeshClass : if self . study_type == STUDY_TYPE [ 0 ]: self . MeshClass = NACABaseMesh elif self . study_type == STUDY_TYPE [ 1 ]: self . MeshClass = NACABlockMesh elif self . study_type == STUDY_TYPE [ 2 ]: self . MeshClass = CascadeMesh elif self . study_type == STUDY_TYPE [ 3 ]: self . MeshClass = MeshMusicaa else : raise Exception ( f \"ERROR -- incorrect study_type < { self . study_type } >\" ) def set_inner ( self ): \"\"\" **Sets** some use-case specific inner variables: \"\"\" logger . info ( \"set_inner not implemented\" ) def deform ( self , Delta : np . ndarray , gid : int , cid : int ) -> tuple [ str , np . ndarray ]: \"\"\" **Applies** FFD on a given candidate and returns its resulting file. \"\"\" ffd_dir = os . path . join ( self . outdir , \"FFD\" ) check_dir ( ffd_dir ) logger . info ( f \"g { gid } , c { cid } generate profile with deformation { Delta } \" ) profile : np . ndarray = self . ffd . apply_ffd ( Delta ) return self . ffd . write_ffd ( profile , Delta , ffd_dir , gid = gid , cid = cid ), profile def mesh ( self , ffdfile : str ) -> str : \"\"\" **Builds** mesh for a given candidate and returns its resulting file. Note: if a mesh file matching the pattern name already exists, it is not rebuilt. \"\"\" mesh_dir = os . path . join ( self . outdir , \"MESH\" ) check_dir ( mesh_dir ) gmsh_mesh = self . MeshClass ( self . config , ffdfile ) if os . path . isfile ( gmsh_mesh . get_meshfile ( mesh_dir )): return gmsh_mesh . get_meshfile ( mesh_dir ) gmsh_mesh . build_mesh () return gmsh_mesh . write_mesh ( mesh_dir ) def execute_candidates ( self , candidates : list [ Individual ] | np . ndarray , gid : int ): \"\"\" **Executes** all candidates and **waits** for them to finish. Note: this method is meant to be called in _evaluate. \"\"\" logger . info ( f \"evaluating candidates of generation { self . gen_ctr } ..\" ) self . ffd_profiles . append ([]) self . inputs . append ([]) for cid , cand in enumerate ( candidates ): self . inputs [ gid ] . append ( np . array ( cand )) ffd_file , ffd_profile = self . deform ( cand , gid , cid ) self . ffd_profiles [ gid ] . append ( ffd_profile ) # meshing with proper sigint management # see https://gitlab.onelab.info/gmsh/gmsh/-/issues/842 ORIGINAL_SIGINT_HANDLER = signal . signal ( signal . SIGINT , signal . SIG_DFL ) mesh_file = self . mesh ( ffd_file ) signal . signal ( signal . SIGINT , ORIGINAL_SIGINT_HANDLER ) while self . simulator . monitor_sim_progress () * self . nproc_per_sim >= self . budget : time . sleep ( 1 ) self . simulator . execute_sim ( meshfile = mesh_file , gid = gid , cid = cid ) # wait for last candidates to finish while self . simulator . monitor_sim_progress () > 0 : time . sleep ( 0.1 ) def compute_statistics ( self , gen_fitness : np . ndarray ): \"\"\" **Computes** generation statistics. Note: this method is meant to be called in `_observe`. \"\"\" self . mean . append ( np . mean ( gen_fitness )) self . median . append ( np . median ( gen_fitness )) self . min . append ( min ( gen_fitness )) self . max . append ( max ( gen_fitness )) def _observe ( self , * args , ** kwargs ): \"\"\" **Plots** generation data after each evaluation. \"\"\" logger . info ( \"_observe not implemented\" ) def plot_generation ( self , gid : int , sorted_idx : np . ndarray , gen_fitness : np . ndarray , fig_name : str ): \"\"\" **Plots** the results of the last evaluated generation. **Saves** the graph in the output directory. Note: this method is meant to be called in `_observe`. \"\"\" logger . info ( \"plot_generation not implemented\" ) def plot_progress ( self , gen_nbr : int , fig_name : str , baseline_value : float | None = None ): \"\"\" **Plots** and **saves** the overall progress of the optimization. Note: this method is meant to be called in `final_observe`. \"\"\" logger . info ( f \"plotting populations statistics after { gen_nbr } generations..\" ) # plot construction _ , ax = plt . subplots ( figsize = ( 8 , 8 )) psize = self . doe_size if baseline_value : ax . axhline ( y = baseline_value , color = 'k' , ls = \"--\" , label = \"baseline\" ) # plotting data best = self . max if self . maximize else self . min worst = self . min if self . maximize else self . max data = [ self . mean , self . median , best , worst ] colors = [ \"grey\" , \"blue\" , \"green\" , \"red\" ] labels = [ \"mean\" , \"median\" , \"best\" , \"worst\" ] for val , col , lab in zip ( data , colors , labels ): ax . plot ( range ( self . gen_ctr ), val , color = col , label = lab ) plt . fill_between ( range ( self . gen_ctr ), data [ 2 ], data [ 3 ], color = '#e6f2e6' ) plt . grid ( True ) ymin = min ([ min ( d ) for d in data ]) ymax = max ([ max ( d ) for d in data ]) yrange = ymax - ymin plt . ylim (( ymin - 0.1 * yrange , ymax + 0.1 * yrange )) ax . xaxis . set_major_locator ( MaxNLocator ( integer = True )) # legend and title ax . set_title ( f \"Optimization evolution ( { gen_nbr } g. x { psize } c.)\" ) ax . legend ( loc = \"center left\" , bbox_to_anchor = ( 1 , 0.5 )) ax . set_xlabel ( 'generation $[ \\\\ cdot]$' ) ax . set_ylabel ( 'fitness' ) # save figure as png logger . info ( f \"saving { fig_name } to { self . outdir } \" ) plt . savefig ( os . path . join ( self . outdir , fig_name ), bbox_inches = 'tight' ) plt . close () def save_results ( self ): \"\"\" **Saves** candidates and fitnesses to file. \"\"\" logger . info ( f \"optimization results saved to { self . outdir } \" ) np . savetxt ( os . path . join ( self . outdir , \"candidates.txt\" ), np . reshape ( self . inputs , ( - 1 , self . n_design )) ) np . savetxt ( os . path . join ( self . outdir , \"fitnesses.txt\" ), self . J ) @abstractmethod def set_simulator_class ( self ): \"\"\" Instantiates the simulator class with CustomSimulator if found. \"\"\" self . SimulatorClass = ( get_custom_class ( self . custom_file , \"CustomSimulator\" ) if self . custom_file else None ) @abstractmethod def _evaluate ( self , * args , ** kwargs ) -> list [ float | list [ float ]] | None : \"\"\" Computes all candidates outputs and return the optimizer list of QoIs. \"\"\"","title":"Optimizer"},{"location":"dev_optimizer/#optim.optimizer.Optimizer.__init__","text":"Instantiates the Optimizer object. Input config (dict): the config file dictionary. debug (bool): skip FFD and Mesh objects instantation for debugging purposes. Inner n_design (int): the number of design variables (dimensions of the problem). doe_size (int): the size of the initial and subsequent generations. max_generations (int): the number of generations before termination. dat_file (str): path to input_geometry.dat (baseline geometry). outdir (str): highest level optimization output directory. Note the result folder tree is structured as follows: outdir |__ FFD (contains <geom>_gXX_cYY.dat) |__ Figs (contains the figures generated during the optimization) |__ MESH (contains <geom>_gXX_cYY.mesh, .log, .geo_unrolled) |__ SOLVER |__ solver_gXX_cYY (contains the results of each simulation) study_type (str): use-case/meshing routine. ffd_type (str): deformation method. strategy (str): the optimization algorithm amongst inspyred's [ES, PSO] and pymoo's [GA, PSO] see https://pythonhosted.org/inspyred/examples.html#standard-algorithms and https://pymoo.org/algorithms/list.html#nb-algorithms-list maximize (bool): whether to maximize or minimize the objective QoIs. budget (int): maximum number of concurrent proc in use. nproc_per_sim (int): number of proc per simulation. bound (tuple[float]): design variables boundaries. custom_doe (str): path to a custom doe. sampler_name (str): name of the sampling algorithm used to generate samples. the initial generation. seed (int): seed number of the random processes involved in the optimization. prng (random.Random): pseudo-random generator passed to inspyred generator. ea_kwargs (dict): additional arguments to be passed to the evolution algorithm. gen_ctr (int): generation counter. generator (Generator): Generator object for the initial generation sampling. ffd (FFD_2D): FFD_2D object to generate deformed geometries. gmsh_mesh (Mesh): Mesh class to generate deformed geometries meshes. simulator (Simulator): Simulator object to perform simulations. mean (list[float]): list of populations mean fitness. median (list[float]): list of populations median fitness. max (list[float]): list of populations max fitness. min (list[float]): list of populations min fitness. J (list[float | list[float]]): the list of all generated candidates fitnesses. inputs (list[list[np.ndarray]]): all input candidates. ffd_profiles (list[list[np.ndarray]]): all deformed geometries {gid: {cid: ffd_profile}}. QoI (str): the quantity of intereset to minimize/maximize. n_plt (int): the number of best candidates results to display after each evaluation. cmap (str): the colormaps used for the observer plot see https://matplotlib.org/stable/users/explain/colors/colormaps.html. Source code in aero_optim/optim/optimizer.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def __init__ ( self , config : dict , debug : bool = False ): \"\"\" Instantiates the Optimizer object. **Input** - config (dict): the config file dictionary. - debug (bool): skip FFD and Mesh objects instantation for debugging purposes. **Inner** - n_design (int): the number of design variables (dimensions of the problem). - doe_size (int): the size of the initial and subsequent generations. - max_generations (int): the number of generations before termination. - dat_file (str): path to input_geometry.dat (baseline geometry). - outdir (str): highest level optimization output directory. Note: the result folder tree is structured as follows: ``` outdir |__ FFD (contains <geom>_gXX_cYY.dat) |__ Figs (contains the figures generated during the optimization) |__ MESH (contains <geom>_gXX_cYY.mesh, .log, .geo_unrolled) |__ SOLVER |__ solver_gXX_cYY (contains the results of each simulation) ``` - study_type (str): use-case/meshing routine. - ffd_type (str): deformation method. - strategy (str): the optimization algorithm amongst inspyred's [ES, PSO] and pymoo's [GA, PSO]</br> see https://pythonhosted.org/inspyred/examples.html#standard-algorithms</br> and https://pymoo.org/algorithms/list.html#nb-algorithms-list - maximize (bool): whether to maximize or minimize the objective QoIs. - budget (int): maximum number of concurrent proc in use. - nproc_per_sim (int): number of proc per simulation. - bound (tuple[float]): design variables boundaries. - custom_doe (str): path to a custom doe. - sampler_name (str): name of the sampling algorithm used to generate samples. the initial generation. - seed (int): seed number of the random processes involved in the optimization. - prng (random.Random): pseudo-random generator passed to inspyred generator. - ea_kwargs (dict): additional arguments to be passed to the evolution algorithm. - gen_ctr (int): generation counter. - generator (Generator): Generator object for the initial generation sampling. - ffd (FFD_2D): FFD_2D object to generate deformed geometries. - gmsh_mesh (Mesh): Mesh class to generate deformed geometries meshes. - simulator (Simulator): Simulator object to perform simulations. - mean (list[float]): list of populations mean fitness. - median (list[float]): list of populations median fitness. - max (list[float]): list of populations max fitness. - min (list[float]): list of populations min fitness. - J (list[float | list[float]]): the list of all generated candidates fitnesses. - inputs (list[list[np.ndarray]]): all input candidates. - ffd_profiles (list[list[np.ndarray]]): all deformed geometries {gid: {cid: ffd_profile}}. - QoI (str): the quantity of intereset to minimize/maximize. - n_plt (int): the number of best candidates results to display after each evaluation. - cmap (str): the colormaps used for the observer plot</br> see https://matplotlib.org/stable/users/explain/colors/colormaps.html. \"\"\" self . config = config self . process_config () # required entries self . n_design : int = config [ \"optim\" ][ \"n_design\" ] self . doe_size : int = config [ \"optim\" ][ \"doe_size\" ] self . max_generations : int = config [ \"optim\" ][ \"max_generations\" ] self . dat_file : str = config [ \"study\" ][ \"file\" ] self . outdir : str = config [ \"study\" ][ \"outdir\" ] self . study_type : str = config [ \"study\" ][ \"study_type\" ] # optional entries self . ffd_type : str = config [ \"study\" ] . get ( \"ffd_type\" , \"\" ) self . custom_file : str = config [ \"study\" ] . get ( \"custom_file\" , \"\" ) self . strategy : str = config [ \"optim\" ] . get ( \"strategy\" , \"PSO\" ) self . maximize : bool = config [ \"optim\" ] . get ( \"maximize\" , False ) self . budget : int = config [ \"optim\" ] . get ( \"budget\" , 4 ) self . nproc_per_sim : int = config [ \"optim\" ] . get ( \"nproc_per_sim\" , 1 ) self . bound : tuple [ Any , ... ] = tuple ( config [ \"optim\" ] . get ( \"bound\" , [ - 1 , 1 ])) self . custom_doe : str = config [ \"optim\" ] . get ( \"custom_doe\" , \"\" ) self . sampler_name : str = config [ \"optim\" ] . get ( \"sampler_name\" , \"lhs\" ) self . ea_kwargs : dict = config [ \"optim\" ] . get ( \"ea_kwargs\" , {}) # reproducibility variables self . seed : int = config [ \"optim\" ] . get ( \"seed\" , 123 ) self . prng : Random = Random () self . prng . seed ( self . seed ) # generation counter self . gen_ctr : int = 0 # optimization objects if not debug : self . set_ffd_class () self . set_gmsh_mesh_class () self . generator : Generator = Generator ( self . seed , self . n_design , self . doe_size , self . sampler_name , self . bound , self . custom_doe ) self . set_simulator_class () self . simulator = self . SimulatorClass ( self . config ) # population statistics self . mean : list [ float ] = [] self . median : list [ float ] = [] self . max : list [ float ] = [] self . min : list [ float ] = [] # set other inner optimization variables self . J : list [ float | list [ float ]] = [] self . inputs : list [ list [ np . ndarray ]] = [] self . ffd_profiles : list [ list [ np . ndarray ]] = [] self . QoI : str = self . config [ \"optim\" ] . get ( \"QoI\" , \"CD\" ) self . n_plt : int = self . config [ \"optim\" ] . get ( \"n_plt\" , 5 ) self . cmap : str = self . config [ \"optim\" ] . get ( \"cmap\" , \"viridis\" ) self . set_inner () # figure directory self . figdir : str = os . path . join ( self . outdir , \"Figs\" ) check_dir ( self . figdir )","title":"__init__"},{"location":"dev_optimizer/#optim.optimizer.Optimizer._evaluate","text":"Computes all candidates outputs and return the optimizer list of QoIs. Source code in aero_optim/optim/optimizer.py 401 402 403 404 405 @abstractmethod def _evaluate ( self , * args , ** kwargs ) -> list [ float | list [ float ]] | None : \"\"\" Computes all candidates outputs and return the optimizer list of QoIs. \"\"\"","title":"_evaluate"},{"location":"dev_optimizer/#optim.optimizer.Optimizer._observe","text":"Plots generation data after each evaluation. Source code in aero_optim/optim/optimizer.py 318 319 320 321 322 def _observe ( self , * args , ** kwargs ): \"\"\" **Plots** generation data after each evaluation. \"\"\" logger . info ( \"_observe not implemented\" )","title":"_observe"},{"location":"dev_optimizer/#optim.optimizer.Optimizer.compute_statistics","text":"Computes generation statistics. Note this method is meant to be called in _observe . Source code in aero_optim/optim/optimizer.py 306 307 308 309 310 311 312 313 314 315 316 def compute_statistics ( self , gen_fitness : np . ndarray ): \"\"\" **Computes** generation statistics. Note: this method is meant to be called in `_observe`. \"\"\" self . mean . append ( np . mean ( gen_fitness )) self . median . append ( np . median ( gen_fitness )) self . min . append ( min ( gen_fitness )) self . max . append ( max ( gen_fitness ))","title":"compute_statistics"},{"location":"dev_optimizer/#optim.optimizer.Optimizer.deform","text":"Applies FFD on a given candidate and returns its resulting file. Source code in aero_optim/optim/optimizer.py 254 255 256 257 258 259 260 261 262 def deform ( self , Delta : np . ndarray , gid : int , cid : int ) -> tuple [ str , np . ndarray ]: \"\"\" **Applies** FFD on a given candidate and returns its resulting file. \"\"\" ffd_dir = os . path . join ( self . outdir , \"FFD\" ) check_dir ( ffd_dir ) logger . info ( f \"g { gid } , c { cid } generate profile with deformation { Delta } \" ) profile : np . ndarray = self . ffd . apply_ffd ( Delta ) return self . ffd . write_ffd ( profile , Delta , ffd_dir , gid = gid , cid = cid ), profile","title":"deform"},{"location":"dev_optimizer/#optim.optimizer.Optimizer.execute_candidates","text":"Executes all candidates and waits for them to finish. Note this method is meant to be called in _evaluate. Source code in aero_optim/optim/optimizer.py 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 def execute_candidates ( self , candidates : list [ Individual ] | np . ndarray , gid : int ): \"\"\" **Executes** all candidates and **waits** for them to finish. Note: this method is meant to be called in _evaluate. \"\"\" logger . info ( f \"evaluating candidates of generation { self . gen_ctr } ..\" ) self . ffd_profiles . append ([]) self . inputs . append ([]) for cid , cand in enumerate ( candidates ): self . inputs [ gid ] . append ( np . array ( cand )) ffd_file , ffd_profile = self . deform ( cand , gid , cid ) self . ffd_profiles [ gid ] . append ( ffd_profile ) # meshing with proper sigint management # see https://gitlab.onelab.info/gmsh/gmsh/-/issues/842 ORIGINAL_SIGINT_HANDLER = signal . signal ( signal . SIGINT , signal . SIG_DFL ) mesh_file = self . mesh ( ffd_file ) signal . signal ( signal . SIGINT , ORIGINAL_SIGINT_HANDLER ) while self . simulator . monitor_sim_progress () * self . nproc_per_sim >= self . budget : time . sleep ( 1 ) self . simulator . execute_sim ( meshfile = mesh_file , gid = gid , cid = cid ) # wait for last candidates to finish while self . simulator . monitor_sim_progress () > 0 : time . sleep ( 0.1 )","title":"execute_candidates"},{"location":"dev_optimizer/#optim.optimizer.Optimizer.mesh","text":"Builds mesh for a given candidate and returns its resulting file. Note if a mesh file matching the pattern name already exists, it is not rebuilt. Source code in aero_optim/optim/optimizer.py 264 265 266 267 268 269 270 271 272 273 274 275 276 277 def mesh ( self , ffdfile : str ) -> str : \"\"\" **Builds** mesh for a given candidate and returns its resulting file. Note: if a mesh file matching the pattern name already exists, it is not rebuilt. \"\"\" mesh_dir = os . path . join ( self . outdir , \"MESH\" ) check_dir ( mesh_dir ) gmsh_mesh = self . MeshClass ( self . config , ffdfile ) if os . path . isfile ( gmsh_mesh . get_meshfile ( mesh_dir )): return gmsh_mesh . get_meshfile ( mesh_dir ) gmsh_mesh . build_mesh () return gmsh_mesh . write_mesh ( mesh_dir )","title":"mesh"},{"location":"dev_optimizer/#optim.optimizer.Optimizer.plot_generation","text":"Plots the results of the last evaluated generation. Saves the graph in the output directory. Note this method is meant to be called in _observe . Source code in aero_optim/optim/optimizer.py 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 def plot_generation ( self , gid : int , sorted_idx : np . ndarray , gen_fitness : np . ndarray , fig_name : str ): \"\"\" **Plots** the results of the last evaluated generation. **Saves** the graph in the output directory. Note: this method is meant to be called in `_observe`. \"\"\" logger . info ( \"plot_generation not implemented\" )","title":"plot_generation"},{"location":"dev_optimizer/#optim.optimizer.Optimizer.plot_progress","text":"Plots and saves the overall progress of the optimization. Note this method is meant to be called in final_observe . Source code in aero_optim/optim/optimizer.py 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 def plot_progress ( self , gen_nbr : int , fig_name : str , baseline_value : float | None = None ): \"\"\" **Plots** and **saves** the overall progress of the optimization. Note: this method is meant to be called in `final_observe`. \"\"\" logger . info ( f \"plotting populations statistics after { gen_nbr } generations..\" ) # plot construction _ , ax = plt . subplots ( figsize = ( 8 , 8 )) psize = self . doe_size if baseline_value : ax . axhline ( y = baseline_value , color = 'k' , ls = \"--\" , label = \"baseline\" ) # plotting data best = self . max if self . maximize else self . min worst = self . min if self . maximize else self . max data = [ self . mean , self . median , best , worst ] colors = [ \"grey\" , \"blue\" , \"green\" , \"red\" ] labels = [ \"mean\" , \"median\" , \"best\" , \"worst\" ] for val , col , lab in zip ( data , colors , labels ): ax . plot ( range ( self . gen_ctr ), val , color = col , label = lab ) plt . fill_between ( range ( self . gen_ctr ), data [ 2 ], data [ 3 ], color = '#e6f2e6' ) plt . grid ( True ) ymin = min ([ min ( d ) for d in data ]) ymax = max ([ max ( d ) for d in data ]) yrange = ymax - ymin plt . ylim (( ymin - 0.1 * yrange , ymax + 0.1 * yrange )) ax . xaxis . set_major_locator ( MaxNLocator ( integer = True )) # legend and title ax . set_title ( f \"Optimization evolution ( { gen_nbr } g. x { psize } c.)\" ) ax . legend ( loc = \"center left\" , bbox_to_anchor = ( 1 , 0.5 )) ax . set_xlabel ( 'generation $[ \\\\ cdot]$' ) ax . set_ylabel ( 'fitness' ) # save figure as png logger . info ( f \"saving { fig_name } to { self . outdir } \" ) plt . savefig ( os . path . join ( self . outdir , fig_name ), bbox_inches = 'tight' ) plt . close ()","title":"plot_progress"},{"location":"dev_optimizer/#optim.optimizer.Optimizer.process_config","text":"Makes sure the config file contains the required information. Source code in aero_optim/optim/optimizer.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 def process_config ( self ): \"\"\" **Makes sure** the config file contains the required information. \"\"\" logger . info ( \"processing config..\" ) if \"n_design\" not in self . config [ \"optim\" ]: raise Exception ( f \"ERROR -- no <n_design> entry in { self . config [ 'optim' ] } \" ) if \"doe_size\" not in self . config [ \"optim\" ]: raise Exception ( f \"ERROR -- no <doe_size> entry in { self . config [ 'optim' ] } \" ) if \"max_generations\" not in self . config [ \"optim\" ]: raise Exception ( f \"ERROR -- no <max_generations> entry in { self . config [ 'optim' ] } \" ) if \"file\" not in self . config [ \"study\" ]: raise Exception ( f \"ERROR -- no <file> entry in { self . config [ 'study' ] } \" ) if \"budget\" not in self . config [ \"optim\" ]: logger . warning ( f \"no <budget> entry in { self . config [ 'optim' ] } \" ) if \"nproc_per_sim\" not in self . config [ \"optim\" ]: logger . warning ( f \"no <nproc_per_sim> entry in { self . config [ 'optim' ] } \" ) if \"bound\" not in self . config [ \"optim\" ]: logger . warning ( f \"no <bound> entry in { self . config [ 'optim' ] } \" ) if \"sampler_name\" not in self . config [ \"optim\" ]: logger . warning ( f \"no <sampler_name> entry in { self . config [ 'optim' ] } \" ) if \"seed\" not in self . config [ \"optim\" ]: logger . warning ( f \"no <seed> entry in { self . config [ 'optim' ] } \" ) # alter config for optimization purposes if \"outfile\" in self . config [ \"study\" ]: logger . warning ( f \"<outfile> entry in { self . config [ 'study' ] } will be ignored\" ) del self . config [ \"study\" ][ \"outfile\" ] if \"view\" in self . config [ \"gmsh\" ] and \"GUI\" in self . config [ \"gmsh\" ][ \"view\" ]: logger . warning ( f \"<GUI> entry in { self . config [ 'gmsh' ][ 'view' ] } forced to False\" ) self . config [ \"gmsh\" ][ \"view\" ][ \"GUI\" ] = False","title":"process_config"},{"location":"dev_optimizer/#optim.optimizer.Optimizer.save_results","text":"Saves candidates and fitnesses to file. Source code in aero_optim/optim/optimizer.py 381 382 383 384 385 386 387 388 389 390 def save_results ( self ): \"\"\" **Saves** candidates and fitnesses to file. \"\"\" logger . info ( f \"optimization results saved to { self . outdir } \" ) np . savetxt ( os . path . join ( self . outdir , \"candidates.txt\" ), np . reshape ( self . inputs , ( - 1 , self . n_design )) ) np . savetxt ( os . path . join ( self . outdir , \"fitnesses.txt\" ), self . J )","title":"save_results"},{"location":"dev_optimizer/#optim.optimizer.Optimizer.set_ffd_class","text":"Instantiates the deformation class and object as custom if found, as one of the default classes otherwise. Source code in aero_optim/optim/optimizer.py 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 def set_ffd_class ( self ): \"\"\" **Instantiates** the deformation class and object as custom if found, as one of the default classes otherwise. \"\"\" self . FFDClass = ( get_custom_class ( self . custom_file , \"CustomFFD\" ) if self . custom_file else None ) ffd_config = self . config . get ( \"ffd\" , {}) rotation = ffd_config . get ( \"rotation\" , False ) if not self . FFDClass : # standard FFD 2D if self . ffd_type == FFD_TYPE [ 0 ]: self . FFDClass = FFD_2D self . ffd = self . FFDClass ( self . dat_file , self . n_design // 2 , ** ffd_config ) # POD coupled FFD 2D elif self . ffd_type == FFD_TYPE [ 1 ]: self . FFDClass = FFD_POD_2D ffd_config [ \"ffd_ncontrol\" ] = self . n_design ffd_config [ \"ffd_bound\" ] = self . bound logger . info ( f \"ffd bound: { self . bound } \" ) self . ffd = self . FFDClass ( self . dat_file , ** ffd_config ) self . n_design = ffd_config [ \"pod_ncontrol\" ] self . bound = ffd_config . get ( \"pod_bound\" , self . ffd . get_bound ()) logger . info ( f \"pod bound: { self . bound } \" ) else : raise Exception ( f \"ERROR -- incorrect ffd_type < { self . ffd_type } >\" ) else : self . ffd = self . FFDClass ( self . dat_file , self . n_design , ** ffd_config ) # rotation wrapper if rotation : logger . info ( f \"rotation: { rotation } \" ) self . ffd = RotationWrapper ( self . ffd ) rot_bound = ffd_config . get ( \"rot_bound\" , [ - 1 , 1 ]) # convert bound from tuple of floats to tuple of lists if not isinstance ( self . bound [ 0 ], list ): self . bound = ([ self . bound [ 0 ]] * self . n_design , [ self . bound [ - 1 ]] * self . n_design ) self . bound = ( self . bound [ 0 ] + [ rot_bound [ 0 ]], self . bound [ - 1 ] + [ rot_bound [ - 1 ]]) self . n_design += 1 logger . info ( f \"effective n_design: { self . n_design } \" )","title":"set_ffd_class"},{"location":"dev_optimizer/#optim.optimizer.Optimizer.set_gmsh_mesh_class","text":"Instantiates the mesher class as custom if found, as one of the default meshers otherwise. Source code in aero_optim/optim/optimizer.py 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 def set_gmsh_mesh_class ( self ): \"\"\" **Instantiates** the mesher class as custom if found, as one of the default meshers otherwise. \"\"\" self . MeshClass = ( get_custom_class ( self . custom_file , \"CustomMesh\" ) if self . custom_file else None ) if not self . MeshClass : if self . study_type == STUDY_TYPE [ 0 ]: self . MeshClass = NACABaseMesh elif self . study_type == STUDY_TYPE [ 1 ]: self . MeshClass = NACABlockMesh elif self . study_type == STUDY_TYPE [ 2 ]: self . MeshClass = CascadeMesh elif self . study_type == STUDY_TYPE [ 3 ]: self . MeshClass = MeshMusicaa else : raise Exception ( f \"ERROR -- incorrect study_type < { self . study_type } >\" )","title":"set_gmsh_mesh_class"},{"location":"dev_optimizer/#optim.optimizer.Optimizer.set_inner","text":"Sets some use-case specific inner variables: Source code in aero_optim/optim/optimizer.py 248 249 250 251 252 def set_inner ( self ): \"\"\" **Sets** some use-case specific inner variables: \"\"\" logger . info ( \"set_inner not implemented\" )","title":"set_inner"},{"location":"dev_optimizer/#optim.optimizer.Optimizer.set_simulator_class","text":"Instantiates the simulator class with CustomSimulator if found. Source code in aero_optim/optim/optimizer.py 392 393 394 395 396 397 398 399 @abstractmethod def set_simulator_class ( self ): \"\"\" Instantiates the simulator class with CustomSimulator if found. \"\"\" self . SimulatorClass = ( get_custom_class ( self . custom_file , \"CustomSimulator\" ) if self . custom_file else None )","title":"set_simulator_class"},{"location":"dev_optimizer/#optim.optimizer.WolfOptimizer","text":"Bases: Optimizer , ABC This class implements a Wolf based Optimizer. Source code in aero_optim/optim/optimizer.py 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 class WolfOptimizer ( Optimizer , ABC ): \"\"\" This class implements a Wolf based Optimizer. \"\"\" def __init__ ( self , config : dict ): \"\"\" Instantiates the WolfOptimizer object. **Input** - config (dict): the config file dictionary. \"\"\" super () . __init__ ( config ) def set_simulator_class ( self ): \"\"\" **Sets** the simulator class as custom if found, as WolfSimulator otherwise. \"\"\" super () . set_simulator_class () if not self . SimulatorClass : self . SimulatorClass = WolfSimulator def set_inner ( self ): \"\"\" **Sets** some use-case specific inner variables: - baseline_CD (float): the drag coefficient of the baseline geometry. - baseline_CL (float): the lift coefficient of the baseline geometry. - baseline_area (float): the baseline area that is used as a structural constraint. - area_margin (float): area tolerance margin given as a percentage wrt baseline_area</br> i.e. a candidate with an area greater/smaller than +/- area_margin % of the baseline_area will be penalized. - penalty (list): a [key, value] constraint not to be worsen by the optimization. - constraint (bool): constraints are applied (True) or not (False) \"\"\" self . baseline_CD = self . config [ \"optim\" ] . get ( \"baseline_CD\" , 0.15 ) self . baseline_CL = self . config [ \"optim\" ] . get ( \"baseline_CL\" , 0.36 ) self . baseline_area = abs ( get_area ( self . ffd . pts )) self . area_margin = self . config [ \"optim\" ] . get ( \"area_margin\" , 40. ) / 100. self . penalty = self . config [ \"optim\" ] . get ( \"penalty\" , [ \"CL\" , self . baseline_CL ]) self . constraint = self . config [ \"optim\" ] . get ( \"constraint\" , True ) def plot_generation ( self , gid : int , sorted_idx : np . ndarray , gen_fitness : np . ndarray , fig_name : str ): \"\"\" **Plots** the results of the last evaluated generation. **Saves** the graph in the output directory. \"\"\" baseline : np . ndarray = self . ffd . pts profiles : list [ np . ndarray ] = self . ffd_profiles [ gid ] res_dict = self . simulator . df_dict [ gid ] df_key = res_dict [ 0 ] . columns # \"ResTot\", \"CD\", \"CL\", \"ResCD\", \"ResCL\", \"x\", \"y\", \"Cp\" cmap = mpl . colormaps [ self . cmap ] . resampled ( self . n_plt ) colors = cmap ( np . linspace ( 0 , 1 , self . n_plt )) # subplot construction fig = plt . figure ( figsize = ( 16 , 12 )) ax1 = plt . subplot ( 2 , 1 , 1 ) # profiles ax2 = plt . subplot ( 2 , 3 , 4 ) # ResTot ax3 = plt . subplot ( 2 , 3 , 5 ) # CD & CL ax4 = plt . subplot ( 2 , 3 , 6 ) # fitness (CD) plt . subplots_adjust ( wspace = 0.25 ) ax1 . plot ( baseline [:, 0 ], baseline [:, 1 ], color = \"k\" , lw = 2 , ls = \"--\" , label = \"baseline\" ) ax3 . axhline ( y = self . baseline_CD , color = 'k' , label = \"baseline\" ) ax3 . axhline ( y = self . baseline_CL , color = 'k' , linestyle = \"--\" , label = \"baseline\" ) ax4 . axhline ( y = self . baseline_CD , color = 'k' , linestyle = \"--\" , label = \"baseline\" ) # loop over candidates through the last generated profiles for color , cid in enumerate ( sorted_idx ): ax1 . plot ( profiles [ cid ][:, 0 ], profiles [ cid ][:, 1 ], color = colors [ color ], label = f \"c { cid } \" ) res_dict [ cid ][ df_key [ 0 ]] . plot ( ax = ax2 , color = colors [ color ], label = f \"c { cid } \" ) # ResTot res_dict [ cid ][ df_key [ 1 ]] . plot ( ax = ax3 , color = colors [ color ], label = f \" { df_key [ 1 ] } c { cid } \" ) res_dict [ cid ][ df_key [ 2 ]] . plot ( ax = ax3 , color = colors [ color ], ls = \"--\" , label = f \" { df_key [ 2 ] } c { cid } \" ) ax4 . scatter ( cid , gen_fitness [ cid ], color = colors [ color ], label = f \"c { cid } \" ) # legend and title fig . suptitle ( f \"Generation { gid } - { self . n_plt } top candidates\" , size = \"x-large\" , weight = \"bold\" , y = 0.93 ) # top ax1 . set_title ( \"FFD profiles\" , weight = \"bold\" ) ax1 . legend ( loc = \"center left\" , bbox_to_anchor = ( 1 , 0.5 )) ax1 . set_xlabel ( '$x$ $[m]$' ) ax1 . set_ylabel ( '$y$ $[m]$' ) # bottom left ax2 . set_title ( f \" { df_key [ 0 ] } \" , weight = \"bold\" ) ax2 . set_yscale ( \"log\" ) ax2 . set_xlabel ( 'iteration $[ \\\\ cdot]$' ) ax2 . set_ylabel ( 'residual $[ \\\\ cdot]$' ) # bottom center ax3 . set_title ( f \" { df_key [ 1 ] } & { df_key [ 2 ] } \" , weight = \"bold\" ) ax3 . set_xlabel ( 'iteration $[ \\\\ cdot]$' ) ax3 . set_ylabel ( 'aerodynamic coefficients $[ \\\\ cdot]$' ) # bottom right ax4 . xaxis . set_major_locator ( MaxNLocator ( integer = True )) ax4 . set_title ( f \"fitness: { self . QoI } \" , weight = \"bold\" ) ax4 . legend ( loc = \"center left\" , bbox_to_anchor = ( 1 , 0.5 )) ax4 . set_xlabel ( 'candidate $[ \\\\ cdot]$' ) ax4 . set_ylabel ( \"fitness\" ) # save figure as png logger . info ( f \"saving { fig_name } to { self . outdir } \" ) plt . savefig ( os . path . join ( self . figdir , fig_name ), bbox_inches = 'tight' ) plt . close () def save_results ( self ): super () . save_results () with open ( os . path . join ( self . outdir , \"df_dict.pkl\" ), \"wb\" ) as handle : pickle . dump ( self . simulator . df_dict , handle ) logger . info ( f \"results dictionary saved to { self . outdir } \" ) @abstractmethod def apply_constraints ( self , * args , ** kwargs ): \"\"\" Looks for constraints violations. \"\"\" @abstractmethod def final_observe ( self , * args , ** kwargs ): \"\"\" Plots convergence progress by plotting the fitness values obtained with the successive generations. \"\"\"","title":"WolfOptimizer"},{"location":"dev_optimizer/#optim.optimizer.WolfOptimizer.__init__","text":"Instantiates the WolfOptimizer object. Input config (dict): the config file dictionary. Source code in aero_optim/optim/optimizer.py 412 413 414 415 416 417 418 419 420 def __init__ ( self , config : dict ): \"\"\" Instantiates the WolfOptimizer object. **Input** - config (dict): the config file dictionary. \"\"\" super () . __init__ ( config )","title":"__init__"},{"location":"dev_optimizer/#optim.optimizer.WolfOptimizer.apply_constraints","text":"Looks for constraints violations. Source code in aero_optim/optim/optimizer.py 523 524 525 526 527 @abstractmethod def apply_constraints ( self , * args , ** kwargs ): \"\"\" Looks for constraints violations. \"\"\"","title":"apply_constraints"},{"location":"dev_optimizer/#optim.optimizer.WolfOptimizer.final_observe","text":"Plots convergence progress by plotting the fitness values obtained with the successive generations. Source code in aero_optim/optim/optimizer.py 529 530 531 532 533 534 @abstractmethod def final_observe ( self , * args , ** kwargs ): \"\"\" Plots convergence progress by plotting the fitness values obtained with the successive generations. \"\"\"","title":"final_observe"},{"location":"dev_optimizer/#optim.optimizer.WolfOptimizer.plot_generation","text":"Plots the results of the last evaluated generation. Saves the graph in the output directory. Source code in aero_optim/optim/optimizer.py 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 def plot_generation ( self , gid : int , sorted_idx : np . ndarray , gen_fitness : np . ndarray , fig_name : str ): \"\"\" **Plots** the results of the last evaluated generation. **Saves** the graph in the output directory. \"\"\" baseline : np . ndarray = self . ffd . pts profiles : list [ np . ndarray ] = self . ffd_profiles [ gid ] res_dict = self . simulator . df_dict [ gid ] df_key = res_dict [ 0 ] . columns # \"ResTot\", \"CD\", \"CL\", \"ResCD\", \"ResCL\", \"x\", \"y\", \"Cp\" cmap = mpl . colormaps [ self . cmap ] . resampled ( self . n_plt ) colors = cmap ( np . linspace ( 0 , 1 , self . n_plt )) # subplot construction fig = plt . figure ( figsize = ( 16 , 12 )) ax1 = plt . subplot ( 2 , 1 , 1 ) # profiles ax2 = plt . subplot ( 2 , 3 , 4 ) # ResTot ax3 = plt . subplot ( 2 , 3 , 5 ) # CD & CL ax4 = plt . subplot ( 2 , 3 , 6 ) # fitness (CD) plt . subplots_adjust ( wspace = 0.25 ) ax1 . plot ( baseline [:, 0 ], baseline [:, 1 ], color = \"k\" , lw = 2 , ls = \"--\" , label = \"baseline\" ) ax3 . axhline ( y = self . baseline_CD , color = 'k' , label = \"baseline\" ) ax3 . axhline ( y = self . baseline_CL , color = 'k' , linestyle = \"--\" , label = \"baseline\" ) ax4 . axhline ( y = self . baseline_CD , color = 'k' , linestyle = \"--\" , label = \"baseline\" ) # loop over candidates through the last generated profiles for color , cid in enumerate ( sorted_idx ): ax1 . plot ( profiles [ cid ][:, 0 ], profiles [ cid ][:, 1 ], color = colors [ color ], label = f \"c { cid } \" ) res_dict [ cid ][ df_key [ 0 ]] . plot ( ax = ax2 , color = colors [ color ], label = f \"c { cid } \" ) # ResTot res_dict [ cid ][ df_key [ 1 ]] . plot ( ax = ax3 , color = colors [ color ], label = f \" { df_key [ 1 ] } c { cid } \" ) res_dict [ cid ][ df_key [ 2 ]] . plot ( ax = ax3 , color = colors [ color ], ls = \"--\" , label = f \" { df_key [ 2 ] } c { cid } \" ) ax4 . scatter ( cid , gen_fitness [ cid ], color = colors [ color ], label = f \"c { cid } \" ) # legend and title fig . suptitle ( f \"Generation { gid } - { self . n_plt } top candidates\" , size = \"x-large\" , weight = \"bold\" , y = 0.93 ) # top ax1 . set_title ( \"FFD profiles\" , weight = \"bold\" ) ax1 . legend ( loc = \"center left\" , bbox_to_anchor = ( 1 , 0.5 )) ax1 . set_xlabel ( '$x$ $[m]$' ) ax1 . set_ylabel ( '$y$ $[m]$' ) # bottom left ax2 . set_title ( f \" { df_key [ 0 ] } \" , weight = \"bold\" ) ax2 . set_yscale ( \"log\" ) ax2 . set_xlabel ( 'iteration $[ \\\\ cdot]$' ) ax2 . set_ylabel ( 'residual $[ \\\\ cdot]$' ) # bottom center ax3 . set_title ( f \" { df_key [ 1 ] } & { df_key [ 2 ] } \" , weight = \"bold\" ) ax3 . set_xlabel ( 'iteration $[ \\\\ cdot]$' ) ax3 . set_ylabel ( 'aerodynamic coefficients $[ \\\\ cdot]$' ) # bottom right ax4 . xaxis . set_major_locator ( MaxNLocator ( integer = True )) ax4 . set_title ( f \"fitness: { self . QoI } \" , weight = \"bold\" ) ax4 . legend ( loc = \"center left\" , bbox_to_anchor = ( 1 , 0.5 )) ax4 . set_xlabel ( 'candidate $[ \\\\ cdot]$' ) ax4 . set_ylabel ( \"fitness\" ) # save figure as png logger . info ( f \"saving { fig_name } to { self . outdir } \" ) plt . savefig ( os . path . join ( self . figdir , fig_name ), bbox_inches = 'tight' ) plt . close ()","title":"plot_generation"},{"location":"dev_optimizer/#optim.optimizer.WolfOptimizer.set_inner","text":"Sets some use-case specific inner variables: baseline_CD (float): the drag coefficient of the baseline geometry. baseline_CL (float): the lift coefficient of the baseline geometry. baseline_area (float): the baseline area that is used as a structural constraint. area_margin (float): area tolerance margin given as a percentage wrt baseline_area i.e. a candidate with an area greater/smaller than +/- area_margin % of the baseline_area will be penalized. penalty (list): a [key, value] constraint not to be worsen by the optimization. constraint (bool): constraints are applied (True) or not (False) Source code in aero_optim/optim/optimizer.py 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 def set_inner ( self ): \"\"\" **Sets** some use-case specific inner variables: - baseline_CD (float): the drag coefficient of the baseline geometry. - baseline_CL (float): the lift coefficient of the baseline geometry. - baseline_area (float): the baseline area that is used as a structural constraint. - area_margin (float): area tolerance margin given as a percentage wrt baseline_area</br> i.e. a candidate with an area greater/smaller than +/- area_margin % of the baseline_area will be penalized. - penalty (list): a [key, value] constraint not to be worsen by the optimization. - constraint (bool): constraints are applied (True) or not (False) \"\"\" self . baseline_CD = self . config [ \"optim\" ] . get ( \"baseline_CD\" , 0.15 ) self . baseline_CL = self . config [ \"optim\" ] . get ( \"baseline_CL\" , 0.36 ) self . baseline_area = abs ( get_area ( self . ffd . pts )) self . area_margin = self . config [ \"optim\" ] . get ( \"area_margin\" , 40. ) / 100. self . penalty = self . config [ \"optim\" ] . get ( \"penalty\" , [ \"CL\" , self . baseline_CL ]) self . constraint = self . config [ \"optim\" ] . get ( \"constraint\" , True )","title":"set_inner"},{"location":"dev_optimizer/#optim.optimizer.WolfOptimizer.set_simulator_class","text":"Sets the simulator class as custom if found, as WolfSimulator otherwise. Source code in aero_optim/optim/optimizer.py 422 423 424 425 426 427 428 def set_simulator_class ( self ): \"\"\" **Sets** the simulator class as custom if found, as WolfSimulator otherwise. \"\"\" super () . set_simulator_class () if not self . SimulatorClass : self . SimulatorClass = WolfSimulator","title":"set_simulator_class"},{"location":"dev_optimizer/#optim.optimizer.DebugOptimizer","text":"Bases: Optimizer , ABC Source code in aero_optim/optim/optimizer.py 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 class DebugOptimizer ( Optimizer , ABC ): def __init__ ( self , config : dict ): \"\"\" Dummy init. \"\"\" super () . __init__ ( config , debug = True ) def set_simulator_class ( self ): \"\"\" **Sets** the simulator class as custom if found, as DebugSimulator otherwise. \"\"\" super () . set_simulator_class () if not self . SimulatorClass : self . SimulatorClass = DebugSimulator def set_inner ( self ): return def execute_candidates ( self , candidates : list [ Individual ] | np . ndarray , gid : int ): \"\"\" **Executes** all candidates and **waits** for them to finish. \"\"\" logger . info ( f \"evaluating candidates of generation { self . gen_ctr } ..\" ) self . inputs . append ([]) for cid , cand in enumerate ( candidates ): self . inputs [ gid ] . append ( np . array ( cand )) logger . debug ( f \"g { gid } , c { cid } cand { cand } \" ) self . simulator . execute_sim ( cand , gid , cid ) logger . debug ( f \"g { gid } , c { cid } cand { cand } , \" f \"fitness { self . simulator . df_dict [ gid ][ cid ][ 'result' ] . iloc [ - 1 ] } \" )","title":"DebugOptimizer"},{"location":"dev_optimizer/#optim.optimizer.DebugOptimizer.__init__","text":"Dummy init. Source code in aero_optim/optim/optimizer.py 538 539 540 541 542 def __init__ ( self , config : dict ): \"\"\" Dummy init. \"\"\" super () . __init__ ( config , debug = True )","title":"__init__"},{"location":"dev_optimizer/#optim.optimizer.DebugOptimizer.execute_candidates","text":"Executes all candidates and waits for them to finish. Source code in aero_optim/optim/optimizer.py 555 556 557 558 559 560 561 562 563 564 565 566 def execute_candidates ( self , candidates : list [ Individual ] | np . ndarray , gid : int ): \"\"\" **Executes** all candidates and **waits** for them to finish. \"\"\" logger . info ( f \"evaluating candidates of generation { self . gen_ctr } ..\" ) self . inputs . append ([]) for cid , cand in enumerate ( candidates ): self . inputs [ gid ] . append ( np . array ( cand )) logger . debug ( f \"g { gid } , c { cid } cand { cand } \" ) self . simulator . execute_sim ( cand , gid , cid ) logger . debug ( f \"g { gid } , c { cid } cand { cand } , \" f \"fitness { self . simulator . df_dict [ gid ][ cid ][ 'result' ] . iloc [ - 1 ] } \" )","title":"execute_candidates"},{"location":"dev_optimizer/#optim.optimizer.DebugOptimizer.set_simulator_class","text":"Sets the simulator class as custom if found, as DebugSimulator otherwise. Source code in aero_optim/optim/optimizer.py 544 545 546 547 548 549 550 def set_simulator_class ( self ): \"\"\" **Sets** the simulator class as custom if found, as DebugSimulator otherwise. \"\"\" super () . set_simulator_class () if not self . SimulatorClass : self . SimulatorClass = DebugSimulator","title":"set_simulator_class"},{"location":"dev_optimizer/#inspyred-optimizers","text":"","title":"inspyred Optimizers"},{"location":"dev_optimizer/#optim.inspyred_optimizer.InspyredWolfOptimizer","text":"Bases: WolfOptimizer This class implements a Wolf based Optimizer. Source code in aero_optim/optim/inspyred_optimizer.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 class InspyredWolfOptimizer ( WolfOptimizer ): \"\"\" This class implements a Wolf based Optimizer. \"\"\" def _evaluate ( self , candidates : list [ Individual ], args : dict ) -> list [ float | list [ float ]]: \"\"\" **Executes** Wolf simulations, **extracts** results and **returns** the list of candidates QoIs. Note: __candidates__ and __args__ are inspyred mandatory arguments</br> see https://pythonhosted.org/inspyred/tutorial.html#the-evaluator \"\"\" gid = self . gen_ctr # execute all candidates self . execute_candidates ( candidates , gid ) # add penalty to the candidates fitness for cid , _ in enumerate ( candidates ): self . J . append ( self . apply_constraints ( gid , cid , self . ffd_profiles [ gid ][ cid ], self . simulator . df_dict [ gid ][ cid ][ self . penalty [ 0 ]] . iloc [ - 1 ] ) ) self . J [ - 1 ] += self . simulator . df_dict [ gid ][ cid ][ self . QoI ] . iloc [ - 1 ] self . gen_ctr += 1 return self . J [ - self . doe_size :] def apply_constraints ( self , gid : int , cid : int , ffd_profile : np . ndarray , pen_value : float ) -> float : \"\"\" **Returns** a penalty value based on some specific constraints</br> see https://inspyred.readthedocs.io/en/latest/recipes.html#constraint-selection \"\"\" if not self . constraint : return 0. area_cond : bool = ( abs ( get_area ( ffd_profile )) > ( 1. + self . area_margin ) * self . baseline_area or abs ( get_area ( ffd_profile )) < ( 1. - self . area_margin ) * self . baseline_area ) penalty_cond : bool = pen_value < self . penalty [ - 1 ] if area_cond or penalty_cond : logger . info ( f \"penalized candidate g { gid } , c { cid } \" f \"with area { abs ( get_area ( ffd_profile )) } and CL { pen_value } \" ) return 1. return 0. def _observe ( self , population : list [ Individual ], num_generations : int , num_evaluations : int , args : dict ): \"\"\" **Plots** the n_plt best results each time a generation has been evaluated:</br> > the simulations residuals,</br> > the simulations CD & CL,</br> > the candidates fitness,</br> > the baseline and deformed profiles. Note: __num_generations__, __num_evaluations__ and __args__ are inspyred mandatory arguments</br> see https://pythonhosted.org/inspyred/examples.html#custom-observer \"\"\" gid = num_generations # extract generation best profiles fitness : np . ndarray = np . array ( self . J [ - self . doe_size :]) sorted_idx = ( np . argsort ( fitness )[ - self . n_plt :] if self . maximize else np . argsort ( fitness )[: self . n_plt ] ) # compute population statistics self . compute_statistics ( np . array ([ ind . fitness for ind in population ])) logger . info ( f \"extracting { self . n_plt } best profiles in g { gid } : { sorted_idx } ..\" ) logger . debug ( f \"g { gid } J-fitnesses (candidates): { fitness } \" ) logger . debug ( f \"g { gid } P-fitness (population) { [ ind . fitness for ind in population ] } \" ) # plot settings fig_name = f \"inspyred_g { num_generations } .png\" self . plot_generation ( gid , sorted_idx , fitness , fig_name ) def final_observe ( self , * args , ** kwargs ): \"\"\" **Plots** convergence progress by plotting the fitness values obtained with the successive generations</br> see https://pythonhosted.org/inspyred/reference.html#inspyred.ec.analysis.generation_plot \"\"\" fig_name = f \"inspyred_optim_g { self . gen_ctr - 1 } _c { self . doe_size } .png\" self . plot_progress ( self . gen_ctr - 1 , fig_name , baseline_value = self . baseline_CD )","title":"InspyredWolfOptimizer"},{"location":"dev_optimizer/#optim.inspyred_optimizer.InspyredWolfOptimizer._evaluate","text":"Executes Wolf simulations, extracts results and returns the list of candidates QoIs. Note candidates and args are inspyred mandatory arguments see https://pythonhosted.org/inspyred/tutorial.html#the-evaluator Source code in aero_optim/optim/inspyred_optimizer.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def _evaluate ( self , candidates : list [ Individual ], args : dict ) -> list [ float | list [ float ]]: \"\"\" **Executes** Wolf simulations, **extracts** results and **returns** the list of candidates QoIs. Note: __candidates__ and __args__ are inspyred mandatory arguments</br> see https://pythonhosted.org/inspyred/tutorial.html#the-evaluator \"\"\" gid = self . gen_ctr # execute all candidates self . execute_candidates ( candidates , gid ) # add penalty to the candidates fitness for cid , _ in enumerate ( candidates ): self . J . append ( self . apply_constraints ( gid , cid , self . ffd_profiles [ gid ][ cid ], self . simulator . df_dict [ gid ][ cid ][ self . penalty [ 0 ]] . iloc [ - 1 ] ) ) self . J [ - 1 ] += self . simulator . df_dict [ gid ][ cid ][ self . QoI ] . iloc [ - 1 ] self . gen_ctr += 1 return self . J [ - self . doe_size :]","title":"_evaluate"},{"location":"dev_optimizer/#optim.inspyred_optimizer.InspyredWolfOptimizer._observe","text":"Plots the n_plt best results each time a generation has been evaluated: the simulations residuals, the simulations CD & CL, the candidates fitness, the baseline and deformed profiles. Note num_generations , num_evaluations and args are inspyred mandatory arguments see https://pythonhosted.org/inspyred/examples.html#custom-observer Source code in aero_optim/optim/inspyred_optimizer.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 def _observe ( self , population : list [ Individual ], num_generations : int , num_evaluations : int , args : dict ): \"\"\" **Plots** the n_plt best results each time a generation has been evaluated:</br> > the simulations residuals,</br> > the simulations CD & CL,</br> > the candidates fitness,</br> > the baseline and deformed profiles. Note: __num_generations__, __num_evaluations__ and __args__ are inspyred mandatory arguments</br> see https://pythonhosted.org/inspyred/examples.html#custom-observer \"\"\" gid = num_generations # extract generation best profiles fitness : np . ndarray = np . array ( self . J [ - self . doe_size :]) sorted_idx = ( np . argsort ( fitness )[ - self . n_plt :] if self . maximize else np . argsort ( fitness )[: self . n_plt ] ) # compute population statistics self . compute_statistics ( np . array ([ ind . fitness for ind in population ])) logger . info ( f \"extracting { self . n_plt } best profiles in g { gid } : { sorted_idx } ..\" ) logger . debug ( f \"g { gid } J-fitnesses (candidates): { fitness } \" ) logger . debug ( f \"g { gid } P-fitness (population) { [ ind . fitness for ind in population ] } \" ) # plot settings fig_name = f \"inspyred_g { num_generations } .png\" self . plot_generation ( gid , sorted_idx , fitness , fig_name )","title":"_observe"},{"location":"dev_optimizer/#optim.inspyred_optimizer.InspyredWolfOptimizer.apply_constraints","text":"Returns a penalty value based on some specific constraints see https://inspyred.readthedocs.io/en/latest/recipes.html#constraint-selection Source code in aero_optim/optim/inspyred_optimizer.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def apply_constraints ( self , gid : int , cid : int , ffd_profile : np . ndarray , pen_value : float ) -> float : \"\"\" **Returns** a penalty value based on some specific constraints</br> see https://inspyred.readthedocs.io/en/latest/recipes.html#constraint-selection \"\"\" if not self . constraint : return 0. area_cond : bool = ( abs ( get_area ( ffd_profile )) > ( 1. + self . area_margin ) * self . baseline_area or abs ( get_area ( ffd_profile )) < ( 1. - self . area_margin ) * self . baseline_area ) penalty_cond : bool = pen_value < self . penalty [ - 1 ] if area_cond or penalty_cond : logger . info ( f \"penalized candidate g { gid } , c { cid } \" f \"with area { abs ( get_area ( ffd_profile )) } and CL { pen_value } \" ) return 1. return 0.","title":"apply_constraints"},{"location":"dev_optimizer/#optim.inspyred_optimizer.InspyredWolfOptimizer.final_observe","text":"Plots convergence progress by plotting the fitness values obtained with the successive generations see https://pythonhosted.org/inspyred/reference.html#inspyred.ec.analysis.generation_plot Source code in aero_optim/optim/inspyred_optimizer.py 119 120 121 122 123 124 125 126 def final_observe ( self , * args , ** kwargs ): \"\"\" **Plots** convergence progress by plotting the fitness values obtained with the successive generations</br> see https://pythonhosted.org/inspyred/reference.html#inspyred.ec.analysis.generation_plot \"\"\" fig_name = f \"inspyred_optim_g { self . gen_ctr - 1 } _c { self . doe_size } .png\" self . plot_progress ( self . gen_ctr - 1 , fig_name , baseline_value = self . baseline_CD )","title":"final_observe"},{"location":"dev_optimizer/#optim.inspyred_optimizer.InspyredDebugOptimizer","text":"Bases: DebugOptimizer Source code in aero_optim/optim/inspyred_optimizer.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 class InspyredDebugOptimizer ( DebugOptimizer ): def _evaluate ( self , candidates : list [ Individual ], args : dict ) -> list [ float | list [ float ]]: \"\"\" **Executes** dummy simulations, **extracts** results and **returns** the list of candidates QoIs. \"\"\" gid = self . gen_ctr # execute all candidates self . execute_candidates ( candidates , gid ) for cid , _ in enumerate ( candidates ): self . J . append ( self . simulator . df_dict [ gid ][ cid ][ \"result\" ] . iloc [ - 1 ]) self . gen_ctr += 1 return self . J [ - self . doe_size :] def _observe ( self , population : list [ Individual ], num_generations : int , num_evaluations : int , args : dict ): \"\"\" Dummy _observe function. \"\"\" # extract best profiles gid = num_generations fitness : np . ndarray = np . array ( self . J [ - self . doe_size :]) sorted_idx = np . argsort ( fitness , kind = \"stable\" )[: self . n_plt ] logger . info ( f \"extracting { self . n_plt } best profiles in g { gid } : { sorted_idx } ..\" ) logger . debug ( f \"g { gid } J-fitnesses (candidates): { fitness } \" ) logger . debug ( f \"g { gid } P-fitness (population) { [ ind . fitness for ind in population ] } \" ) # compute population statistics self . compute_statistics ( np . array ([ ind . fitness for ind in population ])) def final_observe ( self ): \"\"\" Dummy final_observe function. \"\"\" fig_name = f \"inspyred_optim_g { self . gen_ctr - 1 } _c { self . doe_size } .png\" self . plot_progress ( self . gen_ctr - 1 , fig_name )","title":"InspyredDebugOptimizer"},{"location":"dev_optimizer/#optim.inspyred_optimizer.InspyredDebugOptimizer._evaluate","text":"Executes dummy simulations, extracts results and returns the list of candidates QoIs. Source code in aero_optim/optim/inspyred_optimizer.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 def _evaluate ( self , candidates : list [ Individual ], args : dict ) -> list [ float | list [ float ]]: \"\"\" **Executes** dummy simulations, **extracts** results and **returns** the list of candidates QoIs. \"\"\" gid = self . gen_ctr # execute all candidates self . execute_candidates ( candidates , gid ) for cid , _ in enumerate ( candidates ): self . J . append ( self . simulator . df_dict [ gid ][ cid ][ \"result\" ] . iloc [ - 1 ]) self . gen_ctr += 1 return self . J [ - self . doe_size :]","title":"_evaluate"},{"location":"dev_optimizer/#optim.inspyred_optimizer.InspyredDebugOptimizer._observe","text":"Dummy _observe function. Source code in aero_optim/optim/inspyred_optimizer.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 def _observe ( self , population : list [ Individual ], num_generations : int , num_evaluations : int , args : dict ): \"\"\" Dummy _observe function. \"\"\" # extract best profiles gid = num_generations fitness : np . ndarray = np . array ( self . J [ - self . doe_size :]) sorted_idx = np . argsort ( fitness , kind = \"stable\" )[: self . n_plt ] logger . info ( f \"extracting { self . n_plt } best profiles in g { gid } : { sorted_idx } ..\" ) logger . debug ( f \"g { gid } J-fitnesses (candidates): { fitness } \" ) logger . debug ( f \"g { gid } P-fitness (population) { [ ind . fitness for ind in population ] } \" ) # compute population statistics self . compute_statistics ( np . array ([ ind . fitness for ind in population ]))","title":"_observe"},{"location":"dev_optimizer/#optim.inspyred_optimizer.InspyredDebugOptimizer.final_observe","text":"Dummy final_observe function. Source code in aero_optim/optim/inspyred_optimizer.py 167 168 169 170 171 172 def final_observe ( self ): \"\"\" Dummy final_observe function. \"\"\" fig_name = f \"inspyred_optim_g { self . gen_ctr - 1 } _c { self . doe_size } .png\" self . plot_progress ( self . gen_ctr - 1 , fig_name )","title":"final_observe"},{"location":"dev_optimizer/#pymoo-optimizers","text":"","title":"pymoo Optimizers"},{"location":"dev_optimizer/#optim.pymoo_optimizer.PymooWolfOptimizer","text":"Bases: WolfOptimizer , Problem This class implements a Wolf based Optimizer. Source code in aero_optim/optim/pymoo_optimizer.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 class PymooWolfOptimizer ( WolfOptimizer , Problem ): \"\"\" This class implements a Wolf based Optimizer. \"\"\" def __init__ ( self , config : dict ): \"\"\" Instantiates the WolfOptimizer object. **Input** - config (dict): the config file dictionary. \"\"\" WolfOptimizer . __init__ ( self , config ) Problem . __init__ ( self , n_var = self . n_design , n_obj = 1 , n_ieq_constr = 2 , xl = self . bound [ 0 ], xu = self . bound [ 1 ] ) def _evaluate ( self , X : np . ndarray , out : np . ndarray , * args , ** kwargs ): \"\"\" **Executes** Wolf simulations, **extracts** results and **returns** arrays of candidates QoIs and constraints. \"\"\" gid = self . gen_ctr # execute all candidates self . execute_candidates ( X , gid ) # update candidates fitness self . J . extend ([ self . simulator . df_dict [ gid ][ cid ][ self . QoI ] . iloc [ - 1 ] for cid in range ( len ( X )) ]) out [ \"F\" ] = np . array ( self . J [ - self . doe_size :]) out [ \"G\" ] = self . apply_constraints ( gid ) self . _observe ( out [ \"F\" ]) self . gen_ctr += 1 def apply_constraints ( self , gid : int ) -> np . ndarray : \"\"\" **Returns** a constraint array ensuring negative inequality</br> see https://pymoo.org/constraints/index.html \"\"\" out = [] if not self . constraint : return np . row_stack ([[ - 1 , - 1 ] for _ in range ( len ( self . ffd_profiles [ gid ]))]) for cid , pro in enumerate ( self . ffd_profiles [ gid ]): ieq_1 = ( abs ( abs ( get_area ( pro )) - self . baseline_area ) / self . baseline_area - self . area_margin ) ieq_2 = self . penalty [ - 1 ] - self . simulator . df_dict [ gid ][ cid ][ self . penalty [ 0 ]] . iloc [ - 1 ] if ieq_1 > 0 or ieq_2 > 0 : logger . info ( f \"penalized candidate g { gid } , c { cid } \" f \"with area { abs ( get_area ( pro )) } \" f \"and CL { self . simulator . df_dict [ gid ][ cid ][ self . penalty [ 0 ]] . iloc [ - 1 ] } \" ) out . append ([ ieq_1 , ieq_2 ]) return np . row_stack ( out ) def _observe ( self , pop_fitness : np . ndarray ): \"\"\" **Plots** the n_plt best results each time a generation has been evaluated:</br> > the simulations residuals,</br> > the simulations CD & CL,</br> > the candidates fitness,</br> > the baseline and deformed profiles. \"\"\" gid = self . gen_ctr # extract generation best profiles sorted_idx = np . argsort ( pop_fitness , kind = \"stable\" )[: self . n_plt ] # compute population statistics self . compute_statistics ( pop_fitness ) logger . info ( f \"extracting { self . n_plt } best profiles in g { gid } : { sorted_idx } ..\" ) logger . debug ( f \"g { gid } J-fitnesses: { pop_fitness } \" ) # plot settings fig_name = f \"pymoo_g { gid } .png\" self . plot_generation ( gid , sorted_idx , pop_fitness , fig_name ) def final_observe ( self , * args , ** kwargs ): \"\"\" **Plots** convergence progress by plotting the fitness values obtained with the successive generations \"\"\" fig_name = f \"pymoo_optim_g { self . gen_ctr } _c { self . doe_size } .png\" self . plot_progress ( self . gen_ctr , fig_name , baseline_value = self . baseline_CD )","title":"PymooWolfOptimizer"},{"location":"dev_optimizer/#optim.pymoo_optimizer.PymooWolfOptimizer.__init__","text":"Instantiates the WolfOptimizer object. Input config (dict): the config file dictionary. Source code in aero_optim/optim/pymoo_optimizer.py 34 35 36 37 38 39 40 41 42 43 44 45 def __init__ ( self , config : dict ): \"\"\" Instantiates the WolfOptimizer object. **Input** - config (dict): the config file dictionary. \"\"\" WolfOptimizer . __init__ ( self , config ) Problem . __init__ ( self , n_var = self . n_design , n_obj = 1 , n_ieq_constr = 2 , xl = self . bound [ 0 ], xu = self . bound [ 1 ] )","title":"__init__"},{"location":"dev_optimizer/#optim.pymoo_optimizer.PymooWolfOptimizer._evaluate","text":"Executes Wolf simulations, extracts results and returns arrays of candidates QoIs and constraints. Source code in aero_optim/optim/pymoo_optimizer.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def _evaluate ( self , X : np . ndarray , out : np . ndarray , * args , ** kwargs ): \"\"\" **Executes** Wolf simulations, **extracts** results and **returns** arrays of candidates QoIs and constraints. \"\"\" gid = self . gen_ctr # execute all candidates self . execute_candidates ( X , gid ) # update candidates fitness self . J . extend ([ self . simulator . df_dict [ gid ][ cid ][ self . QoI ] . iloc [ - 1 ] for cid in range ( len ( X )) ]) out [ \"F\" ] = np . array ( self . J [ - self . doe_size :]) out [ \"G\" ] = self . apply_constraints ( gid ) self . _observe ( out [ \"F\" ]) self . gen_ctr += 1","title":"_evaluate"},{"location":"dev_optimizer/#optim.pymoo_optimizer.PymooWolfOptimizer._observe","text":"Plots the n_plt best results each time a generation has been evaluated: the simulations residuals, the simulations CD & CL, the candidates fitness, the baseline and deformed profiles. Source code in aero_optim/optim/pymoo_optimizer.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def _observe ( self , pop_fitness : np . ndarray ): \"\"\" **Plots** the n_plt best results each time a generation has been evaluated:</br> > the simulations residuals,</br> > the simulations CD & CL,</br> > the candidates fitness,</br> > the baseline and deformed profiles. \"\"\" gid = self . gen_ctr # extract generation best profiles sorted_idx = np . argsort ( pop_fitness , kind = \"stable\" )[: self . n_plt ] # compute population statistics self . compute_statistics ( pop_fitness ) logger . info ( f \"extracting { self . n_plt } best profiles in g { gid } : { sorted_idx } ..\" ) logger . debug ( f \"g { gid } J-fitnesses: { pop_fitness } \" ) # plot settings fig_name = f \"pymoo_g { gid } .png\" self . plot_generation ( gid , sorted_idx , pop_fitness , fig_name )","title":"_observe"},{"location":"dev_optimizer/#optim.pymoo_optimizer.PymooWolfOptimizer.apply_constraints","text":"Returns a constraint array ensuring negative inequality see https://pymoo.org/constraints/index.html Source code in aero_optim/optim/pymoo_optimizer.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def apply_constraints ( self , gid : int ) -> np . ndarray : \"\"\" **Returns** a constraint array ensuring negative inequality</br> see https://pymoo.org/constraints/index.html \"\"\" out = [] if not self . constraint : return np . row_stack ([[ - 1 , - 1 ] for _ in range ( len ( self . ffd_profiles [ gid ]))]) for cid , pro in enumerate ( self . ffd_profiles [ gid ]): ieq_1 = ( abs ( abs ( get_area ( pro )) - self . baseline_area ) / self . baseline_area - self . area_margin ) ieq_2 = self . penalty [ - 1 ] - self . simulator . df_dict [ gid ][ cid ][ self . penalty [ 0 ]] . iloc [ - 1 ] if ieq_1 > 0 or ieq_2 > 0 : logger . info ( f \"penalized candidate g { gid } , c { cid } \" f \"with area { abs ( get_area ( pro )) } \" f \"and CL { self . simulator . df_dict [ gid ][ cid ][ self . penalty [ 0 ]] . iloc [ - 1 ] } \" ) out . append ([ ieq_1 , ieq_2 ]) return np . row_stack ( out )","title":"apply_constraints"},{"location":"dev_optimizer/#optim.pymoo_optimizer.PymooWolfOptimizer.final_observe","text":"Plots convergence progress by plotting the fitness values obtained with the successive generations Source code in aero_optim/optim/pymoo_optimizer.py 110 111 112 113 114 115 116 def final_observe ( self , * args , ** kwargs ): \"\"\" **Plots** convergence progress by plotting the fitness values obtained with the successive generations \"\"\" fig_name = f \"pymoo_optim_g { self . gen_ctr } _c { self . doe_size } .png\" self . plot_progress ( self . gen_ctr , fig_name , baseline_value = self . baseline_CD )","title":"final_observe"},{"location":"dev_optimizer/#optim.pymoo_optimizer.PymooDebugOptimizer","text":"Bases: DebugOptimizer , Problem Source code in aero_optim/optim/pymoo_optimizer.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 class PymooDebugOptimizer ( DebugOptimizer , Problem ): def __init__ ( self , config : dict ): \"\"\" Dummy init. \"\"\" DebugOptimizer . __init__ ( self , config ) Problem . __init__ ( self , n_var = self . n_design , n_obj = 1 , n_ieq_constr = 0 , xl = self . bound [ 0 ], xu = self . bound [ 1 ] ) def _evaluate ( self , X : np . ndarray , out : np . ndarray , * args , ** kwargs ): \"\"\" **Executes** dummy simulations, **extracts** results and **returns** the list of candidates QoIs. \"\"\" gid = self . gen_ctr # execute all candidates self . execute_candidates ( X , gid ) for cid , _ in enumerate ( X ): self . J . append ( self . simulator . df_dict [ gid ][ cid ][ \"result\" ] . iloc [ - 1 ]) out [ \"F\" ] = np . array ( self . J [ - self . doe_size :]) self . _observe ( out [ \"F\" ]) self . gen_ctr += 1 def _observe ( self , pop_fitness : np . ndarray ): \"\"\" Dummy _observe function. \"\"\" # extract best profiles gid = self . gen_ctr sorted_idx = np . argsort ( pop_fitness , kind = \"stable\" )[: self . n_plt ] logger . info ( f \"extracting { self . n_plt } best profiles in g { gid } : { sorted_idx } ..\" ) logger . debug ( f \"g { gid } J-fitnesses (candidates): { pop_fitness } \" ) # compute population statistics self . compute_statistics ( pop_fitness ) def final_observe ( self ): \"\"\" Dummy final_observe function. \"\"\" logger . info ( f \"plotting populations statistics after { self . gen_ctr } generations..\" ) fig_name = f \"pymoo_optim_g { self . gen_ctr } _c { self . doe_size } .png\" self . plot_progress ( self . gen_ctr , fig_name )","title":"PymooDebugOptimizer"},{"location":"dev_optimizer/#optim.pymoo_optimizer.PymooDebugOptimizer.__init__","text":"Dummy init. Source code in aero_optim/optim/pymoo_optimizer.py 209 210 211 212 213 214 215 216 def __init__ ( self , config : dict ): \"\"\" Dummy init. \"\"\" DebugOptimizer . __init__ ( self , config ) Problem . __init__ ( self , n_var = self . n_design , n_obj = 1 , n_ieq_constr = 0 , xl = self . bound [ 0 ], xu = self . bound [ 1 ] )","title":"__init__"},{"location":"dev_optimizer/#optim.pymoo_optimizer.PymooDebugOptimizer._evaluate","text":"Executes dummy simulations, extracts results and returns the list of candidates QoIs. Source code in aero_optim/optim/pymoo_optimizer.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 def _evaluate ( self , X : np . ndarray , out : np . ndarray , * args , ** kwargs ): \"\"\" **Executes** dummy simulations, **extracts** results and **returns** the list of candidates QoIs. \"\"\" gid = self . gen_ctr # execute all candidates self . execute_candidates ( X , gid ) for cid , _ in enumerate ( X ): self . J . append ( self . simulator . df_dict [ gid ][ cid ][ \"result\" ] . iloc [ - 1 ]) out [ \"F\" ] = np . array ( self . J [ - self . doe_size :]) self . _observe ( out [ \"F\" ]) self . gen_ctr += 1","title":"_evaluate"},{"location":"dev_optimizer/#optim.pymoo_optimizer.PymooDebugOptimizer._observe","text":"Dummy _observe function. Source code in aero_optim/optim/pymoo_optimizer.py 235 236 237 238 239 240 241 242 243 244 245 246 def _observe ( self , pop_fitness : np . ndarray ): \"\"\" Dummy _observe function. \"\"\" # extract best profiles gid = self . gen_ctr sorted_idx = np . argsort ( pop_fitness , kind = \"stable\" )[: self . n_plt ] logger . info ( f \"extracting { self . n_plt } best profiles in g { gid } : { sorted_idx } ..\" ) logger . debug ( f \"g { gid } J-fitnesses (candidates): { pop_fitness } \" ) # compute population statistics self . compute_statistics ( pop_fitness )","title":"_observe"},{"location":"dev_optimizer/#optim.pymoo_optimizer.PymooDebugOptimizer.final_observe","text":"Dummy final_observe function. Source code in aero_optim/optim/pymoo_optimizer.py 248 249 250 251 252 253 254 def final_observe ( self ): \"\"\" Dummy final_observe function. \"\"\" logger . info ( f \"plotting populations statistics after { self . gen_ctr } generations..\" ) fig_name = f \"pymoo_optim_g { self . gen_ctr } _c { self . doe_size } .png\" self . plot_progress ( self . gen_ctr , fig_name )","title":"final_observe"},{"location":"dev_optimizer/#generator-class","text":"","title":"Generator class"},{"location":"dev_optimizer/#optim.generator.Generator","text":"This class defines a custom generator based on scipy.qmc samplers. Source code in aero_optim/optim/generator.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 class Generator : \"\"\" This class defines a custom generator based on scipy.qmc samplers. \"\"\" # some samplers available from scipy.qmc # see https://docs.scipy.org/doc/scipy/reference/stats.qmc.html sampler_list : list [ str ] = [ \"lhs\" , \"halton\" , \"sobol\" , \"custom\" ] def __init__ ( self , seed : int , ndesign : int , doe_size : int , sampler_name : str , bound : tuple [ Any , ... ], custom_doe : str = \"\" ): \"\"\" Instantiates the Generator class with some optimization parameters and the sampler name. **Input** - seed (int): seed number of the sampler random number generator. - ndesign (int): the number of design variables (dimensions of the problem). - doe_size (int): the size of the initial and subsequent generations. - sampler_name (str): name of the sampling algorithm used to generate samples. - bound (tuple[Any, ...]): design variables boundaries. - custom_doe (str): path to the text file containing a custom doe. **Inner** - initial_doe (list[list[float]]): the initial generation sampled from the generator. \"\"\" self . seed : int = seed self . ndesign : int = ndesign self . doe_size : int = doe_size self . sampler : Optional [ qmc . QMCEngine ] = self . get_sampler ( \"custom\" if custom_doe else sampler_name ) self . bound : tuple [ Any , ... ] = bound self . initial_doe : list [ list [ float ]] = self . sample_doe ( custom_doe ) def get_sampler ( self , sampler_name : str ) -> Optional [ qmc . QMCEngine ]: \"\"\" **Returns** scipy qmc sampler. \"\"\" if sampler_name not in self . sampler_list : raise Exception ( f \"Unrecognized sampler { sampler_name } \" ) else : return ( qmc . LatinHypercube ( d = self . ndesign , seed = self . seed ) if sampler_name == \"lhs\" else qmc . Halton ( d = self . ndesign , seed = self . seed ) if sampler_name == \"halton\" else qmc . Sobol ( d = self . ndesign , seed = self . seed ) if sampler_name == \"sobol\" else None ) def sample_doe ( self , custom_doe : str ) -> list [ list [ float ]]: return ( self . sampler . random ( n = self . doe_size ) . tolist () if self . sampler else [ [ float ( xi ) for xi in X . strip () . split ()] for X in open ( custom_doe , \"r\" ) . read () . splitlines () ] ) def _ins_generator ( self , random : Random , args : dict ) -> list [ float ]: \"\"\" **Returns** a single sample from the initial generation. Note: __random__ and __args__ are inspyred mandatory arguments</br> see https://pythonhosted.org/inspyred/tutorial.html#the-generator \"\"\" element = self . initial_doe . pop ( 0 ) return qmc . scale ([ element ], * self . bound ) . tolist ()[ 0 ] if self . sampler else element def _pymoo_generator ( self ) -> np . ndarray : \"\"\" **Returns** all samples from the initial generation. \"\"\" return ( qmc . scale ( self . initial_doe , * self . bound ) if self . sampler else np . array ( self . initial_doe ) )","title":"Generator"},{"location":"dev_optimizer/#optim.generator.Generator.__init__","text":"Instantiates the Generator class with some optimization parameters and the sampler name. Input seed (int): seed number of the sampler random number generator. ndesign (int): the number of design variables (dimensions of the problem). doe_size (int): the size of the initial and subsequent generations. sampler_name (str): name of the sampling algorithm used to generate samples. bound (tuple[Any, ...]): design variables boundaries. custom_doe (str): path to the text file containing a custom doe. Inner initial_doe (list[list[float]]): the initial generation sampled from the generator. Source code in aero_optim/optim/generator.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def __init__ ( self , seed : int , ndesign : int , doe_size : int , sampler_name : str , bound : tuple [ Any , ... ], custom_doe : str = \"\" ): \"\"\" Instantiates the Generator class with some optimization parameters and the sampler name. **Input** - seed (int): seed number of the sampler random number generator. - ndesign (int): the number of design variables (dimensions of the problem). - doe_size (int): the size of the initial and subsequent generations. - sampler_name (str): name of the sampling algorithm used to generate samples. - bound (tuple[Any, ...]): design variables boundaries. - custom_doe (str): path to the text file containing a custom doe. **Inner** - initial_doe (list[list[float]]): the initial generation sampled from the generator. \"\"\" self . seed : int = seed self . ndesign : int = ndesign self . doe_size : int = doe_size self . sampler : Optional [ qmc . QMCEngine ] = self . get_sampler ( \"custom\" if custom_doe else sampler_name ) self . bound : tuple [ Any , ... ] = bound self . initial_doe : list [ list [ float ]] = self . sample_doe ( custom_doe )","title":"__init__"},{"location":"dev_optimizer/#optim.generator.Generator._ins_generator","text":"Returns a single sample from the initial generation. Note random and args are inspyred mandatory arguments see https://pythonhosted.org/inspyred/tutorial.html#the-generator Source code in aero_optim/optim/generator.py 71 72 73 74 75 76 77 78 79 80 def _ins_generator ( self , random : Random , args : dict ) -> list [ float ]: \"\"\" **Returns** a single sample from the initial generation. Note: __random__ and __args__ are inspyred mandatory arguments</br> see https://pythonhosted.org/inspyred/tutorial.html#the-generator \"\"\" element = self . initial_doe . pop ( 0 ) return qmc . scale ([ element ], * self . bound ) . tolist ()[ 0 ] if self . sampler else element","title":"_ins_generator"},{"location":"dev_optimizer/#optim.generator.Generator._pymoo_generator","text":"Returns all samples from the initial generation. Source code in aero_optim/optim/generator.py 82 83 84 85 86 87 88 def _pymoo_generator ( self ) -> np . ndarray : \"\"\" **Returns** all samples from the initial generation. \"\"\" return ( qmc . scale ( self . initial_doe , * self . bound ) if self . sampler else np . array ( self . initial_doe ) )","title":"_pymoo_generator"},{"location":"dev_optimizer/#optim.generator.Generator.get_sampler","text":"Returns scipy qmc sampler. Source code in aero_optim/optim/generator.py 48 49 50 51 52 53 54 55 56 57 58 59 60 def get_sampler ( self , sampler_name : str ) -> Optional [ qmc . QMCEngine ]: \"\"\" **Returns** scipy qmc sampler. \"\"\" if sampler_name not in self . sampler_list : raise Exception ( f \"Unrecognized sampler { sampler_name } \" ) else : return ( qmc . LatinHypercube ( d = self . ndesign , seed = self . seed ) if sampler_name == \"lhs\" else qmc . Halton ( d = self . ndesign , seed = self . seed ) if sampler_name == \"halton\" else qmc . Sobol ( d = self . ndesign , seed = self . seed ) if sampler_name == \"sobol\" else None )","title":"get_sampler"},{"location":"dev_simulator/","text":"Simulator Source Code simulator.simulator.Simulator Bases: ABC This class implements an abstract simulation class. Source code in aero_optim/simulator/simulator.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 class Simulator ( ABC ): \"\"\" This class implements an abstract simulation class. \"\"\" def __init__ ( self , config : dict ): \"\"\" Instantiates the Simulator object. **Input** - config (dict): the config file dictionary. **Inner** - cwd (str): the working directory. - solver_name (str): the solver name. - outdir (str): the output directory where the simulation results folder will be stored. - exec_cmd (list[str]): solver execution command. - ref_input (str): a simulation input file template. - sim_args (dict): arguments to modify to customize ref_input. - files_to_cp (list[str]): list of files to be copied to the output directory. - post_process_args (dict): quantities to extract from result files. - df_dict (dict): dictionary of dataframes containing all simulations extracted quantities. \"\"\" self . cwd : str = os . getcwd () self . config = config self . process_config () self . set_solver_name () # study params self . outdir : str = config [ \"study\" ][ \"outdir\" ] # simulator params self . exec_cmd : list [ str ] = config [ \"simulator\" ][ \"exec_cmd\" ] . split ( \" \" ) self . ref_input : str = config [ \"simulator\" ][ \"ref_input\" ] self . sim_args : dict = config [ \"simulator\" ] . get ( \"sim_args\" , {}) self . files_to_cp : list [ str ] = config [ \"simulator\" ] . get ( \"files_to_cp\" , []) self . post_process_args : dict = config [ \"simulator\" ] . get ( \"post_process\" , {}) # simulation results self . df_dict : dict [ int , dict [ int , pd . DataFrame ]] = {} def custom_input ( self , fname : str ): \"\"\" **Writes** a customized input file. \"\"\" ref_output = open ( self . ref_input , \"r\" ) . read () . splitlines () for key , value in self . sim_args . items (): idx = ref_output . index ( key ) # in place substitution # {\"keyword\": {{\"inplace\": true}, {'param': [param]}}} if value [ \"inplace\" ]: logger . info ( f \" { key } : replace { ref_output [ idx ] } by { value [ 'param' ][ 0 ] } \" ) ref_output [ idx ] = value [ 'param' ][ 0 ] # multiline substitution # {\"keyword\": {{\"inplace\": false}, {'param': [param0, param1, param..]}}} else : for ii , param in enumerate ( value [ 'param' ]): logger . info ( f \" { key } : replace { ref_output [ idx + 1 + ii ] } by { param } \" ) ref_output [ idx + 1 + ii ] = param with open ( fname , 'w' ) as ftw : ftw . write ( \" \\n \" . join ( ref_output )) logger . info ( f \"input file saved to { fname } \" ) def get_sim_outdir ( self , gid : int = 0 , cid : int = 0 ) -> str : \"\"\" **Returns** the path to the folder containing the simulation results. \"\"\" return os . path . join ( self . outdir , f \" { self . solver_name . upper () } \" , f \" { self . solver_name } _g { gid } _c { cid } \" ) def kill_all ( self , * args , ** kwargs ): \"\"\" **Kills** all active simulations. \"\"\" logger . debug ( \"kill_all not implemented\" ) @abstractmethod def set_solver_name ( self ): \"\"\" Sets the solver_name attribute. \"\"\" self . solver_name = \"solver\" @abstractmethod def process_config ( self ): \"\"\" Makes sure the config file contains the required information. \"\"\" @abstractmethod def execute_sim ( self , * args , ** kwargs ): \"\"\" Runs a single simulation. \"\"\" __init__ ( config : dict ) Instantiates the Simulator object. Input config (dict): the config file dictionary. Inner cwd (str): the working directory. solver_name (str): the solver name. outdir (str): the output directory where the simulation results folder will be stored. exec_cmd (list[str]): solver execution command. ref_input (str): a simulation input file template. sim_args (dict): arguments to modify to customize ref_input. files_to_cp (list[str]): list of files to be copied to the output directory. post_process_args (dict): quantities to extract from result files. df_dict (dict): dictionary of dataframes containing all simulations extracted quantities. Source code in aero_optim/simulator/simulator.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def __init__ ( self , config : dict ): \"\"\" Instantiates the Simulator object. **Input** - config (dict): the config file dictionary. **Inner** - cwd (str): the working directory. - solver_name (str): the solver name. - outdir (str): the output directory where the simulation results folder will be stored. - exec_cmd (list[str]): solver execution command. - ref_input (str): a simulation input file template. - sim_args (dict): arguments to modify to customize ref_input. - files_to_cp (list[str]): list of files to be copied to the output directory. - post_process_args (dict): quantities to extract from result files. - df_dict (dict): dictionary of dataframes containing all simulations extracted quantities. \"\"\" self . cwd : str = os . getcwd () self . config = config self . process_config () self . set_solver_name () # study params self . outdir : str = config [ \"study\" ][ \"outdir\" ] # simulator params self . exec_cmd : list [ str ] = config [ \"simulator\" ][ \"exec_cmd\" ] . split ( \" \" ) self . ref_input : str = config [ \"simulator\" ][ \"ref_input\" ] self . sim_args : dict = config [ \"simulator\" ] . get ( \"sim_args\" , {}) self . files_to_cp : list [ str ] = config [ \"simulator\" ] . get ( \"files_to_cp\" , []) self . post_process_args : dict = config [ \"simulator\" ] . get ( \"post_process\" , {}) # simulation results self . df_dict : dict [ int , dict [ int , pd . DataFrame ]] = {} custom_input ( fname : str ) Writes a customized input file. Source code in aero_optim/simulator/simulator.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def custom_input ( self , fname : str ): \"\"\" **Writes** a customized input file. \"\"\" ref_output = open ( self . ref_input , \"r\" ) . read () . splitlines () for key , value in self . sim_args . items (): idx = ref_output . index ( key ) # in place substitution # {\"keyword\": {{\"inplace\": true}, {'param': [param]}}} if value [ \"inplace\" ]: logger . info ( f \" { key } : replace { ref_output [ idx ] } by { value [ 'param' ][ 0 ] } \" ) ref_output [ idx ] = value [ 'param' ][ 0 ] # multiline substitution # {\"keyword\": {{\"inplace\": false}, {'param': [param0, param1, param..]}}} else : for ii , param in enumerate ( value [ 'param' ]): logger . info ( f \" { key } : replace { ref_output [ idx + 1 + ii ] } by { param } \" ) ref_output [ idx + 1 + ii ] = param with open ( fname , 'w' ) as ftw : ftw . write ( \" \\n \" . join ( ref_output )) logger . info ( f \"input file saved to { fname } \" ) execute_sim ( * args , ** kwargs ) abstractmethod Runs a single simulation. Source code in aero_optim/simulator/simulator.py 103 104 105 106 107 @abstractmethod def execute_sim ( self , * args , ** kwargs ): \"\"\" Runs a single simulation. \"\"\" get_sim_outdir ( gid : int = 0 , cid : int = 0 ) -> str Returns the path to the folder containing the simulation results. Source code in aero_optim/simulator/simulator.py 75 76 77 78 79 80 81 82 def get_sim_outdir ( self , gid : int = 0 , cid : int = 0 ) -> str : \"\"\" **Returns** the path to the folder containing the simulation results. \"\"\" return os . path . join ( self . outdir , f \" { self . solver_name . upper () } \" , f \" { self . solver_name } _g { gid } _c { cid } \" ) kill_all ( * args , ** kwargs ) Kills all active simulations. Source code in aero_optim/simulator/simulator.py 84 85 86 87 88 def kill_all ( self , * args , ** kwargs ): \"\"\" **Kills** all active simulations. \"\"\" logger . debug ( \"kill_all not implemented\" ) process_config () abstractmethod Makes sure the config file contains the required information. Source code in aero_optim/simulator/simulator.py 97 98 99 100 101 @abstractmethod def process_config ( self ): \"\"\" Makes sure the config file contains the required information. \"\"\" set_solver_name () abstractmethod Sets the solver_name attribute. Source code in aero_optim/simulator/simulator.py 90 91 92 93 94 95 @abstractmethod def set_solver_name ( self ): \"\"\" Sets the solver_name attribute. \"\"\" self . solver_name = \"solver\" simulator.simulator.WolfSimulator Bases: Simulator This class implements a simulator for the CFD code WOLF. Source code in aero_optim/simulator/simulator.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 class WolfSimulator ( Simulator ): \"\"\" This class implements a simulator for the CFD code WOLF. \"\"\" def __init__ ( self , config : dict ): \"\"\" Instantiates the WolfSimulator object. **Input** - config (dict): the config file dictionary. **Inner** - exec_cmd (list[str]): solver execution command. Note: with wolf, the exec_cmd is expected to contain a @.mesh argument that is automatically replaced with the simulation input mesh file name. - sim_pro (list[tuple[dict, subprocess.Popen[str]]]): list to track simulations and their associated subprocess. It has the following form: ({'gid': gid, 'cid': cid, 'meshfile': meshfile, 'restart': restart}, subprocess). - restart (int): how many times a simulation is allowed to be restarted in case of failure. \"\"\" super () . __init__ ( config ) self . sim_pro : list [ tuple [ dict , subprocess . Popen [ str ]]] = [] self . restart : int = config [ \"simulator\" ] . get ( \"restart\" , 0 ) def process_config ( self ): \"\"\" **Makes sure** the config file contains the required information and extracts it. \"\"\" logger . debug ( \"processing config..\" ) if \"exec_cmd\" not in self . config [ \"simulator\" ]: raise Exception ( f \"ERROR -- no <exec_cmd> entry in { self . config [ 'simulator' ] } \" ) if \"ref_input\" not in self . config [ \"simulator\" ]: raise Exception ( f \"ERROR -- no <ref_input> entry in { self . config [ 'simulator' ] } \" ) if \"sim_args\" not in self . config [ \"simulator\" ]: logger . debug ( f \"no <sim_args> entry in { self . config [ 'simulator' ] } \" ) if \"post_process\" not in self . config [ \"simulator\" ]: logger . debug ( f \"no <post_process> entry in { self . config [ 'simulator' ] } \" ) def set_solver_name ( self ): \"\"\" **Sets** the solver name to wolf. \"\"\" self . solver_name = \"wolf\" def execute_sim ( self , meshfile : str = \"\" , gid : int = 0 , cid : int = 0 , restart : int = 0 ): \"\"\" **Pre-processes** and **executes** a Wolf simulation. \"\"\" # add gid entry to the results dictionary if gid not in self . df_dict : self . df_dict [ gid ] = {} try : sim_outdir = self . get_sim_outdir ( gid , cid ) dict_id : dict = { \"gid\" : gid , \"cid\" : cid , \"meshfile\" : meshfile } self . df_dict [ dict_id [ \"gid\" ]][ dict_id [ \"cid\" ]] = self . post_process ( dict_id , sim_outdir ) logger . info ( f \"g { gid } , c { cid } : loaded pre-existing results from files\" ) except FileNotFoundError : # Pre-process sim_outdir , exec_cmd = self . pre_process ( meshfile , gid , cid ) # Execution self . execute ( sim_outdir , exec_cmd , gid , cid , meshfile , restart ) def pre_process ( self , meshfile : str , gid : int , cid : int ) -> tuple [ str , list [ str ]]: \"\"\" **Pre-processes** the simulation execution and **returns** the execution command and directory. \"\"\" # get the simulation meshfile full_meshfile = meshfile if meshfile else self . config [ \"simulator\" ][ \"file\" ] path_to_meshfile : str = \"/\" . join ( full_meshfile . split ( \"/\" )[: - 1 ]) meshfile = full_meshfile . split ( \"/\" )[ - 1 ] # generate custom input by altering the wolf template sim_outdir = self . get_sim_outdir ( gid = gid , cid = cid ) check_dir ( sim_outdir ) self . custom_input ( os . path . join ( sim_outdir , f \" { meshfile . split ( '.' )[ 0 ] } .wolf\" )) # copy meshfile to the output directory shutil . copy ( os . path . join ( path_to_meshfile , meshfile ), sim_outdir ) logger . info ( f \" { os . path . join ( path_to_meshfile , meshfile ) } copied to { sim_outdir } \" ) # copy any other solver expected files suffix_list = [ file . split ( \".\" )[ - 1 ] for file in self . files_to_cp ] [ shutil . copy ( file , os . path . join ( sim_outdir , f \" { meshfile . split ( '.' )[ 0 ] } . { suffix } \" )) for file , suffix in zip ( self . files_to_cp , suffix_list )] logger . info ( f \" { self . files_to_cp } copied to { sim_outdir } \" ) # update the execution command with the right mesh file exec_cmd = self . exec_cmd . copy () idx = self . exec_cmd . index ( \"@.mesh\" ) exec_cmd [ idx ] = os . path . join ( meshfile ) return sim_outdir , exec_cmd def execute ( self , sim_outdir : str , exec_cmd : list [ str ], gid : int , cid : int , meshfile : str , restart : int ): \"\"\" **Submits** the simulation subprocess and **updates** sim_pro. \"\"\" # move to the output directory, execute wolf and move back to the main directory os . chdir ( sim_outdir ) with open ( f \" { self . solver_name } _g { gid } _c { cid } .out\" , \"wb\" ) as out : with open ( f \" { self . solver_name } _g { gid } _c { cid } .err\" , \"wb\" ) as err : logger . info ( f \"execute simulation g { gid } , c { cid } with { self . solver_name } \" ) proc = subprocess . Popen ( exec_cmd , env = os . environ , stdin = subprocess . DEVNULL , stdout = out , stderr = err , universal_newlines = True ) os . chdir ( self . cwd ) # append simulation to the list of active processes self . sim_pro . append ( ({ \"gid\" : gid , \"cid\" : cid , \"meshfile\" : meshfile , \"restart\" : restart }, proc ) ) def monitor_sim_progress ( self ) -> int : \"\"\" **Updates** the list of simulations under execution and **returns** its length. \"\"\" finished_sim = [] # loop over the list of simulation processes for id , ( dict_id , p_id ) in enumerate ( self . sim_pro ): returncode = p_id . poll () if returncode is None : pass # simulation still running elif returncode == 0 : logger . info ( f \"simulation { dict_id } finished\" ) finished_sim . append ( id ) sim_outdir = self . get_sim_outdir ( dict_id [ \"gid\" ], dict_id [ \"cid\" ]) self . df_dict [ dict_id [ \"gid\" ]][ dict_id [ \"cid\" ]] = self . post_process ( dict_id , sim_outdir ) break else : if dict_id [ \"restart\" ] < self . restart : logger . error ( f \"ERROR -- simulation { dict_id } crashed and will be restarted\" ) finished_sim . append ( id ) sim_out_dir = self . get_sim_outdir ( dict_id [ \"gid\" ], dict_id [ \"cid\" ]) shutil . rmtree ( sim_out_dir , ignore_errors = True ) self . execute_sim ( dict_id [ \"meshfile\" ], dict_id [ \"gid\" ], dict_id [ \"cid\" ], dict_id [ \"restart\" ] + 1 ) else : raise Exception ( f \"ERROR -- simulation { dict_id } crashed\" ) # update the list of active processes self . sim_pro = [ tup for id , tup in enumerate ( self . sim_pro ) if id not in finished_sim ] return len ( self . sim_pro ) def post_process ( self , dict_id : dict , sim_out_dir : str ) -> pd . DataFrame : \"\"\" **Post-processes** the results of a terminated simulation.</br> **Returns** the extracted results in a DataFrame. \"\"\" qty_list : list [ list [ float ]] = [] head_list : list [ str ] = [] # loop over the post-processing arguments to extract from the results for key , value in self . post_process_args . items (): # filter removes possible blank lines avoiding index out of range errors file = list ( filter ( None , open ( os . path . join ( sim_out_dir , key ), \"r\" ) . read () . splitlines ())) headers = file [ 0 ][ 2 :] . split () # ignore \"# \" before first item in headers for qty in value : try : idx = headers . index ( qty ) qty_list . append ([ float ( line . split ()[ idx ]) for line in file [ 1 :]]) head_list . append ( qty ) except Exception as e : logger . warning ( f \"could not read { qty } in { headers } \" ) logger . warning ( f \"exception { e } was raised\" ) # pd.Series allows columns of different lengths df = pd . DataFrame ({ head_list [ i ]: pd . Series ( qty_list [ i ]) for i in range ( len ( qty_list ))}) logger . info ( f \"g { dict_id [ 'gid' ] } , c { dict_id [ 'cid' ] } converged in { len ( df ) } it.\" ) logger . info ( f \"last values: \\n { df . tail ( n = 1 ) . to_string ( index = False ) } \" ) return df def kill_all ( self ): \"\"\" **Kills** all active processes. \"\"\" logger . info ( f \" { len ( self . sim_pro ) } remaining simulation(s) will be killed\" ) _ = [ subpro . terminate () for _ , subpro in self . sim_pro ] __init__ ( config : dict ) Instantiates the WolfSimulator object. Input config (dict): the config file dictionary. Inner exec_cmd (list[str]): solver execution command. Note with wolf, the exec_cmd is expected to contain a @.mesh argument that is automatically replaced with the simulation input mesh file name. sim_pro (list[tuple[dict, subprocess.Popen[str]]]): list to track simulations and their associated subprocess. It has the following form: ({'gid': gid, 'cid': cid, 'meshfile': meshfile, 'restart': restart}, subprocess). restart (int): how many times a simulation is allowed to be restarted in case of failure. Source code in aero_optim/simulator/simulator.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 def __init__ ( self , config : dict ): \"\"\" Instantiates the WolfSimulator object. **Input** - config (dict): the config file dictionary. **Inner** - exec_cmd (list[str]): solver execution command. Note: with wolf, the exec_cmd is expected to contain a @.mesh argument that is automatically replaced with the simulation input mesh file name. - sim_pro (list[tuple[dict, subprocess.Popen[str]]]): list to track simulations and their associated subprocess. It has the following form: ({'gid': gid, 'cid': cid, 'meshfile': meshfile, 'restart': restart}, subprocess). - restart (int): how many times a simulation is allowed to be restarted in case of failure. \"\"\" super () . __init__ ( config ) self . sim_pro : list [ tuple [ dict , subprocess . Popen [ str ]]] = [] self . restart : int = config [ \"simulator\" ] . get ( \"restart\" , 0 ) execute ( sim_outdir : str , exec_cmd : list [ str ], gid : int , cid : int , meshfile : str , restart : int ) Submits the simulation subprocess and updates sim_pro. Source code in aero_optim/simulator/simulator.py 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 def execute ( self , sim_outdir : str , exec_cmd : list [ str ], gid : int , cid : int , meshfile : str , restart : int ): \"\"\" **Submits** the simulation subprocess and **updates** sim_pro. \"\"\" # move to the output directory, execute wolf and move back to the main directory os . chdir ( sim_outdir ) with open ( f \" { self . solver_name } _g { gid } _c { cid } .out\" , \"wb\" ) as out : with open ( f \" { self . solver_name } _g { gid } _c { cid } .err\" , \"wb\" ) as err : logger . info ( f \"execute simulation g { gid } , c { cid } with { self . solver_name } \" ) proc = subprocess . Popen ( exec_cmd , env = os . environ , stdin = subprocess . DEVNULL , stdout = out , stderr = err , universal_newlines = True ) os . chdir ( self . cwd ) # append simulation to the list of active processes self . sim_pro . append ( ({ \"gid\" : gid , \"cid\" : cid , \"meshfile\" : meshfile , \"restart\" : restart }, proc ) ) execute_sim ( meshfile : str = '' , gid : int = 0 , cid : int = 0 , restart : int = 0 ) Pre-processes and executes a Wolf simulation. Source code in aero_optim/simulator/simulator.py 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 def execute_sim ( self , meshfile : str = \"\" , gid : int = 0 , cid : int = 0 , restart : int = 0 ): \"\"\" **Pre-processes** and **executes** a Wolf simulation. \"\"\" # add gid entry to the results dictionary if gid not in self . df_dict : self . df_dict [ gid ] = {} try : sim_outdir = self . get_sim_outdir ( gid , cid ) dict_id : dict = { \"gid\" : gid , \"cid\" : cid , \"meshfile\" : meshfile } self . df_dict [ dict_id [ \"gid\" ]][ dict_id [ \"cid\" ]] = self . post_process ( dict_id , sim_outdir ) logger . info ( f \"g { gid } , c { cid } : loaded pre-existing results from files\" ) except FileNotFoundError : # Pre-process sim_outdir , exec_cmd = self . pre_process ( meshfile , gid , cid ) # Execution self . execute ( sim_outdir , exec_cmd , gid , cid , meshfile , restart ) kill_all () Kills all active processes. Source code in aero_optim/simulator/simulator.py 300 301 302 303 304 305 def kill_all ( self ): \"\"\" **Kills** all active processes. \"\"\" logger . info ( f \" { len ( self . sim_pro ) } remaining simulation(s) will be killed\" ) _ = [ subpro . terminate () for _ , subpro in self . sim_pro ] monitor_sim_progress () -> int Updates the list of simulations under execution and returns its length. Source code in aero_optim/simulator/simulator.py 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 def monitor_sim_progress ( self ) -> int : \"\"\" **Updates** the list of simulations under execution and **returns** its length. \"\"\" finished_sim = [] # loop over the list of simulation processes for id , ( dict_id , p_id ) in enumerate ( self . sim_pro ): returncode = p_id . poll () if returncode is None : pass # simulation still running elif returncode == 0 : logger . info ( f \"simulation { dict_id } finished\" ) finished_sim . append ( id ) sim_outdir = self . get_sim_outdir ( dict_id [ \"gid\" ], dict_id [ \"cid\" ]) self . df_dict [ dict_id [ \"gid\" ]][ dict_id [ \"cid\" ]] = self . post_process ( dict_id , sim_outdir ) break else : if dict_id [ \"restart\" ] < self . restart : logger . error ( f \"ERROR -- simulation { dict_id } crashed and will be restarted\" ) finished_sim . append ( id ) sim_out_dir = self . get_sim_outdir ( dict_id [ \"gid\" ], dict_id [ \"cid\" ]) shutil . rmtree ( sim_out_dir , ignore_errors = True ) self . execute_sim ( dict_id [ \"meshfile\" ], dict_id [ \"gid\" ], dict_id [ \"cid\" ], dict_id [ \"restart\" ] + 1 ) else : raise Exception ( f \"ERROR -- simulation { dict_id } crashed\" ) # update the list of active processes self . sim_pro = [ tup for id , tup in enumerate ( self . sim_pro ) if id not in finished_sim ] return len ( self . sim_pro ) post_process ( dict_id : dict , sim_out_dir : str ) -> pd . DataFrame Post-processes the results of a terminated simulation. Returns the extracted results in a DataFrame. Source code in aero_optim/simulator/simulator.py 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 def post_process ( self , dict_id : dict , sim_out_dir : str ) -> pd . DataFrame : \"\"\" **Post-processes** the results of a terminated simulation.</br> **Returns** the extracted results in a DataFrame. \"\"\" qty_list : list [ list [ float ]] = [] head_list : list [ str ] = [] # loop over the post-processing arguments to extract from the results for key , value in self . post_process_args . items (): # filter removes possible blank lines avoiding index out of range errors file = list ( filter ( None , open ( os . path . join ( sim_out_dir , key ), \"r\" ) . read () . splitlines ())) headers = file [ 0 ][ 2 :] . split () # ignore \"# \" before first item in headers for qty in value : try : idx = headers . index ( qty ) qty_list . append ([ float ( line . split ()[ idx ]) for line in file [ 1 :]]) head_list . append ( qty ) except Exception as e : logger . warning ( f \"could not read { qty } in { headers } \" ) logger . warning ( f \"exception { e } was raised\" ) # pd.Series allows columns of different lengths df = pd . DataFrame ({ head_list [ i ]: pd . Series ( qty_list [ i ]) for i in range ( len ( qty_list ))}) logger . info ( f \"g { dict_id [ 'gid' ] } , c { dict_id [ 'cid' ] } converged in { len ( df ) } it.\" ) logger . info ( f \"last values: \\n { df . tail ( n = 1 ) . to_string ( index = False ) } \" ) return df pre_process ( meshfile : str , gid : int , cid : int ) -> tuple [ str , list [ str ]] Pre-processes the simulation execution and returns the execution command and directory. Source code in aero_optim/simulator/simulator.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 def pre_process ( self , meshfile : str , gid : int , cid : int ) -> tuple [ str , list [ str ]]: \"\"\" **Pre-processes** the simulation execution and **returns** the execution command and directory. \"\"\" # get the simulation meshfile full_meshfile = meshfile if meshfile else self . config [ \"simulator\" ][ \"file\" ] path_to_meshfile : str = \"/\" . join ( full_meshfile . split ( \"/\" )[: - 1 ]) meshfile = full_meshfile . split ( \"/\" )[ - 1 ] # generate custom input by altering the wolf template sim_outdir = self . get_sim_outdir ( gid = gid , cid = cid ) check_dir ( sim_outdir ) self . custom_input ( os . path . join ( sim_outdir , f \" { meshfile . split ( '.' )[ 0 ] } .wolf\" )) # copy meshfile to the output directory shutil . copy ( os . path . join ( path_to_meshfile , meshfile ), sim_outdir ) logger . info ( f \" { os . path . join ( path_to_meshfile , meshfile ) } copied to { sim_outdir } \" ) # copy any other solver expected files suffix_list = [ file . split ( \".\" )[ - 1 ] for file in self . files_to_cp ] [ shutil . copy ( file , os . path . join ( sim_outdir , f \" { meshfile . split ( '.' )[ 0 ] } . { suffix } \" )) for file , suffix in zip ( self . files_to_cp , suffix_list )] logger . info ( f \" { self . files_to_cp } copied to { sim_outdir } \" ) # update the execution command with the right mesh file exec_cmd = self . exec_cmd . copy () idx = self . exec_cmd . index ( \"@.mesh\" ) exec_cmd [ idx ] = os . path . join ( meshfile ) return sim_outdir , exec_cmd process_config () Makes sure the config file contains the required information and extracts it. Source code in aero_optim/simulator/simulator.py 142 143 144 145 146 147 148 149 150 151 152 153 154 def process_config ( self ): \"\"\" **Makes sure** the config file contains the required information and extracts it. \"\"\" logger . debug ( \"processing config..\" ) if \"exec_cmd\" not in self . config [ \"simulator\" ]: raise Exception ( f \"ERROR -- no <exec_cmd> entry in { self . config [ 'simulator' ] } \" ) if \"ref_input\" not in self . config [ \"simulator\" ]: raise Exception ( f \"ERROR -- no <ref_input> entry in { self . config [ 'simulator' ] } \" ) if \"sim_args\" not in self . config [ \"simulator\" ]: logger . debug ( f \"no <sim_args> entry in { self . config [ 'simulator' ] } \" ) if \"post_process\" not in self . config [ \"simulator\" ]: logger . debug ( f \"no <post_process> entry in { self . config [ 'simulator' ] } \" ) set_solver_name () Sets the solver name to wolf. Source code in aero_optim/simulator/simulator.py 156 157 158 159 160 def set_solver_name ( self ): \"\"\" **Sets** the solver name to wolf. \"\"\" self . solver_name = \"wolf\" simulator.simulator.DebugSimulator Bases: Simulator This class implements a basic simulator for debugging purposes. Source code in aero_optim/simulator/simulator.py 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 class DebugSimulator ( Simulator ): \"\"\" This class implements a basic simulator for debugging purposes. \"\"\" def __init__ ( self , config : dict ): super () . __init__ ( config ) def process_config ( self ): \"\"\" Dummy process_config. \"\"\" logger . debug ( \"process_config not implemented\" ) def set_solver_name ( self ): \"\"\" Dummy set_solver_name. \"\"\" self . solver_name = \"debug\" def execute_sim ( self , candidate : list [ float ], gid : int = 0 , cid : int = 0 ): \"\"\" Dummy execute_sim. \"\"\" logger . debug ( f \"problem dim: { len ( candidate ) } \" ) if gid not in self . df_dict : self . df_dict [ gid ] = {} sim_res = self . compute_sol ( candidate ) self . post_process ( sim_res , gid , cid ) def compute_sol ( self , candidate ) -> float : \"\"\" Dummy compute_sol based on the Ackley function. \"\"\" import math dim = len ( candidate ) return ( - 20 * math . exp ( - 0.2 * math . sqrt ( 1.0 / dim * sum ([ x ** 2 for x in candidate ]))) - math . exp ( 1.0 / dim * sum ([ math . cos ( 2 * math . pi * x ) for x in candidate ])) + 20 + math . e ) def post_process ( self , sim_res : float , gid : int , cid : int ): \"\"\" Dummy post_process. \"\"\" # pd.Series allows columns of different lengths df = pd . DataFrame ({ \"result\" : pd . Series ( sim_res )}) logger . info ( f \"g { gid } , c { cid } converged in { len ( df ) } it.\" ) logger . info ( f \"last values: \\n { df . tail () . to_string ( index = False ) } \" ) self . df_dict [ gid ][ cid ] = df compute_sol ( candidate ) -> float Dummy compute_sol based on the Ackley function. Source code in aero_optim/simulator/simulator.py 337 338 339 340 341 342 343 344 345 346 347 def compute_sol ( self , candidate ) -> float : \"\"\" Dummy compute_sol based on the Ackley function. \"\"\" import math dim = len ( candidate ) return ( - 20 * math . exp ( - 0.2 * math . sqrt ( 1.0 / dim * sum ([ x ** 2 for x in candidate ]))) - math . exp ( 1.0 / dim * sum ([ math . cos ( 2 * math . pi * x ) for x in candidate ])) + 20 + math . e ) execute_sim ( candidate : list [ float ], gid : int = 0 , cid : int = 0 ) Dummy execute_sim. Source code in aero_optim/simulator/simulator.py 327 328 329 330 331 332 333 334 335 def execute_sim ( self , candidate : list [ float ], gid : int = 0 , cid : int = 0 ): \"\"\" Dummy execute_sim. \"\"\" logger . debug ( f \"problem dim: { len ( candidate ) } \" ) if gid not in self . df_dict : self . df_dict [ gid ] = {} sim_res = self . compute_sol ( candidate ) self . post_process ( sim_res , gid , cid ) post_process ( sim_res : float , gid : int , cid : int ) Dummy post_process. Source code in aero_optim/simulator/simulator.py 349 350 351 352 353 354 355 356 357 358 359 def post_process ( self , sim_res : float , gid : int , cid : int ): \"\"\" Dummy post_process. \"\"\" # pd.Series allows columns of different lengths df = pd . DataFrame ({ \"result\" : pd . Series ( sim_res )}) logger . info ( f \"g { gid } , c { cid } converged in { len ( df ) } it.\" ) logger . info ( f \"last values: \\n { df . tail () . to_string ( index = False ) } \" ) self . df_dict [ gid ][ cid ] = df process_config () Dummy process_config. Source code in aero_optim/simulator/simulator.py 315 316 317 318 319 def process_config ( self ): \"\"\" Dummy process_config. \"\"\" logger . debug ( \"process_config not implemented\" ) set_solver_name () Dummy set_solver_name. Source code in aero_optim/simulator/simulator.py 321 322 323 324 325 def set_solver_name ( self ): \"\"\" Dummy set_solver_name. \"\"\" self . solver_name = \"debug\"","title":"Simulator Module"},{"location":"dev_simulator/#simulator-source-code","text":"","title":"Simulator Source Code"},{"location":"dev_simulator/#simulator.simulator.Simulator","text":"Bases: ABC This class implements an abstract simulation class. Source code in aero_optim/simulator/simulator.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 class Simulator ( ABC ): \"\"\" This class implements an abstract simulation class. \"\"\" def __init__ ( self , config : dict ): \"\"\" Instantiates the Simulator object. **Input** - config (dict): the config file dictionary. **Inner** - cwd (str): the working directory. - solver_name (str): the solver name. - outdir (str): the output directory where the simulation results folder will be stored. - exec_cmd (list[str]): solver execution command. - ref_input (str): a simulation input file template. - sim_args (dict): arguments to modify to customize ref_input. - files_to_cp (list[str]): list of files to be copied to the output directory. - post_process_args (dict): quantities to extract from result files. - df_dict (dict): dictionary of dataframes containing all simulations extracted quantities. \"\"\" self . cwd : str = os . getcwd () self . config = config self . process_config () self . set_solver_name () # study params self . outdir : str = config [ \"study\" ][ \"outdir\" ] # simulator params self . exec_cmd : list [ str ] = config [ \"simulator\" ][ \"exec_cmd\" ] . split ( \" \" ) self . ref_input : str = config [ \"simulator\" ][ \"ref_input\" ] self . sim_args : dict = config [ \"simulator\" ] . get ( \"sim_args\" , {}) self . files_to_cp : list [ str ] = config [ \"simulator\" ] . get ( \"files_to_cp\" , []) self . post_process_args : dict = config [ \"simulator\" ] . get ( \"post_process\" , {}) # simulation results self . df_dict : dict [ int , dict [ int , pd . DataFrame ]] = {} def custom_input ( self , fname : str ): \"\"\" **Writes** a customized input file. \"\"\" ref_output = open ( self . ref_input , \"r\" ) . read () . splitlines () for key , value in self . sim_args . items (): idx = ref_output . index ( key ) # in place substitution # {\"keyword\": {{\"inplace\": true}, {'param': [param]}}} if value [ \"inplace\" ]: logger . info ( f \" { key } : replace { ref_output [ idx ] } by { value [ 'param' ][ 0 ] } \" ) ref_output [ idx ] = value [ 'param' ][ 0 ] # multiline substitution # {\"keyword\": {{\"inplace\": false}, {'param': [param0, param1, param..]}}} else : for ii , param in enumerate ( value [ 'param' ]): logger . info ( f \" { key } : replace { ref_output [ idx + 1 + ii ] } by { param } \" ) ref_output [ idx + 1 + ii ] = param with open ( fname , 'w' ) as ftw : ftw . write ( \" \\n \" . join ( ref_output )) logger . info ( f \"input file saved to { fname } \" ) def get_sim_outdir ( self , gid : int = 0 , cid : int = 0 ) -> str : \"\"\" **Returns** the path to the folder containing the simulation results. \"\"\" return os . path . join ( self . outdir , f \" { self . solver_name . upper () } \" , f \" { self . solver_name } _g { gid } _c { cid } \" ) def kill_all ( self , * args , ** kwargs ): \"\"\" **Kills** all active simulations. \"\"\" logger . debug ( \"kill_all not implemented\" ) @abstractmethod def set_solver_name ( self ): \"\"\" Sets the solver_name attribute. \"\"\" self . solver_name = \"solver\" @abstractmethod def process_config ( self ): \"\"\" Makes sure the config file contains the required information. \"\"\" @abstractmethod def execute_sim ( self , * args , ** kwargs ): \"\"\" Runs a single simulation. \"\"\"","title":"Simulator"},{"location":"dev_simulator/#simulator.simulator.Simulator.__init__","text":"Instantiates the Simulator object. Input config (dict): the config file dictionary. Inner cwd (str): the working directory. solver_name (str): the solver name. outdir (str): the output directory where the simulation results folder will be stored. exec_cmd (list[str]): solver execution command. ref_input (str): a simulation input file template. sim_args (dict): arguments to modify to customize ref_input. files_to_cp (list[str]): list of files to be copied to the output directory. post_process_args (dict): quantities to extract from result files. df_dict (dict): dictionary of dataframes containing all simulations extracted quantities. Source code in aero_optim/simulator/simulator.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def __init__ ( self , config : dict ): \"\"\" Instantiates the Simulator object. **Input** - config (dict): the config file dictionary. **Inner** - cwd (str): the working directory. - solver_name (str): the solver name. - outdir (str): the output directory where the simulation results folder will be stored. - exec_cmd (list[str]): solver execution command. - ref_input (str): a simulation input file template. - sim_args (dict): arguments to modify to customize ref_input. - files_to_cp (list[str]): list of files to be copied to the output directory. - post_process_args (dict): quantities to extract from result files. - df_dict (dict): dictionary of dataframes containing all simulations extracted quantities. \"\"\" self . cwd : str = os . getcwd () self . config = config self . process_config () self . set_solver_name () # study params self . outdir : str = config [ \"study\" ][ \"outdir\" ] # simulator params self . exec_cmd : list [ str ] = config [ \"simulator\" ][ \"exec_cmd\" ] . split ( \" \" ) self . ref_input : str = config [ \"simulator\" ][ \"ref_input\" ] self . sim_args : dict = config [ \"simulator\" ] . get ( \"sim_args\" , {}) self . files_to_cp : list [ str ] = config [ \"simulator\" ] . get ( \"files_to_cp\" , []) self . post_process_args : dict = config [ \"simulator\" ] . get ( \"post_process\" , {}) # simulation results self . df_dict : dict [ int , dict [ int , pd . DataFrame ]] = {}","title":"__init__"},{"location":"dev_simulator/#simulator.simulator.Simulator.custom_input","text":"Writes a customized input file. Source code in aero_optim/simulator/simulator.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def custom_input ( self , fname : str ): \"\"\" **Writes** a customized input file. \"\"\" ref_output = open ( self . ref_input , \"r\" ) . read () . splitlines () for key , value in self . sim_args . items (): idx = ref_output . index ( key ) # in place substitution # {\"keyword\": {{\"inplace\": true}, {'param': [param]}}} if value [ \"inplace\" ]: logger . info ( f \" { key } : replace { ref_output [ idx ] } by { value [ 'param' ][ 0 ] } \" ) ref_output [ idx ] = value [ 'param' ][ 0 ] # multiline substitution # {\"keyword\": {{\"inplace\": false}, {'param': [param0, param1, param..]}}} else : for ii , param in enumerate ( value [ 'param' ]): logger . info ( f \" { key } : replace { ref_output [ idx + 1 + ii ] } by { param } \" ) ref_output [ idx + 1 + ii ] = param with open ( fname , 'w' ) as ftw : ftw . write ( \" \\n \" . join ( ref_output )) logger . info ( f \"input file saved to { fname } \" )","title":"custom_input"},{"location":"dev_simulator/#simulator.simulator.Simulator.execute_sim","text":"Runs a single simulation. Source code in aero_optim/simulator/simulator.py 103 104 105 106 107 @abstractmethod def execute_sim ( self , * args , ** kwargs ): \"\"\" Runs a single simulation. \"\"\"","title":"execute_sim"},{"location":"dev_simulator/#simulator.simulator.Simulator.get_sim_outdir","text":"Returns the path to the folder containing the simulation results. Source code in aero_optim/simulator/simulator.py 75 76 77 78 79 80 81 82 def get_sim_outdir ( self , gid : int = 0 , cid : int = 0 ) -> str : \"\"\" **Returns** the path to the folder containing the simulation results. \"\"\" return os . path . join ( self . outdir , f \" { self . solver_name . upper () } \" , f \" { self . solver_name } _g { gid } _c { cid } \" )","title":"get_sim_outdir"},{"location":"dev_simulator/#simulator.simulator.Simulator.kill_all","text":"Kills all active simulations. Source code in aero_optim/simulator/simulator.py 84 85 86 87 88 def kill_all ( self , * args , ** kwargs ): \"\"\" **Kills** all active simulations. \"\"\" logger . debug ( \"kill_all not implemented\" )","title":"kill_all"},{"location":"dev_simulator/#simulator.simulator.Simulator.process_config","text":"Makes sure the config file contains the required information. Source code in aero_optim/simulator/simulator.py 97 98 99 100 101 @abstractmethod def process_config ( self ): \"\"\" Makes sure the config file contains the required information. \"\"\"","title":"process_config"},{"location":"dev_simulator/#simulator.simulator.Simulator.set_solver_name","text":"Sets the solver_name attribute. Source code in aero_optim/simulator/simulator.py 90 91 92 93 94 95 @abstractmethod def set_solver_name ( self ): \"\"\" Sets the solver_name attribute. \"\"\" self . solver_name = \"solver\"","title":"set_solver_name"},{"location":"dev_simulator/#simulator.simulator.WolfSimulator","text":"Bases: Simulator This class implements a simulator for the CFD code WOLF. Source code in aero_optim/simulator/simulator.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 class WolfSimulator ( Simulator ): \"\"\" This class implements a simulator for the CFD code WOLF. \"\"\" def __init__ ( self , config : dict ): \"\"\" Instantiates the WolfSimulator object. **Input** - config (dict): the config file dictionary. **Inner** - exec_cmd (list[str]): solver execution command. Note: with wolf, the exec_cmd is expected to contain a @.mesh argument that is automatically replaced with the simulation input mesh file name. - sim_pro (list[tuple[dict, subprocess.Popen[str]]]): list to track simulations and their associated subprocess. It has the following form: ({'gid': gid, 'cid': cid, 'meshfile': meshfile, 'restart': restart}, subprocess). - restart (int): how many times a simulation is allowed to be restarted in case of failure. \"\"\" super () . __init__ ( config ) self . sim_pro : list [ tuple [ dict , subprocess . Popen [ str ]]] = [] self . restart : int = config [ \"simulator\" ] . get ( \"restart\" , 0 ) def process_config ( self ): \"\"\" **Makes sure** the config file contains the required information and extracts it. \"\"\" logger . debug ( \"processing config..\" ) if \"exec_cmd\" not in self . config [ \"simulator\" ]: raise Exception ( f \"ERROR -- no <exec_cmd> entry in { self . config [ 'simulator' ] } \" ) if \"ref_input\" not in self . config [ \"simulator\" ]: raise Exception ( f \"ERROR -- no <ref_input> entry in { self . config [ 'simulator' ] } \" ) if \"sim_args\" not in self . config [ \"simulator\" ]: logger . debug ( f \"no <sim_args> entry in { self . config [ 'simulator' ] } \" ) if \"post_process\" not in self . config [ \"simulator\" ]: logger . debug ( f \"no <post_process> entry in { self . config [ 'simulator' ] } \" ) def set_solver_name ( self ): \"\"\" **Sets** the solver name to wolf. \"\"\" self . solver_name = \"wolf\" def execute_sim ( self , meshfile : str = \"\" , gid : int = 0 , cid : int = 0 , restart : int = 0 ): \"\"\" **Pre-processes** and **executes** a Wolf simulation. \"\"\" # add gid entry to the results dictionary if gid not in self . df_dict : self . df_dict [ gid ] = {} try : sim_outdir = self . get_sim_outdir ( gid , cid ) dict_id : dict = { \"gid\" : gid , \"cid\" : cid , \"meshfile\" : meshfile } self . df_dict [ dict_id [ \"gid\" ]][ dict_id [ \"cid\" ]] = self . post_process ( dict_id , sim_outdir ) logger . info ( f \"g { gid } , c { cid } : loaded pre-existing results from files\" ) except FileNotFoundError : # Pre-process sim_outdir , exec_cmd = self . pre_process ( meshfile , gid , cid ) # Execution self . execute ( sim_outdir , exec_cmd , gid , cid , meshfile , restart ) def pre_process ( self , meshfile : str , gid : int , cid : int ) -> tuple [ str , list [ str ]]: \"\"\" **Pre-processes** the simulation execution and **returns** the execution command and directory. \"\"\" # get the simulation meshfile full_meshfile = meshfile if meshfile else self . config [ \"simulator\" ][ \"file\" ] path_to_meshfile : str = \"/\" . join ( full_meshfile . split ( \"/\" )[: - 1 ]) meshfile = full_meshfile . split ( \"/\" )[ - 1 ] # generate custom input by altering the wolf template sim_outdir = self . get_sim_outdir ( gid = gid , cid = cid ) check_dir ( sim_outdir ) self . custom_input ( os . path . join ( sim_outdir , f \" { meshfile . split ( '.' )[ 0 ] } .wolf\" )) # copy meshfile to the output directory shutil . copy ( os . path . join ( path_to_meshfile , meshfile ), sim_outdir ) logger . info ( f \" { os . path . join ( path_to_meshfile , meshfile ) } copied to { sim_outdir } \" ) # copy any other solver expected files suffix_list = [ file . split ( \".\" )[ - 1 ] for file in self . files_to_cp ] [ shutil . copy ( file , os . path . join ( sim_outdir , f \" { meshfile . split ( '.' )[ 0 ] } . { suffix } \" )) for file , suffix in zip ( self . files_to_cp , suffix_list )] logger . info ( f \" { self . files_to_cp } copied to { sim_outdir } \" ) # update the execution command with the right mesh file exec_cmd = self . exec_cmd . copy () idx = self . exec_cmd . index ( \"@.mesh\" ) exec_cmd [ idx ] = os . path . join ( meshfile ) return sim_outdir , exec_cmd def execute ( self , sim_outdir : str , exec_cmd : list [ str ], gid : int , cid : int , meshfile : str , restart : int ): \"\"\" **Submits** the simulation subprocess and **updates** sim_pro. \"\"\" # move to the output directory, execute wolf and move back to the main directory os . chdir ( sim_outdir ) with open ( f \" { self . solver_name } _g { gid } _c { cid } .out\" , \"wb\" ) as out : with open ( f \" { self . solver_name } _g { gid } _c { cid } .err\" , \"wb\" ) as err : logger . info ( f \"execute simulation g { gid } , c { cid } with { self . solver_name } \" ) proc = subprocess . Popen ( exec_cmd , env = os . environ , stdin = subprocess . DEVNULL , stdout = out , stderr = err , universal_newlines = True ) os . chdir ( self . cwd ) # append simulation to the list of active processes self . sim_pro . append ( ({ \"gid\" : gid , \"cid\" : cid , \"meshfile\" : meshfile , \"restart\" : restart }, proc ) ) def monitor_sim_progress ( self ) -> int : \"\"\" **Updates** the list of simulations under execution and **returns** its length. \"\"\" finished_sim = [] # loop over the list of simulation processes for id , ( dict_id , p_id ) in enumerate ( self . sim_pro ): returncode = p_id . poll () if returncode is None : pass # simulation still running elif returncode == 0 : logger . info ( f \"simulation { dict_id } finished\" ) finished_sim . append ( id ) sim_outdir = self . get_sim_outdir ( dict_id [ \"gid\" ], dict_id [ \"cid\" ]) self . df_dict [ dict_id [ \"gid\" ]][ dict_id [ \"cid\" ]] = self . post_process ( dict_id , sim_outdir ) break else : if dict_id [ \"restart\" ] < self . restart : logger . error ( f \"ERROR -- simulation { dict_id } crashed and will be restarted\" ) finished_sim . append ( id ) sim_out_dir = self . get_sim_outdir ( dict_id [ \"gid\" ], dict_id [ \"cid\" ]) shutil . rmtree ( sim_out_dir , ignore_errors = True ) self . execute_sim ( dict_id [ \"meshfile\" ], dict_id [ \"gid\" ], dict_id [ \"cid\" ], dict_id [ \"restart\" ] + 1 ) else : raise Exception ( f \"ERROR -- simulation { dict_id } crashed\" ) # update the list of active processes self . sim_pro = [ tup for id , tup in enumerate ( self . sim_pro ) if id not in finished_sim ] return len ( self . sim_pro ) def post_process ( self , dict_id : dict , sim_out_dir : str ) -> pd . DataFrame : \"\"\" **Post-processes** the results of a terminated simulation.</br> **Returns** the extracted results in a DataFrame. \"\"\" qty_list : list [ list [ float ]] = [] head_list : list [ str ] = [] # loop over the post-processing arguments to extract from the results for key , value in self . post_process_args . items (): # filter removes possible blank lines avoiding index out of range errors file = list ( filter ( None , open ( os . path . join ( sim_out_dir , key ), \"r\" ) . read () . splitlines ())) headers = file [ 0 ][ 2 :] . split () # ignore \"# \" before first item in headers for qty in value : try : idx = headers . index ( qty ) qty_list . append ([ float ( line . split ()[ idx ]) for line in file [ 1 :]]) head_list . append ( qty ) except Exception as e : logger . warning ( f \"could not read { qty } in { headers } \" ) logger . warning ( f \"exception { e } was raised\" ) # pd.Series allows columns of different lengths df = pd . DataFrame ({ head_list [ i ]: pd . Series ( qty_list [ i ]) for i in range ( len ( qty_list ))}) logger . info ( f \"g { dict_id [ 'gid' ] } , c { dict_id [ 'cid' ] } converged in { len ( df ) } it.\" ) logger . info ( f \"last values: \\n { df . tail ( n = 1 ) . to_string ( index = False ) } \" ) return df def kill_all ( self ): \"\"\" **Kills** all active processes. \"\"\" logger . info ( f \" { len ( self . sim_pro ) } remaining simulation(s) will be killed\" ) _ = [ subpro . terminate () for _ , subpro in self . sim_pro ]","title":"WolfSimulator"},{"location":"dev_simulator/#simulator.simulator.WolfSimulator.__init__","text":"Instantiates the WolfSimulator object. Input config (dict): the config file dictionary. Inner exec_cmd (list[str]): solver execution command. Note with wolf, the exec_cmd is expected to contain a @.mesh argument that is automatically replaced with the simulation input mesh file name. sim_pro (list[tuple[dict, subprocess.Popen[str]]]): list to track simulations and their associated subprocess. It has the following form: ({'gid': gid, 'cid': cid, 'meshfile': meshfile, 'restart': restart}, subprocess). restart (int): how many times a simulation is allowed to be restarted in case of failure. Source code in aero_optim/simulator/simulator.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 def __init__ ( self , config : dict ): \"\"\" Instantiates the WolfSimulator object. **Input** - config (dict): the config file dictionary. **Inner** - exec_cmd (list[str]): solver execution command. Note: with wolf, the exec_cmd is expected to contain a @.mesh argument that is automatically replaced with the simulation input mesh file name. - sim_pro (list[tuple[dict, subprocess.Popen[str]]]): list to track simulations and their associated subprocess. It has the following form: ({'gid': gid, 'cid': cid, 'meshfile': meshfile, 'restart': restart}, subprocess). - restart (int): how many times a simulation is allowed to be restarted in case of failure. \"\"\" super () . __init__ ( config ) self . sim_pro : list [ tuple [ dict , subprocess . Popen [ str ]]] = [] self . restart : int = config [ \"simulator\" ] . get ( \"restart\" , 0 )","title":"__init__"},{"location":"dev_simulator/#simulator.simulator.WolfSimulator.execute","text":"Submits the simulation subprocess and updates sim_pro. Source code in aero_optim/simulator/simulator.py 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 def execute ( self , sim_outdir : str , exec_cmd : list [ str ], gid : int , cid : int , meshfile : str , restart : int ): \"\"\" **Submits** the simulation subprocess and **updates** sim_pro. \"\"\" # move to the output directory, execute wolf and move back to the main directory os . chdir ( sim_outdir ) with open ( f \" { self . solver_name } _g { gid } _c { cid } .out\" , \"wb\" ) as out : with open ( f \" { self . solver_name } _g { gid } _c { cid } .err\" , \"wb\" ) as err : logger . info ( f \"execute simulation g { gid } , c { cid } with { self . solver_name } \" ) proc = subprocess . Popen ( exec_cmd , env = os . environ , stdin = subprocess . DEVNULL , stdout = out , stderr = err , universal_newlines = True ) os . chdir ( self . cwd ) # append simulation to the list of active processes self . sim_pro . append ( ({ \"gid\" : gid , \"cid\" : cid , \"meshfile\" : meshfile , \"restart\" : restart }, proc ) )","title":"execute"},{"location":"dev_simulator/#simulator.simulator.WolfSimulator.execute_sim","text":"Pre-processes and executes a Wolf simulation. Source code in aero_optim/simulator/simulator.py 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 def execute_sim ( self , meshfile : str = \"\" , gid : int = 0 , cid : int = 0 , restart : int = 0 ): \"\"\" **Pre-processes** and **executes** a Wolf simulation. \"\"\" # add gid entry to the results dictionary if gid not in self . df_dict : self . df_dict [ gid ] = {} try : sim_outdir = self . get_sim_outdir ( gid , cid ) dict_id : dict = { \"gid\" : gid , \"cid\" : cid , \"meshfile\" : meshfile } self . df_dict [ dict_id [ \"gid\" ]][ dict_id [ \"cid\" ]] = self . post_process ( dict_id , sim_outdir ) logger . info ( f \"g { gid } , c { cid } : loaded pre-existing results from files\" ) except FileNotFoundError : # Pre-process sim_outdir , exec_cmd = self . pre_process ( meshfile , gid , cid ) # Execution self . execute ( sim_outdir , exec_cmd , gid , cid , meshfile , restart )","title":"execute_sim"},{"location":"dev_simulator/#simulator.simulator.WolfSimulator.kill_all","text":"Kills all active processes. Source code in aero_optim/simulator/simulator.py 300 301 302 303 304 305 def kill_all ( self ): \"\"\" **Kills** all active processes. \"\"\" logger . info ( f \" { len ( self . sim_pro ) } remaining simulation(s) will be killed\" ) _ = [ subpro . terminate () for _ , subpro in self . sim_pro ]","title":"kill_all"},{"location":"dev_simulator/#simulator.simulator.WolfSimulator.monitor_sim_progress","text":"Updates the list of simulations under execution and returns its length. Source code in aero_optim/simulator/simulator.py 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 def monitor_sim_progress ( self ) -> int : \"\"\" **Updates** the list of simulations under execution and **returns** its length. \"\"\" finished_sim = [] # loop over the list of simulation processes for id , ( dict_id , p_id ) in enumerate ( self . sim_pro ): returncode = p_id . poll () if returncode is None : pass # simulation still running elif returncode == 0 : logger . info ( f \"simulation { dict_id } finished\" ) finished_sim . append ( id ) sim_outdir = self . get_sim_outdir ( dict_id [ \"gid\" ], dict_id [ \"cid\" ]) self . df_dict [ dict_id [ \"gid\" ]][ dict_id [ \"cid\" ]] = self . post_process ( dict_id , sim_outdir ) break else : if dict_id [ \"restart\" ] < self . restart : logger . error ( f \"ERROR -- simulation { dict_id } crashed and will be restarted\" ) finished_sim . append ( id ) sim_out_dir = self . get_sim_outdir ( dict_id [ \"gid\" ], dict_id [ \"cid\" ]) shutil . rmtree ( sim_out_dir , ignore_errors = True ) self . execute_sim ( dict_id [ \"meshfile\" ], dict_id [ \"gid\" ], dict_id [ \"cid\" ], dict_id [ \"restart\" ] + 1 ) else : raise Exception ( f \"ERROR -- simulation { dict_id } crashed\" ) # update the list of active processes self . sim_pro = [ tup for id , tup in enumerate ( self . sim_pro ) if id not in finished_sim ] return len ( self . sim_pro )","title":"monitor_sim_progress"},{"location":"dev_simulator/#simulator.simulator.WolfSimulator.post_process","text":"Post-processes the results of a terminated simulation. Returns the extracted results in a DataFrame. Source code in aero_optim/simulator/simulator.py 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 def post_process ( self , dict_id : dict , sim_out_dir : str ) -> pd . DataFrame : \"\"\" **Post-processes** the results of a terminated simulation.</br> **Returns** the extracted results in a DataFrame. \"\"\" qty_list : list [ list [ float ]] = [] head_list : list [ str ] = [] # loop over the post-processing arguments to extract from the results for key , value in self . post_process_args . items (): # filter removes possible blank lines avoiding index out of range errors file = list ( filter ( None , open ( os . path . join ( sim_out_dir , key ), \"r\" ) . read () . splitlines ())) headers = file [ 0 ][ 2 :] . split () # ignore \"# \" before first item in headers for qty in value : try : idx = headers . index ( qty ) qty_list . append ([ float ( line . split ()[ idx ]) for line in file [ 1 :]]) head_list . append ( qty ) except Exception as e : logger . warning ( f \"could not read { qty } in { headers } \" ) logger . warning ( f \"exception { e } was raised\" ) # pd.Series allows columns of different lengths df = pd . DataFrame ({ head_list [ i ]: pd . Series ( qty_list [ i ]) for i in range ( len ( qty_list ))}) logger . info ( f \"g { dict_id [ 'gid' ] } , c { dict_id [ 'cid' ] } converged in { len ( df ) } it.\" ) logger . info ( f \"last values: \\n { df . tail ( n = 1 ) . to_string ( index = False ) } \" ) return df","title":"post_process"},{"location":"dev_simulator/#simulator.simulator.WolfSimulator.pre_process","text":"Pre-processes the simulation execution and returns the execution command and directory. Source code in aero_optim/simulator/simulator.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 def pre_process ( self , meshfile : str , gid : int , cid : int ) -> tuple [ str , list [ str ]]: \"\"\" **Pre-processes** the simulation execution and **returns** the execution command and directory. \"\"\" # get the simulation meshfile full_meshfile = meshfile if meshfile else self . config [ \"simulator\" ][ \"file\" ] path_to_meshfile : str = \"/\" . join ( full_meshfile . split ( \"/\" )[: - 1 ]) meshfile = full_meshfile . split ( \"/\" )[ - 1 ] # generate custom input by altering the wolf template sim_outdir = self . get_sim_outdir ( gid = gid , cid = cid ) check_dir ( sim_outdir ) self . custom_input ( os . path . join ( sim_outdir , f \" { meshfile . split ( '.' )[ 0 ] } .wolf\" )) # copy meshfile to the output directory shutil . copy ( os . path . join ( path_to_meshfile , meshfile ), sim_outdir ) logger . info ( f \" { os . path . join ( path_to_meshfile , meshfile ) } copied to { sim_outdir } \" ) # copy any other solver expected files suffix_list = [ file . split ( \".\" )[ - 1 ] for file in self . files_to_cp ] [ shutil . copy ( file , os . path . join ( sim_outdir , f \" { meshfile . split ( '.' )[ 0 ] } . { suffix } \" )) for file , suffix in zip ( self . files_to_cp , suffix_list )] logger . info ( f \" { self . files_to_cp } copied to { sim_outdir } \" ) # update the execution command with the right mesh file exec_cmd = self . exec_cmd . copy () idx = self . exec_cmd . index ( \"@.mesh\" ) exec_cmd [ idx ] = os . path . join ( meshfile ) return sim_outdir , exec_cmd","title":"pre_process"},{"location":"dev_simulator/#simulator.simulator.WolfSimulator.process_config","text":"Makes sure the config file contains the required information and extracts it. Source code in aero_optim/simulator/simulator.py 142 143 144 145 146 147 148 149 150 151 152 153 154 def process_config ( self ): \"\"\" **Makes sure** the config file contains the required information and extracts it. \"\"\" logger . debug ( \"processing config..\" ) if \"exec_cmd\" not in self . config [ \"simulator\" ]: raise Exception ( f \"ERROR -- no <exec_cmd> entry in { self . config [ 'simulator' ] } \" ) if \"ref_input\" not in self . config [ \"simulator\" ]: raise Exception ( f \"ERROR -- no <ref_input> entry in { self . config [ 'simulator' ] } \" ) if \"sim_args\" not in self . config [ \"simulator\" ]: logger . debug ( f \"no <sim_args> entry in { self . config [ 'simulator' ] } \" ) if \"post_process\" not in self . config [ \"simulator\" ]: logger . debug ( f \"no <post_process> entry in { self . config [ 'simulator' ] } \" )","title":"process_config"},{"location":"dev_simulator/#simulator.simulator.WolfSimulator.set_solver_name","text":"Sets the solver name to wolf. Source code in aero_optim/simulator/simulator.py 156 157 158 159 160 def set_solver_name ( self ): \"\"\" **Sets** the solver name to wolf. \"\"\" self . solver_name = \"wolf\"","title":"set_solver_name"},{"location":"dev_simulator/#simulator.simulator.DebugSimulator","text":"Bases: Simulator This class implements a basic simulator for debugging purposes. Source code in aero_optim/simulator/simulator.py 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 class DebugSimulator ( Simulator ): \"\"\" This class implements a basic simulator for debugging purposes. \"\"\" def __init__ ( self , config : dict ): super () . __init__ ( config ) def process_config ( self ): \"\"\" Dummy process_config. \"\"\" logger . debug ( \"process_config not implemented\" ) def set_solver_name ( self ): \"\"\" Dummy set_solver_name. \"\"\" self . solver_name = \"debug\" def execute_sim ( self , candidate : list [ float ], gid : int = 0 , cid : int = 0 ): \"\"\" Dummy execute_sim. \"\"\" logger . debug ( f \"problem dim: { len ( candidate ) } \" ) if gid not in self . df_dict : self . df_dict [ gid ] = {} sim_res = self . compute_sol ( candidate ) self . post_process ( sim_res , gid , cid ) def compute_sol ( self , candidate ) -> float : \"\"\" Dummy compute_sol based on the Ackley function. \"\"\" import math dim = len ( candidate ) return ( - 20 * math . exp ( - 0.2 * math . sqrt ( 1.0 / dim * sum ([ x ** 2 for x in candidate ]))) - math . exp ( 1.0 / dim * sum ([ math . cos ( 2 * math . pi * x ) for x in candidate ])) + 20 + math . e ) def post_process ( self , sim_res : float , gid : int , cid : int ): \"\"\" Dummy post_process. \"\"\" # pd.Series allows columns of different lengths df = pd . DataFrame ({ \"result\" : pd . Series ( sim_res )}) logger . info ( f \"g { gid } , c { cid } converged in { len ( df ) } it.\" ) logger . info ( f \"last values: \\n { df . tail () . to_string ( index = False ) } \" ) self . df_dict [ gid ][ cid ] = df","title":"DebugSimulator"},{"location":"dev_simulator/#simulator.simulator.DebugSimulator.compute_sol","text":"Dummy compute_sol based on the Ackley function. Source code in aero_optim/simulator/simulator.py 337 338 339 340 341 342 343 344 345 346 347 def compute_sol ( self , candidate ) -> float : \"\"\" Dummy compute_sol based on the Ackley function. \"\"\" import math dim = len ( candidate ) return ( - 20 * math . exp ( - 0.2 * math . sqrt ( 1.0 / dim * sum ([ x ** 2 for x in candidate ]))) - math . exp ( 1.0 / dim * sum ([ math . cos ( 2 * math . pi * x ) for x in candidate ])) + 20 + math . e )","title":"compute_sol"},{"location":"dev_simulator/#simulator.simulator.DebugSimulator.execute_sim","text":"Dummy execute_sim. Source code in aero_optim/simulator/simulator.py 327 328 329 330 331 332 333 334 335 def execute_sim ( self , candidate : list [ float ], gid : int = 0 , cid : int = 0 ): \"\"\" Dummy execute_sim. \"\"\" logger . debug ( f \"problem dim: { len ( candidate ) } \" ) if gid not in self . df_dict : self . df_dict [ gid ] = {} sim_res = self . compute_sol ( candidate ) self . post_process ( sim_res , gid , cid )","title":"execute_sim"},{"location":"dev_simulator/#simulator.simulator.DebugSimulator.post_process","text":"Dummy post_process. Source code in aero_optim/simulator/simulator.py 349 350 351 352 353 354 355 356 357 358 359 def post_process ( self , sim_res : float , gid : int , cid : int ): \"\"\" Dummy post_process. \"\"\" # pd.Series allows columns of different lengths df = pd . DataFrame ({ \"result\" : pd . Series ( sim_res )}) logger . info ( f \"g { gid } , c { cid } converged in { len ( df ) } it.\" ) logger . info ( f \"last values: \\n { df . tail () . to_string ( index = False ) } \" ) self . df_dict [ gid ][ cid ] = df","title":"post_process"},{"location":"dev_simulator/#simulator.simulator.DebugSimulator.process_config","text":"Dummy process_config. Source code in aero_optim/simulator/simulator.py 315 316 317 318 319 def process_config ( self ): \"\"\" Dummy process_config. \"\"\" logger . debug ( \"process_config not implemented\" )","title":"process_config"},{"location":"dev_simulator/#simulator.simulator.DebugSimulator.set_solver_name","text":"Dummy set_solver_name. Source code in aero_optim/simulator/simulator.py 321 322 323 324 325 def set_solver_name ( self ): \"\"\" Dummy set_solver_name. \"\"\" self . solver_name = \"debug\"","title":"set_solver_name"},{"location":"example_custom/","text":"Customized Optimization Although this framework was designed to perform simple forms of aerodynamic optimization, it still covers a broad range of applications and use-cases. It seems therefore unrealistic to see this framework as a universal tool. Yet, a specific care was taken when designing and assembling the building parts of it in order to make it as customizable as possible. Hence any optimization part of the framework can be customized with the following steps: 1) create a <custom-script>.py file in the working directory (e.g. inspyred_debug.py or pymoo_debug.py ), 2) inherit all classes to be customized respecting the class naming format i.e respectively CustomMesh , CustomSimulator , CustomOptimizer and CustomEvolution if overriding a Mesh , Simulator , Optimizer or Evolution based class, 3) add a custom_file entry specifying the path to the custom script in the \"study\" sub-dictionary of the configuration file. Note As of now, the FFD_2D class is the only static element of the framework. However, extending Optimizer to enable its customization would be pretty straightforward. Illustration The scripts in the debug example illustrate how to customize the Simulator , Optimizer and Evolution classes both with pymoo (or inspyred ). First, the Simulator class is customized: class CustomSimulator ( DebugSimulator ): def __init__ ( self , config : dict ): super () . __init__ ( config ) logger . info ( \"INIT CUSTOM SIMULATOR\" ) Then, the Optimizer class is customized: class CustomOptimizer ( PymooDebugOptimizer ): def __init__ ( self , config : dict ): super () . __init__ ( config ) logger . info ( \"INIT CUSTOM OPTIMIZER\" ) Finally, the Evolution class is customized: class CustomEvolution ( PymooEvolution ): def set_ea ( self ): logger . info ( \"SET CUSTOM EA\" ) self . ea = PSO ( pop_size = self . optimizer . doe_size , sampling = self . optimizer . generator . _pymoo_generator (), ** self . optimizer . ea_kwargs ) def evolve ( self ): logger . info ( \"EXECUTE CUSTOM EVOLVE\" ) res = minimize ( problem = self . optimizer , algorithm = self . ea , termination = get_termination ( \"n_gen\" , self . optimizer . max_generations ), seed = self . optimizer . seed , verbose = True ) self . optimizer . final_observe () # output results best = res . F index , opt_J = min ( enumerate ( self . optimizer . J ), key = lambda x : abs ( best - x [ 1 ])) gid , cid = ( index // self . optimizer . doe_size , index % self . optimizer . doe_size ) logger . info ( f \"optimal J: { opt_J } (J_pymoo: { best } ), \\n \" f \"D: { ' ' . join ([ str ( d ) for d in self . optimizer . inputs [ gid ][ cid ]]) } \\n \" f \"D_pymoo: { ' ' . join ([ str ( d ) for d in res . X ]) } \\n \" f \"[g { gid } , c { cid } ]\" ) Of course, this is a purely illustrative example and the customization simply consists in overriding these upper level classes with already existing ones. It is still representative of how it can be done. Quick Experiments Running the following commands will execute a simple optimization with pymoo : # from aero-optim to debug cd examples/debug optim -c debug.json Since the pymoo_debug.py script is given in debug.json and CustomEvolution inherits from PymooEvolution , in this case, there is no need to specify the optimization library which is automatically selected. The custom script can also be superseded by passing it to optim with the --file option. Hence, simply running the command below will execute an optimization with inspyred : # from aero-optim to debug cd examples/debug optim -c debug.json -f inspyred_debug.py","title":"Customized Optimization"},{"location":"example_custom/#customized-optimization","text":"Although this framework was designed to perform simple forms of aerodynamic optimization, it still covers a broad range of applications and use-cases. It seems therefore unrealistic to see this framework as a universal tool. Yet, a specific care was taken when designing and assembling the building parts of it in order to make it as customizable as possible. Hence any optimization part of the framework can be customized with the following steps: 1) create a <custom-script>.py file in the working directory (e.g. inspyred_debug.py or pymoo_debug.py ), 2) inherit all classes to be customized respecting the class naming format i.e respectively CustomMesh , CustomSimulator , CustomOptimizer and CustomEvolution if overriding a Mesh , Simulator , Optimizer or Evolution based class, 3) add a custom_file entry specifying the path to the custom script in the \"study\" sub-dictionary of the configuration file. Note As of now, the FFD_2D class is the only static element of the framework. However, extending Optimizer to enable its customization would be pretty straightforward.","title":"Customized Optimization"},{"location":"example_custom/#illustration","text":"The scripts in the debug example illustrate how to customize the Simulator , Optimizer and Evolution classes both with pymoo (or inspyred ). First, the Simulator class is customized: class CustomSimulator ( DebugSimulator ): def __init__ ( self , config : dict ): super () . __init__ ( config ) logger . info ( \"INIT CUSTOM SIMULATOR\" ) Then, the Optimizer class is customized: class CustomOptimizer ( PymooDebugOptimizer ): def __init__ ( self , config : dict ): super () . __init__ ( config ) logger . info ( \"INIT CUSTOM OPTIMIZER\" ) Finally, the Evolution class is customized: class CustomEvolution ( PymooEvolution ): def set_ea ( self ): logger . info ( \"SET CUSTOM EA\" ) self . ea = PSO ( pop_size = self . optimizer . doe_size , sampling = self . optimizer . generator . _pymoo_generator (), ** self . optimizer . ea_kwargs ) def evolve ( self ): logger . info ( \"EXECUTE CUSTOM EVOLVE\" ) res = minimize ( problem = self . optimizer , algorithm = self . ea , termination = get_termination ( \"n_gen\" , self . optimizer . max_generations ), seed = self . optimizer . seed , verbose = True ) self . optimizer . final_observe () # output results best = res . F index , opt_J = min ( enumerate ( self . optimizer . J ), key = lambda x : abs ( best - x [ 1 ])) gid , cid = ( index // self . optimizer . doe_size , index % self . optimizer . doe_size ) logger . info ( f \"optimal J: { opt_J } (J_pymoo: { best } ), \\n \" f \"D: { ' ' . join ([ str ( d ) for d in self . optimizer . inputs [ gid ][ cid ]]) } \\n \" f \"D_pymoo: { ' ' . join ([ str ( d ) for d in res . X ]) } \\n \" f \"[g { gid } , c { cid } ]\" ) Of course, this is a purely illustrative example and the customization simply consists in overriding these upper level classes with already existing ones. It is still representative of how it can be done.","title":"Illustration"},{"location":"example_custom/#quick-experiments","text":"Running the following commands will execute a simple optimization with pymoo : # from aero-optim to debug cd examples/debug optim -c debug.json Since the pymoo_debug.py script is given in debug.json and CustomEvolution inherits from PymooEvolution , in this case, there is no need to specify the optimization library which is automatically selected. The custom script can also be superseded by passing it to optim with the --file option. Hence, simply running the command below will execute an optimization with inspyred : # from aero-optim to debug cd examples/debug optim -c debug.json -f inspyred_debug.py","title":"Quick Experiments"},{"location":"example_mf_smo/","text":"Multi-Fidelity Surrogate based Optimization Multi-Fidelity surrogate based optimization (MF-SBO) also is a common practice in aerodynamic shape optimization. In comparison to the standard SBO, the idea in this case is to build multiple initial design of experiments (DOE) with different fidelities (e.g. RANS vs LES, increasing mesh fineness, etc.). Then, these multi-fidelity datasets are used to train a multi-fidelity surrogate model of the problem's quantities of interest (QoIs). In the end, the multi-fidelity surrogate model, which is expected to be more precised than a mono-fidelity model, is used in the optimization loop in place of the CFD solver. This tutorial illustrates the steps to do so with Aero-Optim : 1) a non-penalized low-fidelity DOE is built with a single generation optimization execution, 2) the best candidates amongst low-fidelity ones are used as candidates for the high-fidelity DOE that is then built with a single generation optimization execution, 3) the low-fidelity and high-fidelity results are used to train the multi-fidelity surrogate model of the user's choosing, 4) a full optimization based on a CustomSimulator and a CustomOptimizer is performed by evaluating candidates with the trained multi-fidelity surrogate model. Illustration The NACA12/naca_mf_smt example shows how this can be done with two fidelities: the naca_base use-case with its coarse mesh for the first one, the naca_adap use-case with its adapted mesh for the second fidelity. Once again, the smt toolbox is used to build and train the multi-fidelity surrogates. First, the naca_lf_doe.json configuration file is built with max_generations set to 1 (the DOE is generated with pymoo ): subprocess . run ([ \"optim\" , \"-c\" , \"naca_lf_doe.json\" , \"--pymoo\" ], env = os . environ , stdin = subprocess . DEVNULL , check = True ) Then, the results are loaded and the best candidates are selected to become those of the high-fidelity DOE: # lf data loading X_lf = np . loadtxt ( os . path . join ( lf_outdir , \"candidates.txt\" )) Y_lf = [] with open ( os . path . join ( lf_outdir , \"df_dict.pkl\" ), \"rb\" ) as handle : df_dict = pickle . load ( handle ) for gid in range ( len ( df_dict )): for cid in range ( len ( df_dict [ gid ])): Y_lf . append ([ df_dict [ gid ][ cid ][ \"CD\" ] . iloc [ - 1 ], df_dict [ gid ][ cid ][ \"CL\" ] . iloc [ - 1 ]]) Y_lf = np . array ( Y_lf ) del df_dict # hf candidates selection best_candidates_idx = np . argsort ( Y_lf [:, 0 ]) np . savetxt ( os . path . join ( hf_outdir , \"custom_doe.txt\" ), X_lf [ best_candidates_idx ][: hf_doe_size ] ) # hf data generation subprocess . run ([ \"optim\" , \"-c\" , f \"naca_hf_doe.json\" , \"--pymoo\" ], env = os . environ , stdin = subprocess . DEVNULL , check = True ) Where naca_hf_doe.json is based on the naca_adp.json configuration file with an additional parameter enabling the Generator to fetch the newly selected candidates: - \"custom_doe\": \"output_hf_doe/custom_doe.txt\" in the \"optim\" entry. The high-fidelity results are next loaded and used to train the multi-fidelity surrogate models for both Cd and Cl : X_hf = np . loadtxt ( os . path . join ( hf_outdir , \"candidates.txt\" )) Y_hf = [] with open ( os . path . join ( hf_outdir , \"df_dict.pkl\" ), \"rb\" ) as handle : df_dict = pickle . load ( handle ) for gid in range ( len ( df_dict )): for cid in range ( len ( df_dict [ gid ])): Y_hf . append ([ df_dict [ gid ][ cid ][ \"CD\" ] . iloc [ - 1 ], df_dict [ gid ][ cid ][ \"CL\" ] . iloc [ - 1 ]]) Y_hf = np . array ( Y_hf ) del df_dict # Cd mfsm_cd = MFK ( theta0 = X_lf . shape [ 1 ] * [ 1.0 ]) mfsm_cd . set_training_values ( X_lf , Y_lf [:, 0 ], name = 0 ) mfsm_cd . set_training_values ( X_hf , Y_hf [:, 0 ]) mfsm_cd . train () # Cl mfsm_cl = MFK ( theta0 = X_lf . shape [ 1 ] * [ 1.0 ]) mfsm_cl . set_training_values ( X_lf , Y_lf [:, 1 ], name = 0 ) mfsm_cl . set_training_values ( X_hf , Y_hf [:, 1 ]) mfsm_cl . train () The exact same CustomSM class as the one introduced in the SBO example is used to combine both models and emulate what would have been extracted from a simulation run: custom_mf_sm = CustomSM ([ sm_cd , sm_cl ]) with open ( os . path . join ( outdir , \"model.pkl\" ), \"wb\" ) as handle : pickle . dump ( custom_mf_sm , handle ) Finally, a full optimization using this multi-fidelity surrogate model is performed with the same naca_smt.json configuration file and two additional parameters: \"custom_file\": \"../naca_smt/custom_sm.py\" in the \"study\" entry, \"model_file\": \"output_hf_doe/model.pkl\" in the \"simulator\" entry. subprocess . run ([ \"optim\" , \"-c\" , \"naca_smt.json\" , \"--pymoo\" ], env = os . environ , stdin = subprocess . DEVNULL , check = True ) Quick Experiments In order to run this examples, the smt library must first be added to the virtual environment: pip install smt Then, the main_mf_sm.py script in the NACA12/naca_mf_smt example folder can be used to perform all three steps at once: # from aero-optim to naca_mf_smt cd examples/NACA12/naca_mf_smt python3 main_mf_sm.py -clf naca_lf_doe.json -chf naca_hf_doe.json -cmfsm naca_smt.json It will produce an output_lf_doe folder with the results of the low-fidelity DOE generation, an output_hf_doe folder with the high-fidelity results and output_smt with the results of the multi-fidelity surrogate based optimization. At that point, the optimal profile properties obtained with the surrogate can be compared to its corresponding CFD simulation: # deformed profile generation ffd -f ../data/naca12.dat -nc 4 -d \"<displacement of the optimal profile>\" -o output_optim # deformed profile meshing mesh -c naca_hf_doe.json -f output_optim/naca12_g0_c0.dat -o output_optim # simulation execution simulator -c naca_hf_doe.json -f output_optim/naca_base.mesh -o optim_profile","title":"Multi-Fidelity Surrogate based Optimization"},{"location":"example_mf_smo/#multi-fidelity-surrogate-based-optimization","text":"Multi-Fidelity surrogate based optimization (MF-SBO) also is a common practice in aerodynamic shape optimization. In comparison to the standard SBO, the idea in this case is to build multiple initial design of experiments (DOE) with different fidelities (e.g. RANS vs LES, increasing mesh fineness, etc.). Then, these multi-fidelity datasets are used to train a multi-fidelity surrogate model of the problem's quantities of interest (QoIs). In the end, the multi-fidelity surrogate model, which is expected to be more precised than a mono-fidelity model, is used in the optimization loop in place of the CFD solver. This tutorial illustrates the steps to do so with Aero-Optim : 1) a non-penalized low-fidelity DOE is built with a single generation optimization execution, 2) the best candidates amongst low-fidelity ones are used as candidates for the high-fidelity DOE that is then built with a single generation optimization execution, 3) the low-fidelity and high-fidelity results are used to train the multi-fidelity surrogate model of the user's choosing, 4) a full optimization based on a CustomSimulator and a CustomOptimizer is performed by evaluating candidates with the trained multi-fidelity surrogate model.","title":"Multi-Fidelity Surrogate based Optimization"},{"location":"example_mf_smo/#illustration","text":"The NACA12/naca_mf_smt example shows how this can be done with two fidelities: the naca_base use-case with its coarse mesh for the first one, the naca_adap use-case with its adapted mesh for the second fidelity. Once again, the smt toolbox is used to build and train the multi-fidelity surrogates. First, the naca_lf_doe.json configuration file is built with max_generations set to 1 (the DOE is generated with pymoo ): subprocess . run ([ \"optim\" , \"-c\" , \"naca_lf_doe.json\" , \"--pymoo\" ], env = os . environ , stdin = subprocess . DEVNULL , check = True ) Then, the results are loaded and the best candidates are selected to become those of the high-fidelity DOE: # lf data loading X_lf = np . loadtxt ( os . path . join ( lf_outdir , \"candidates.txt\" )) Y_lf = [] with open ( os . path . join ( lf_outdir , \"df_dict.pkl\" ), \"rb\" ) as handle : df_dict = pickle . load ( handle ) for gid in range ( len ( df_dict )): for cid in range ( len ( df_dict [ gid ])): Y_lf . append ([ df_dict [ gid ][ cid ][ \"CD\" ] . iloc [ - 1 ], df_dict [ gid ][ cid ][ \"CL\" ] . iloc [ - 1 ]]) Y_lf = np . array ( Y_lf ) del df_dict # hf candidates selection best_candidates_idx = np . argsort ( Y_lf [:, 0 ]) np . savetxt ( os . path . join ( hf_outdir , \"custom_doe.txt\" ), X_lf [ best_candidates_idx ][: hf_doe_size ] ) # hf data generation subprocess . run ([ \"optim\" , \"-c\" , f \"naca_hf_doe.json\" , \"--pymoo\" ], env = os . environ , stdin = subprocess . DEVNULL , check = True ) Where naca_hf_doe.json is based on the naca_adp.json configuration file with an additional parameter enabling the Generator to fetch the newly selected candidates: - \"custom_doe\": \"output_hf_doe/custom_doe.txt\" in the \"optim\" entry. The high-fidelity results are next loaded and used to train the multi-fidelity surrogate models for both Cd and Cl : X_hf = np . loadtxt ( os . path . join ( hf_outdir , \"candidates.txt\" )) Y_hf = [] with open ( os . path . join ( hf_outdir , \"df_dict.pkl\" ), \"rb\" ) as handle : df_dict = pickle . load ( handle ) for gid in range ( len ( df_dict )): for cid in range ( len ( df_dict [ gid ])): Y_hf . append ([ df_dict [ gid ][ cid ][ \"CD\" ] . iloc [ - 1 ], df_dict [ gid ][ cid ][ \"CL\" ] . iloc [ - 1 ]]) Y_hf = np . array ( Y_hf ) del df_dict # Cd mfsm_cd = MFK ( theta0 = X_lf . shape [ 1 ] * [ 1.0 ]) mfsm_cd . set_training_values ( X_lf , Y_lf [:, 0 ], name = 0 ) mfsm_cd . set_training_values ( X_hf , Y_hf [:, 0 ]) mfsm_cd . train () # Cl mfsm_cl = MFK ( theta0 = X_lf . shape [ 1 ] * [ 1.0 ]) mfsm_cl . set_training_values ( X_lf , Y_lf [:, 1 ], name = 0 ) mfsm_cl . set_training_values ( X_hf , Y_hf [:, 1 ]) mfsm_cl . train () The exact same CustomSM class as the one introduced in the SBO example is used to combine both models and emulate what would have been extracted from a simulation run: custom_mf_sm = CustomSM ([ sm_cd , sm_cl ]) with open ( os . path . join ( outdir , \"model.pkl\" ), \"wb\" ) as handle : pickle . dump ( custom_mf_sm , handle ) Finally, a full optimization using this multi-fidelity surrogate model is performed with the same naca_smt.json configuration file and two additional parameters: \"custom_file\": \"../naca_smt/custom_sm.py\" in the \"study\" entry, \"model_file\": \"output_hf_doe/model.pkl\" in the \"simulator\" entry. subprocess . run ([ \"optim\" , \"-c\" , \"naca_smt.json\" , \"--pymoo\" ], env = os . environ , stdin = subprocess . DEVNULL , check = True )","title":"Illustration"},{"location":"example_mf_smo/#quick-experiments","text":"In order to run this examples, the smt library must first be added to the virtual environment: pip install smt Then, the main_mf_sm.py script in the NACA12/naca_mf_smt example folder can be used to perform all three steps at once: # from aero-optim to naca_mf_smt cd examples/NACA12/naca_mf_smt python3 main_mf_sm.py -clf naca_lf_doe.json -chf naca_hf_doe.json -cmfsm naca_smt.json It will produce an output_lf_doe folder with the results of the low-fidelity DOE generation, an output_hf_doe folder with the high-fidelity results and output_smt with the results of the multi-fidelity surrogate based optimization. At that point, the optimal profile properties obtained with the surrogate can be compared to its corresponding CFD simulation: # deformed profile generation ffd -f ../data/naca12.dat -nc 4 -d \"<displacement of the optimal profile>\" -o output_optim # deformed profile meshing mesh -c naca_hf_doe.json -f output_optim/naca12_g0_c0.dat -o output_optim # simulation execution simulator -c naca_hf_doe.json -f output_optim/naca_base.mesh -o optim_profile","title":"Quick Experiments"},{"location":"example_smo/","text":"Surrogate based Optimization Surrogate based optimization (SBO) is a common practice in aerodynamic shape optimization. The main idea is to build an initial design of experiments (DOE) that is then used to train a surrogate model of the problem's quantities of interest (QoIs). In the end, the surrogate model is used in the optimization loop in place of the CFD solver. This tutorial illustrates the steps to do so with Aero-Optim : 1) a non-penalized DOE is built with a single generation optimization execution, 2) the results are used to train the surrogate model of the user's choosing, 3) a full optimization based on a CustomSimulator and a CustomOptimizer is performed by evaluating candidates with the trained surrogate model. Illustration The NACA12/naca_smt example shows how this can be done for the naca_base use-case and the smt toolbox . First, the naca_doe.json configuration file is built with max_generations set to 1 (the DOE is generated with pymoo ): subprocess . run ([ \"optim\" , \"-c\" , \"naca_doe.json\" , \"--pymoo\" ], env = os . environ , stdin = subprocess . DEVNULL , check = True ) Then, the results are loaded and used to train surrogate models for both Cd and Cl : X = np . loadtxt ( os . path . join ( outdir , \"candidates.txt\" )) Y = [] with open ( os . path . join ( outdir , \"df_dict.pkl\" ), \"rb\" ) as handle : df_dict = pickle . load ( handle ) for gid in range ( len ( df_dict )): for cid in range ( len ( df_dict [ gid ])): Y . append ([ df_dict [ gid ][ cid ][ \"CD\" ] . iloc [ - 1 ], df_dict [ gid ][ cid ][ \"CL\" ] . iloc [ - 1 ]]) Y = np . array ( Y ) del df_dict # Cd sm_cd = KRG ( theta0 = [ 1e-2 ]) sm_cd . set_training_values ( X , Y [:, 0 ]) sm_cd . train () # Cl sm_cl = KRG ( theta0 = [ 1e-2 ]) sm_cl . set_training_values ( X , Y [:, 1 ]) sm_cl . train () A straightforward CustomSM class is implemented to combine both models and emulate what would have been extracted from a simulation run: class CustomSM : def __init__ ( self , list_of_surrogates : list [ KRG ]): self . los : list [ KRG ] = list_of_surrogates def predict ( self , x : np . ndarray ) -> list [ float ]: return [ sm . predict_values ( x ) for sm in self . los ] # [Cd, Cl] custom_sm = CustomSM ([ sm_cd , sm_cl ]) with open ( os . path . join ( outdir , \"model.pkl\" ), \"wb\" ) as handle : pickle . dump ( custom_sm , handle ) Finally, a full optimization using this surrogate model is performed with the naca_smt.json configuration file and two additional parameters: \"custom_file\": \"custom_sm.py\" in the \"study\" entry, \"model_file\": \"output_doe/model.pkl\" in the \"simulator\" entry. subprocess . run ([ \"optim\" , \"-c\" , \"naca_smt.json\" , \"--pymoo\" ], env = os . environ , stdin = subprocess . DEVNULL , check = True ) For this instruction to work, the custom script custom_sm.py must also be implemented to define CustomSimulator and CustomOptimizer : class CustomSimulator ( Simulator ): def __init__ ( self , config : dict ): super () . __init__ ( config ) self . set_model ( config [ \"simulator\" ][ \"model_file\" ]) def process_config ( self ): logger . info ( \"processing config..\" ) if \"model_file\" not in self . config [ \"simulator\" ]: raise Exception ( f \"ERROR -- no <model_file> entry in { self . config [ 'simulator' ] } \" ) def set_solver_name ( self ): self . solver_name = \"smt_model\" def set_model ( self , model_file : str ): check_file ( model_file ) with open ( model_file , \"rb\" ) as handle : self . model = pickle . load ( handle ) def execute_sim ( self , candidates : list [ float ] | np . ndarray , gid : int = 0 ): logger . info ( f \"execute simulations g { gid } with { self . solver_name } \" ) cd , cl = self . model . predict ( np . array ( candidates )) self . df_dict [ gid ] = { cid : pd . DataFrame ({ \"ResTot\" : 1. , \"CD\" : cd [ cid ], \"CL\" : cl [ cid ]}) for cid in range ( len ( candidates )) } class CustomOptimizer ( PymooWolfOptimizer ): def set_gmsh_mesh_class ( self ): self . MeshClass = None def execute_candidates ( self , candidates , gid ): logger . info ( f \"evaluating candidates of generation { self . gen_ctr } ..\" ) self . ffd_profiles . append ([]) self . inputs . append ([]) for cid , cand in enumerate ( candidates ): self . inputs [ gid ] . append ( np . array ( cand )) _ , ffd_profile = self . deform ( cand , gid , cid ) self . ffd_profiles [ gid ] . append ( ffd_profile ) self . simulator . execute_sim ( candidates , gid ) Tip Most surrogate models offer vectorized evaluation. It is therefore good practice to implement CustomSimulator in such a way that this aspect is leveraged. Warning Because the standard pickle library is not capable of unpickling an object whose class definition is unaccessible, dill is used instead. Quick Experiments In order to run this examples, the smt library must first be added to the virtual environment: pip install smt Then, the main_sm.py script in the NACA12/naca_smt example folder can be used to perform all three steps at once: # from aero-optim to naca_smt cd examples / NACA12 / naca_smt python3 main_sm . py - c naca_doe . json - csm naca_smt . json It will produce an output_doe folder with the results of the initial DOE generation and output_smt with the results of the surrogate based optimization. At that point, the optimal profile properties obtained with the surrogate can be compared to its corresponding CFD simulation: # deformed profile generation ffd -f ../data/naca12.dat -nc 4 -d \"<displacement of the optimal profile>\" -o output_optim # deformed profile meshing mesh -c naca_doe.json -f output_optim/naca12_g0_c0.dat -o output_optim # simulation execution simulator -c naca_doe.json -f output_optim/naca_base.mesh -o optim_profile","title":"Surrogate based Optimization"},{"location":"example_smo/#surrogate-based-optimization","text":"Surrogate based optimization (SBO) is a common practice in aerodynamic shape optimization. The main idea is to build an initial design of experiments (DOE) that is then used to train a surrogate model of the problem's quantities of interest (QoIs). In the end, the surrogate model is used in the optimization loop in place of the CFD solver. This tutorial illustrates the steps to do so with Aero-Optim : 1) a non-penalized DOE is built with a single generation optimization execution, 2) the results are used to train the surrogate model of the user's choosing, 3) a full optimization based on a CustomSimulator and a CustomOptimizer is performed by evaluating candidates with the trained surrogate model.","title":"Surrogate based Optimization"},{"location":"example_smo/#illustration","text":"The NACA12/naca_smt example shows how this can be done for the naca_base use-case and the smt toolbox . First, the naca_doe.json configuration file is built with max_generations set to 1 (the DOE is generated with pymoo ): subprocess . run ([ \"optim\" , \"-c\" , \"naca_doe.json\" , \"--pymoo\" ], env = os . environ , stdin = subprocess . DEVNULL , check = True ) Then, the results are loaded and used to train surrogate models for both Cd and Cl : X = np . loadtxt ( os . path . join ( outdir , \"candidates.txt\" )) Y = [] with open ( os . path . join ( outdir , \"df_dict.pkl\" ), \"rb\" ) as handle : df_dict = pickle . load ( handle ) for gid in range ( len ( df_dict )): for cid in range ( len ( df_dict [ gid ])): Y . append ([ df_dict [ gid ][ cid ][ \"CD\" ] . iloc [ - 1 ], df_dict [ gid ][ cid ][ \"CL\" ] . iloc [ - 1 ]]) Y = np . array ( Y ) del df_dict # Cd sm_cd = KRG ( theta0 = [ 1e-2 ]) sm_cd . set_training_values ( X , Y [:, 0 ]) sm_cd . train () # Cl sm_cl = KRG ( theta0 = [ 1e-2 ]) sm_cl . set_training_values ( X , Y [:, 1 ]) sm_cl . train () A straightforward CustomSM class is implemented to combine both models and emulate what would have been extracted from a simulation run: class CustomSM : def __init__ ( self , list_of_surrogates : list [ KRG ]): self . los : list [ KRG ] = list_of_surrogates def predict ( self , x : np . ndarray ) -> list [ float ]: return [ sm . predict_values ( x ) for sm in self . los ] # [Cd, Cl] custom_sm = CustomSM ([ sm_cd , sm_cl ]) with open ( os . path . join ( outdir , \"model.pkl\" ), \"wb\" ) as handle : pickle . dump ( custom_sm , handle ) Finally, a full optimization using this surrogate model is performed with the naca_smt.json configuration file and two additional parameters: \"custom_file\": \"custom_sm.py\" in the \"study\" entry, \"model_file\": \"output_doe/model.pkl\" in the \"simulator\" entry. subprocess . run ([ \"optim\" , \"-c\" , \"naca_smt.json\" , \"--pymoo\" ], env = os . environ , stdin = subprocess . DEVNULL , check = True ) For this instruction to work, the custom script custom_sm.py must also be implemented to define CustomSimulator and CustomOptimizer : class CustomSimulator ( Simulator ): def __init__ ( self , config : dict ): super () . __init__ ( config ) self . set_model ( config [ \"simulator\" ][ \"model_file\" ]) def process_config ( self ): logger . info ( \"processing config..\" ) if \"model_file\" not in self . config [ \"simulator\" ]: raise Exception ( f \"ERROR -- no <model_file> entry in { self . config [ 'simulator' ] } \" ) def set_solver_name ( self ): self . solver_name = \"smt_model\" def set_model ( self , model_file : str ): check_file ( model_file ) with open ( model_file , \"rb\" ) as handle : self . model = pickle . load ( handle ) def execute_sim ( self , candidates : list [ float ] | np . ndarray , gid : int = 0 ): logger . info ( f \"execute simulations g { gid } with { self . solver_name } \" ) cd , cl = self . model . predict ( np . array ( candidates )) self . df_dict [ gid ] = { cid : pd . DataFrame ({ \"ResTot\" : 1. , \"CD\" : cd [ cid ], \"CL\" : cl [ cid ]}) for cid in range ( len ( candidates )) } class CustomOptimizer ( PymooWolfOptimizer ): def set_gmsh_mesh_class ( self ): self . MeshClass = None def execute_candidates ( self , candidates , gid ): logger . info ( f \"evaluating candidates of generation { self . gen_ctr } ..\" ) self . ffd_profiles . append ([]) self . inputs . append ([]) for cid , cand in enumerate ( candidates ): self . inputs [ gid ] . append ( np . array ( cand )) _ , ffd_profile = self . deform ( cand , gid , cid ) self . ffd_profiles [ gid ] . append ( ffd_profile ) self . simulator . execute_sim ( candidates , gid ) Tip Most surrogate models offer vectorized evaluation. It is therefore good practice to implement CustomSimulator in such a way that this aspect is leveraged. Warning Because the standard pickle library is not capable of unpickling an object whose class definition is unaccessible, dill is used instead.","title":"Illustration"},{"location":"example_smo/#quick-experiments","text":"In order to run this examples, the smt library must first be added to the virtual environment: pip install smt Then, the main_sm.py script in the NACA12/naca_smt example folder can be used to perform all three steps at once: # from aero-optim to naca_smt cd examples / NACA12 / naca_smt python3 main_sm . py - c naca_doe . json - csm naca_smt . json It will produce an output_doe folder with the results of the initial DOE generation and output_smt with the results of the surrogate based optimization. At that point, the optimal profile properties obtained with the surrogate can be compared to its corresponding CFD simulation: # deformed profile generation ffd -f ../data/naca12.dat -nc 4 -d \"<displacement of the optimal profile>\" -o output_optim # deformed profile meshing mesh -c naca_doe.json -f output_optim/naca12_g0_c0.dat -o output_optim # simulation execution simulator -c naca_doe.json -f output_optim/naca_base.mesh -o optim_profile","title":"Quick Experiments"},{"location":"ffd/","text":"Free-Form Deformation Module The deformation module relies on an abstract class Deform theoretically compatible with any kind of geometric deformation but it was only subclassed for Free-Form Deformation (FFD) purposes so far. FFD is a technique designed to deform solid geometric models in a free-form manner. It was originally introduced by Sederberg in 1986 ( doi ). The present implementation is based on the description in Duvigneau 2006 . The main steps of FFD are: 1) create a lattice, i.e. the minimal parallelepiped box that embeds the geometry (a rectangle in 2D), 2) project the geometry points into the lattice referential such that its coordinates now vary between [0;1] in both x and y directions, 3) for a given deformation vector applied to each control points of the lattice, the displacements of all points forming the geometry are computed with the tensor product of the Bernstein basis polynomials, 4) the deformed profile is finally projected back into the original referential. Note This implementation is limited to 2D geometries only. More sophisticated libraries exist such as PyGeM or pyGeo but they come with heavier dependencies and more cumbersome installation procedures. 2D FFD Free-Form Deformation is implemented in FFD_2D , a straightforward class instantiated with two positional arguments: file (str) which indicates the filename of the baseline geometry to be deformed, ncontrol (int) which indicates the number of design points on each side of the lattice. And two optional arguments: pad (tuple[int, int]) which can be used to make the lattice edges moveable, header (int) which is used to specify the number of header lines in file . Warning The input file is expected to have a specific formatting i.e. a 2 line header followed by coordinates given as tabulated entries (one point per row) with single space separators (see data/naca12.dat for an example). Once instantiated, the apply_ffd(Delta) method can be used to perform the deformation corresponding to the array Delta . Note During an FFD-based optimization, FFD_2D is initialized with ncontrol = n_design // 2 . Illustration An FFD with 2 control points (i.e. 4 in total) and the deformation vector Delta = (0., 0., 1., 1.) will yield the following profile: Considering the figure notations, one notices that the deformation vector Delta corresponds to the list of deformations to be applied to the lower control points followed by those applied to the upper control points. In this case, Delta is: $$(D_{10}=0.,\\, D_{20}=0.,\\, D_{11}=1.,\\, D_{21}=1.)$$ in lattice unit. The corner points are left unchanged so that the lattice corners remain fixed. Quick Experiments The auto_ffd.py scripts is called with the ffd command. It enables basic testing and visualization. It comes with a few options: ffd -- help usage : ffd [ - h ] - f FILE [ - c CONFIG ] [ - o OUTDIR ] [ - nc NCONTROL ] [ - np NPROFILE ] [ - d DELTA ] options : - h , -- help show this help message and exit - f FILE , -- file FILE baseline geometry : -- file =/ path / to / file . dat ( default : None ) - c CONFIG , -- config CONFIG config : -- config =/ path / to / config . json ( default : ) - o OUTDIR , -- outdir OUTDIR output directory ( default : output ) - nc NCONTROL , -- ncontrol NCONTROL number of control points on each side of the lattice ( default : 3 ) - np NPROFILE , -- nprofile NPROFILE number of profiles to generate ( default : 3 ) - d DELTA , -- delta DELTA Delta : 'D10 D20 .. D2nc' ( default : None ) For instance, the command below will perform 3 control points FFDs for 4 random deformations sampled with an LHS sampler: # from aero-optim to naca_base cd examples / NACA12 / naca_base ffd - f ../ data / naca12 . dat - np 4 - nc 3 2D FFD & POD The coupling between POD and FFD was implemented in the FFD_POD_2D class. Its objective is to build a dataset of n FFD perturbed profiles sampled from LHS and to use it to perform POD-based data reduction from the FFD dimension d to a smaller dimension d* . Details on how to do so are given in ( POD 1 ) and ( POD 2 ). The FFD_pod_2D class is instantiated with 5 positional arguments: file (str) which indicates the filename of the baseline geometry to be deformed, pod_ncontrol (int) which indicates the number of reduced design points, ffd_ncontrol (int) which indicates the number of FFD control points design points, ffd_dataset_size (int) which indicates the size of the FFD dataset used in the POD procedure, ffd_bound (tuple[Any]) which set the min/max displacement ranges of the FFD dataset used in the POD procedure. To use this functionality, the ffd_type of the \"study\" entry must be set to \"ffd_pod_2d\" . The number of FFD control points and boundaries are still given by the \"n_design\" and \"bound\" values of the \"optim\" entry. In the \"ffd\" entry, the POD reduced dimension is set via \"pod_ncontrol\" and the size of the FFD dataset with \"ffd_dataset_size\" . Note In the Optimizer class, the n_design attribute is automatically switched to \"pod_ncontrol\" once the FFD_POD_2D class is set. Quick Experiments An application of this feature is illustrated in the POD notebook . Quick Example Let us condiser a user who would want to perform an optimization based on 2D FFD of 10 control points in total (5 on each side) coupled with a POD of reduced dimension 5. The configuration file should be set as follows: { \"study\" : { \"ffd_type: \" ff d_pod_ 2 d \", ... }, \" op t im \": { \" n _desig n \": 10, \" bou n d \": [-0.2, 0.2], ... } \" ff d \": { \" pod_ n co ntr ol \": 5, \" ff d_da taset _size\": 1000 } } In turns, the effective number of design variables would be n_design = 5 . 2D FFD with rotation A variant of the FFD including an extra-rotation step around the center of gravity was implemented with the RotationWrapper class. It directly inherits from Deform and overrides apply_fd in a way such that for any deformation array Delta , the first components are used to perform a standard FFD deformation and the last value is used to rotate the deformed geometry. In the context of an optimization this means that n_design += 1 . Note A direct consequence of this approach is that the deformation array Delta has size n_design + 1 . In the optimizer, this is automatically handled by adding 1 to n_design when instantiating the FFDClass in set_ffd_class . To use this functionality, the ffd_type of the \"study\" entry can be set to any deformation kind and the boundaries are still given by the \"bound\" values of the \"optim\" entry. In the \"ffd\" entry, \"rotate\" should be set to true and the rotation range must be specified via \"rot_bound\" as a list of two values. The values will be automatically appended to the bound attribute of the Optimizer object. Quick Example Let us condiser a user who would want to perform an optimization based on 2D FFD of 10 control points in total (5 on each side) and an extra rotation step inside a +/-2 degrees range. The configuration file should be set as follows: { \"study\" : { \"ffd_type: \" ff d_ 2 d \", ... }, \" op t im \": { \" n _desig n \": 10, \" bou n d \": [-0.2, 0.2], ... } \" ff d \": { \" ro tat io n \": true, \" ro t _bou n d\": [-2, 2] } } In turns, the effective number of design variables would become n_design = 11 .","title":"FFD Module"},{"location":"ffd/#free-form-deformation-module","text":"The deformation module relies on an abstract class Deform theoretically compatible with any kind of geometric deformation but it was only subclassed for Free-Form Deformation (FFD) purposes so far. FFD is a technique designed to deform solid geometric models in a free-form manner. It was originally introduced by Sederberg in 1986 ( doi ). The present implementation is based on the description in Duvigneau 2006 . The main steps of FFD are: 1) create a lattice, i.e. the minimal parallelepiped box that embeds the geometry (a rectangle in 2D), 2) project the geometry points into the lattice referential such that its coordinates now vary between [0;1] in both x and y directions, 3) for a given deformation vector applied to each control points of the lattice, the displacements of all points forming the geometry are computed with the tensor product of the Bernstein basis polynomials, 4) the deformed profile is finally projected back into the original referential. Note This implementation is limited to 2D geometries only. More sophisticated libraries exist such as PyGeM or pyGeo but they come with heavier dependencies and more cumbersome installation procedures.","title":"Free-Form Deformation Module"},{"location":"ffd/#2d-ffd","text":"Free-Form Deformation is implemented in FFD_2D , a straightforward class instantiated with two positional arguments: file (str) which indicates the filename of the baseline geometry to be deformed, ncontrol (int) which indicates the number of design points on each side of the lattice. And two optional arguments: pad (tuple[int, int]) which can be used to make the lattice edges moveable, header (int) which is used to specify the number of header lines in file . Warning The input file is expected to have a specific formatting i.e. a 2 line header followed by coordinates given as tabulated entries (one point per row) with single space separators (see data/naca12.dat for an example). Once instantiated, the apply_ffd(Delta) method can be used to perform the deformation corresponding to the array Delta . Note During an FFD-based optimization, FFD_2D is initialized with ncontrol = n_design // 2 .","title":"2D FFD"},{"location":"ffd/#illustration","text":"An FFD with 2 control points (i.e. 4 in total) and the deformation vector Delta = (0., 0., 1., 1.) will yield the following profile: Considering the figure notations, one notices that the deformation vector Delta corresponds to the list of deformations to be applied to the lower control points followed by those applied to the upper control points. In this case, Delta is: $$(D_{10}=0.,\\, D_{20}=0.,\\, D_{11}=1.,\\, D_{21}=1.)$$ in lattice unit. The corner points are left unchanged so that the lattice corners remain fixed.","title":"Illustration"},{"location":"ffd/#quick-experiments","text":"The auto_ffd.py scripts is called with the ffd command. It enables basic testing and visualization. It comes with a few options: ffd -- help usage : ffd [ - h ] - f FILE [ - c CONFIG ] [ - o OUTDIR ] [ - nc NCONTROL ] [ - np NPROFILE ] [ - d DELTA ] options : - h , -- help show this help message and exit - f FILE , -- file FILE baseline geometry : -- file =/ path / to / file . dat ( default : None ) - c CONFIG , -- config CONFIG config : -- config =/ path / to / config . json ( default : ) - o OUTDIR , -- outdir OUTDIR output directory ( default : output ) - nc NCONTROL , -- ncontrol NCONTROL number of control points on each side of the lattice ( default : 3 ) - np NPROFILE , -- nprofile NPROFILE number of profiles to generate ( default : 3 ) - d DELTA , -- delta DELTA Delta : 'D10 D20 .. D2nc' ( default : None ) For instance, the command below will perform 3 control points FFDs for 4 random deformations sampled with an LHS sampler: # from aero-optim to naca_base cd examples / NACA12 / naca_base ffd - f ../ data / naca12 . dat - np 4 - nc 3","title":"Quick Experiments"},{"location":"ffd/#2d-ffd-pod","text":"The coupling between POD and FFD was implemented in the FFD_POD_2D class. Its objective is to build a dataset of n FFD perturbed profiles sampled from LHS and to use it to perform POD-based data reduction from the FFD dimension d to a smaller dimension d* . Details on how to do so are given in ( POD 1 ) and ( POD 2 ). The FFD_pod_2D class is instantiated with 5 positional arguments: file (str) which indicates the filename of the baseline geometry to be deformed, pod_ncontrol (int) which indicates the number of reduced design points, ffd_ncontrol (int) which indicates the number of FFD control points design points, ffd_dataset_size (int) which indicates the size of the FFD dataset used in the POD procedure, ffd_bound (tuple[Any]) which set the min/max displacement ranges of the FFD dataset used in the POD procedure. To use this functionality, the ffd_type of the \"study\" entry must be set to \"ffd_pod_2d\" . The number of FFD control points and boundaries are still given by the \"n_design\" and \"bound\" values of the \"optim\" entry. In the \"ffd\" entry, the POD reduced dimension is set via \"pod_ncontrol\" and the size of the FFD dataset with \"ffd_dataset_size\" . Note In the Optimizer class, the n_design attribute is automatically switched to \"pod_ncontrol\" once the FFD_POD_2D class is set.","title":"2D FFD &amp; POD"},{"location":"ffd/#quick-experiments_1","text":"An application of this feature is illustrated in the POD notebook .","title":"Quick Experiments"},{"location":"ffd/#quick-example","text":"Let us condiser a user who would want to perform an optimization based on 2D FFD of 10 control points in total (5 on each side) coupled with a POD of reduced dimension 5. The configuration file should be set as follows: { \"study\" : { \"ffd_type: \" ff d_pod_ 2 d \", ... }, \" op t im \": { \" n _desig n \": 10, \" bou n d \": [-0.2, 0.2], ... } \" ff d \": { \" pod_ n co ntr ol \": 5, \" ff d_da taset _size\": 1000 } } In turns, the effective number of design variables would be n_design = 5 .","title":"Quick Example"},{"location":"ffd/#2d-ffd-with-rotation","text":"A variant of the FFD including an extra-rotation step around the center of gravity was implemented with the RotationWrapper class. It directly inherits from Deform and overrides apply_fd in a way such that for any deformation array Delta , the first components are used to perform a standard FFD deformation and the last value is used to rotate the deformed geometry. In the context of an optimization this means that n_design += 1 . Note A direct consequence of this approach is that the deformation array Delta has size n_design + 1 . In the optimizer, this is automatically handled by adding 1 to n_design when instantiating the FFDClass in set_ffd_class . To use this functionality, the ffd_type of the \"study\" entry can be set to any deformation kind and the boundaries are still given by the \"bound\" values of the \"optim\" entry. In the \"ffd\" entry, \"rotate\" should be set to true and the rotation range must be specified via \"rot_bound\" as a list of two values. The values will be automatically appended to the bound attribute of the Optimizer object.","title":"2D FFD with rotation"},{"location":"ffd/#quick-example_1","text":"Let us condiser a user who would want to perform an optimization based on 2D FFD of 10 control points in total (5 on each side) and an extra rotation step inside a +/-2 degrees range. The configuration file should be set as follows: { \"study\" : { \"ffd_type: \" ff d_ 2 d \", ... }, \" op t im \": { \" n _desig n \": 10, \" bou n d \": [-0.2, 0.2], ... } \" ff d \": { \" ro tat io n \": true, \" ro t _bou n d\": [-2, 2] } } In turns, the effective number of design variables would become n_design = 11 .","title":"Quick Example"},{"location":"mesh/","text":"Mesh Module The meshing module builds on the gmsh Python API . Classes inheriting from a basic Mesh class are implemented for NACA airfoil use-cases: NACABaseMesh : implements a simple meshing routine for a naca12 profile with minimal parameters, NACABlockMesh : implements a structured by blocks meshing routine for a naca12 profile, CascadeMesh : implements an unstructured meshing routine for a compressor cascade with periodic elements. All three meshes are parameterized with a json formatted configuration file made of several dictionaries: { \"study\" : { // study entries parameterizing the study and input/output options }, \"gmsh\" : { // mesh related entries parameterizing gmsh api \"domain\" : { // domain entries parameterizing the computational domain size }, \"mesh\" : { // meshing entries parameterizing the boundary layer, // the domain boundaries and the extrusion if defined }, \"view\" : { // visualization entries parameterizing the GUI display } } } The meshing routine then goes through the following steps: 1) a Mesh object is instantiated from the configuration dictionary, 2) the build_mesh() method is called on the instantiated object which then triggers subsequent calls: build_2dmesh() that builds the computational domain and defines 2D meshing parameters (e.g. number of nodes, growth ratio) split_naca() or reorder_blade() that pre-processes the geometry coordinates list 3) the mesh is finally generated, GUI options are set and outputs (e.g. meshing log, output mesh) are written. Note All meshing parameters are described in their respective class definition (see Developer Guide ). NACA For the NACA use-case, two meshing routines were implemented. The first one is a very basic mesh with a few parameters while the second one was adapted from a structured mesh generation procedure. Although they have similar domains, the meshing routines differ in many aspects which is why they were handled through separate modules, with separate configuration files and in their respective use-case folders (i.e. NACA12/naca_base and NACA12/naca_block ). NACA Base Meshing details relative to this routine reside in the build_2dmesh() method and its inner calls. For instance, the split_naca() method describes how the naca profile should be split into its upper and lower parts. This is critical to the domain construction steps in build_2dmesh() since the trailing and leading edges may be used as construction points. The build_2dmesh() routine of the NACABaseMesh class also gives the possibility to mesh the boundary layer by calling build_bl() . The meshing of the boundary layer is triggered by setting \"bl\" to true in the \"mesh\" category of the configuration file. For this class, the computational domain is a rectangle whose inlet face (on the left) is made of a semi-circle. The domain dimensions are parameterized in the \"domain\" section of the configuration file: inlet (int) : the inlet face radius centered on the airfoil trailing edge, outlet (int) : the outlet distance to the airfoil trailing, le_offset (int) : the size (in point number) of the leading edge portion that is meshed with its own refinement level. The \"mesh\" entry contains various meshing parameters such as the number of nodes on the domain inner and outer boundaries or the parameters of the boundary layer if needed: nodes_inlet (int) : the number of nodes to mesh the inlet boundary, nodes_outlet (int) : the number of nodes to mesh the outlet boundary, side_nodes (int) : the number of nodes to mesh the upper and lower side boundaries, le (int) : the number of nodes to mesh the leading edge portion defined earlier, low (int) : the number of nodes to mesh the trailing lower portion of the airfoil, up (int) : the number of nodes to mesh the trailing upper portion of the airfoil. For this meshing routine, other \"mesh\" parameters can be used to parameterize the meshing of the boundary layer (BL): bl (bool) : whether to mesh the boundary layer (True) or not (False). bl_thickness (float) : the BL meshing cumulated thickness. bl_ratio (float) : the BL meshing growth ratio. bl_size (float) : the BL first element size. Finally, the \"view\" entry contains GUI options to turn it on or off, to display quality metrics and to split the view. NACA Block This meshing routine also inherits from Mesh . Particularities of this routine mostly lies in the build_2dmesh() method. Hence, the boundary layer cannot be meshed with build_bl() which is not called anymore. In addition, the domain is this time made of several inner blocks. Hence for this class, the computational domain still has the same general structure (a rectangle with a semi-circular inlet) but inner blocks are defined and parameterized in \"domain\" : inlet (int) : the inlet face radius centered on the airfoil trailing edge, outlet (int) : the outlet distance to the airfoil trailing, le_offset (int) : the size (in point number) of the leading edge portion that is meshed with its own refinement level, block_width (float) : the size of the trailing blocks that encompass the remaining of the airfoil. The \"mesh\" entry contains various meshing parameters such as the number of nodes on the domain inner/outer boundaries and blocks: n_inlet (int) : the number of nodes to mesh the inlet and the leading edge, n_vertical (int) : number of nodes to mesh the outlet and the blocks in the vertical direction, r_vertical (int) : the outlet and vertical direction growth ratio, n_airfoil (int) : the number of nodes to mesh both sides of the trailing portion of the airfoil, r_airfoil (int) : the airfoil sides growth ratio, n_wake (int) : the number of nodes in the wake direction, r_wake (int) : the wake growth ratio. Examples of unstructured meshes obtained with the naca routines are given below: Cascade This meshing routine corresponds to an internal flow simulation which was initially proposed by the DLR as a structured mesh to be used for LES simulations. Since the mesh is not meant for RANS simulations nor for adaptation (it has a coarse surface and boundary layer mesh), the DLR_mesh option (which is False by default) enables to switch the meshing routine to a simpler routine generating a mesh usable as a starting point of an adaptation procedure. DLR cascade mesh Setting the configuration file \"mesh\" parameters as follows: \"mesh\" : { \"DLR_mesh\" : true , \"bl\" : true , \"bl_thickness\" : 4e-3 , \"bl_ratio\" : 1.15 , \"bl_size\" : 5e-5 , \"bl_sizefar\" : 5e-4 , \"nodes_inlet\" : 20 , \"nodes_outlet\" : 20 , \"side_nodes_inlet\" : 20 , \"side_nodes_outlet\" : 50 , \"curved_side_nodes\" : 10 , \"structured\" : false } will yield the DLR computational domain and mesh as illustrated in the figures below. The line/spline numbers are indicated between brackets and the corresponding meshing parameter between parenthesis. Note This meshing routine was adapted from an existing gmsh file. For this reason, some parameters are hard coded inside the class definition (e.g. the points defining the blade splines and their progression values). Simple cascade mesh Setting the configuration file \"mesh\" parameters as follows: \"mesh\" : { \"bl\" : false , \"nodes_inlet\" : 20 , \"nodes_outlet\" : 20 , \"side_nodes_inlet\" : 20 , \"side_nodes_outlet\" : 50 , \"curved_side_nodes\" : 10 , \"le\" : 16 , \"te\" : 16 , \"nodes_ss\" : 200 , \"nodes_ps\" : 200 , \"structured\" : false } will yield the computational domain and mesh as illustrated in the figures below. Again, the line/spline numbers are indicated between brackets and the corresponding meshing parameter between parenthesis. Warning For the second routine, the number of splines making up the blade wall is different from the number of splines in the DLR version. For both routines, if the mesh is saved as a medit file (i.e. .mesh format), the tags of the upper and lower boundaries will automatically be merged so that there eventually only remains one tag per periodic size (28 for the superior boundary and 11 for the inferior one). Do not forget to adapt the solver input file in consequence when defining the boundary conditions! Quick Experiments The auto_gmsh.py scripts is called with the mesh command. It enables basic testing and visualization for a given configuration file: mesh --help usage: mesh [ -h ] [ -c CONFIG ] [ -f FILE ] [ -o OUTDIR ] options: -h, --help show this help message and exit -c CONFIG, --config CONFIG config: --config = /path/to/config.json ( default: None ) -f FILE, --file FILE input dat file: --file = /path/to/file.dat ( default: ) -o OUTDIR, --outdir OUTDIR simulation output directory ( default: ) For instance setting \"structured\" to true in naca_block_mesh.json will produce a fully structured mesh: # from aero-optim to naca_block cd examples/NACA12/naca_block mesh --config = naca_block.json It is also possible to supersede the config \"file\" entry with the --file input argument. Hence, any previously generated deformed geometry can be meshed according to the naca routine with the commands below: # from naca_block to naca_base cd ../naca_base ffd -f ../data/naca12.dat -nc 2 -d \"0. 0. 1. 1.\" mesh --config = naca_base.json --file = output/naca12_g0_c0.dat","title":"Mesh Module"},{"location":"mesh/#mesh-module","text":"The meshing module builds on the gmsh Python API . Classes inheriting from a basic Mesh class are implemented for NACA airfoil use-cases: NACABaseMesh : implements a simple meshing routine for a naca12 profile with minimal parameters, NACABlockMesh : implements a structured by blocks meshing routine for a naca12 profile, CascadeMesh : implements an unstructured meshing routine for a compressor cascade with periodic elements. All three meshes are parameterized with a json formatted configuration file made of several dictionaries: { \"study\" : { // study entries parameterizing the study and input/output options }, \"gmsh\" : { // mesh related entries parameterizing gmsh api \"domain\" : { // domain entries parameterizing the computational domain size }, \"mesh\" : { // meshing entries parameterizing the boundary layer, // the domain boundaries and the extrusion if defined }, \"view\" : { // visualization entries parameterizing the GUI display } } } The meshing routine then goes through the following steps: 1) a Mesh object is instantiated from the configuration dictionary, 2) the build_mesh() method is called on the instantiated object which then triggers subsequent calls: build_2dmesh() that builds the computational domain and defines 2D meshing parameters (e.g. number of nodes, growth ratio) split_naca() or reorder_blade() that pre-processes the geometry coordinates list 3) the mesh is finally generated, GUI options are set and outputs (e.g. meshing log, output mesh) are written. Note All meshing parameters are described in their respective class definition (see Developer Guide ).","title":"Mesh Module"},{"location":"mesh/#naca","text":"For the NACA use-case, two meshing routines were implemented. The first one is a very basic mesh with a few parameters while the second one was adapted from a structured mesh generation procedure. Although they have similar domains, the meshing routines differ in many aspects which is why they were handled through separate modules, with separate configuration files and in their respective use-case folders (i.e. NACA12/naca_base and NACA12/naca_block ).","title":"NACA"},{"location":"mesh/#naca-base","text":"Meshing details relative to this routine reside in the build_2dmesh() method and its inner calls. For instance, the split_naca() method describes how the naca profile should be split into its upper and lower parts. This is critical to the domain construction steps in build_2dmesh() since the trailing and leading edges may be used as construction points. The build_2dmesh() routine of the NACABaseMesh class also gives the possibility to mesh the boundary layer by calling build_bl() . The meshing of the boundary layer is triggered by setting \"bl\" to true in the \"mesh\" category of the configuration file. For this class, the computational domain is a rectangle whose inlet face (on the left) is made of a semi-circle. The domain dimensions are parameterized in the \"domain\" section of the configuration file: inlet (int) : the inlet face radius centered on the airfoil trailing edge, outlet (int) : the outlet distance to the airfoil trailing, le_offset (int) : the size (in point number) of the leading edge portion that is meshed with its own refinement level. The \"mesh\" entry contains various meshing parameters such as the number of nodes on the domain inner and outer boundaries or the parameters of the boundary layer if needed: nodes_inlet (int) : the number of nodes to mesh the inlet boundary, nodes_outlet (int) : the number of nodes to mesh the outlet boundary, side_nodes (int) : the number of nodes to mesh the upper and lower side boundaries, le (int) : the number of nodes to mesh the leading edge portion defined earlier, low (int) : the number of nodes to mesh the trailing lower portion of the airfoil, up (int) : the number of nodes to mesh the trailing upper portion of the airfoil. For this meshing routine, other \"mesh\" parameters can be used to parameterize the meshing of the boundary layer (BL): bl (bool) : whether to mesh the boundary layer (True) or not (False). bl_thickness (float) : the BL meshing cumulated thickness. bl_ratio (float) : the BL meshing growth ratio. bl_size (float) : the BL first element size. Finally, the \"view\" entry contains GUI options to turn it on or off, to display quality metrics and to split the view.","title":"NACA Base"},{"location":"mesh/#naca-block","text":"This meshing routine also inherits from Mesh . Particularities of this routine mostly lies in the build_2dmesh() method. Hence, the boundary layer cannot be meshed with build_bl() which is not called anymore. In addition, the domain is this time made of several inner blocks. Hence for this class, the computational domain still has the same general structure (a rectangle with a semi-circular inlet) but inner blocks are defined and parameterized in \"domain\" : inlet (int) : the inlet face radius centered on the airfoil trailing edge, outlet (int) : the outlet distance to the airfoil trailing, le_offset (int) : the size (in point number) of the leading edge portion that is meshed with its own refinement level, block_width (float) : the size of the trailing blocks that encompass the remaining of the airfoil. The \"mesh\" entry contains various meshing parameters such as the number of nodes on the domain inner/outer boundaries and blocks: n_inlet (int) : the number of nodes to mesh the inlet and the leading edge, n_vertical (int) : number of nodes to mesh the outlet and the blocks in the vertical direction, r_vertical (int) : the outlet and vertical direction growth ratio, n_airfoil (int) : the number of nodes to mesh both sides of the trailing portion of the airfoil, r_airfoil (int) : the airfoil sides growth ratio, n_wake (int) : the number of nodes in the wake direction, r_wake (int) : the wake growth ratio. Examples of unstructured meshes obtained with the naca routines are given below:","title":"NACA Block"},{"location":"mesh/#cascade","text":"This meshing routine corresponds to an internal flow simulation which was initially proposed by the DLR as a structured mesh to be used for LES simulations. Since the mesh is not meant for RANS simulations nor for adaptation (it has a coarse surface and boundary layer mesh), the DLR_mesh option (which is False by default) enables to switch the meshing routine to a simpler routine generating a mesh usable as a starting point of an adaptation procedure.","title":"Cascade"},{"location":"mesh/#dlr-cascade-mesh","text":"Setting the configuration file \"mesh\" parameters as follows: \"mesh\" : { \"DLR_mesh\" : true , \"bl\" : true , \"bl_thickness\" : 4e-3 , \"bl_ratio\" : 1.15 , \"bl_size\" : 5e-5 , \"bl_sizefar\" : 5e-4 , \"nodes_inlet\" : 20 , \"nodes_outlet\" : 20 , \"side_nodes_inlet\" : 20 , \"side_nodes_outlet\" : 50 , \"curved_side_nodes\" : 10 , \"structured\" : false } will yield the DLR computational domain and mesh as illustrated in the figures below. The line/spline numbers are indicated between brackets and the corresponding meshing parameter between parenthesis. Note This meshing routine was adapted from an existing gmsh file. For this reason, some parameters are hard coded inside the class definition (e.g. the points defining the blade splines and their progression values).","title":"DLR cascade mesh"},{"location":"mesh/#simple-cascade-mesh","text":"Setting the configuration file \"mesh\" parameters as follows: \"mesh\" : { \"bl\" : false , \"nodes_inlet\" : 20 , \"nodes_outlet\" : 20 , \"side_nodes_inlet\" : 20 , \"side_nodes_outlet\" : 50 , \"curved_side_nodes\" : 10 , \"le\" : 16 , \"te\" : 16 , \"nodes_ss\" : 200 , \"nodes_ps\" : 200 , \"structured\" : false } will yield the computational domain and mesh as illustrated in the figures below. Again, the line/spline numbers are indicated between brackets and the corresponding meshing parameter between parenthesis. Warning For the second routine, the number of splines making up the blade wall is different from the number of splines in the DLR version. For both routines, if the mesh is saved as a medit file (i.e. .mesh format), the tags of the upper and lower boundaries will automatically be merged so that there eventually only remains one tag per periodic size (28 for the superior boundary and 11 for the inferior one). Do not forget to adapt the solver input file in consequence when defining the boundary conditions!","title":"Simple cascade mesh"},{"location":"mesh/#quick-experiments","text":"The auto_gmsh.py scripts is called with the mesh command. It enables basic testing and visualization for a given configuration file: mesh --help usage: mesh [ -h ] [ -c CONFIG ] [ -f FILE ] [ -o OUTDIR ] options: -h, --help show this help message and exit -c CONFIG, --config CONFIG config: --config = /path/to/config.json ( default: None ) -f FILE, --file FILE input dat file: --file = /path/to/file.dat ( default: ) -o OUTDIR, --outdir OUTDIR simulation output directory ( default: ) For instance setting \"structured\" to true in naca_block_mesh.json will produce a fully structured mesh: # from aero-optim to naca_block cd examples/NACA12/naca_block mesh --config = naca_block.json It is also possible to supersede the config \"file\" entry with the --file input argument. Hence, any previously generated deformed geometry can be meshed according to the naca routine with the commands below: # from naca_block to naca_base cd ../naca_base ffd -f ../data/naca12.dat -nc 2 -d \"0. 0. 1. 1.\" mesh --config = naca_base.json --file = output/naca12_g0_c0.dat","title":"Quick Experiments"},{"location":"mfsm/","text":"Multi-Fidelity Surrogate Module This module implements two major bricks required to perform multi-fidelity surrogate-assisted optimization: mf_models which defines model classes to be used for single- / multi-fidelity and single- / multi-objective prediction, mf_infill which defines sub-optimization problems to be minimized or maximized in the context of Bayesian or non-Bayesian infill strategies. All features related to surrogate models come with additional dependencies listed in requirements_sm.txt and recalled below: torch # Pytorch for deep learning based models (MFDNN) smt # for single- and multi-fidelity kriging (MfSMT) GPy # for co-kriging and other Gaussian processes models emukit # for co-kriging and other Gaussian processes models These dependencies can be added to the user's environment with the following command: # from aero-optim pip install -r requirements_sm.txt Multi-Fidelity Models The MfModel abstract class defines how any multi-fidelity surrogate model can be wrapped. It is initialized with the following positional arguments: dim (int) which indicates the dimension of the problem, model_dict (dict) which contains model specific information, outdir (str) the directory where model parameters should be saved, seed (int) the random seed the model will be initialized with, x_lf_DOE (np.ndarray) and y_lf_DOE (np.ndarray) the low-fidelity initial DOE, x_hf_DOE (np.ndarray) and y_hf_DOE (np.ndarray) the high-fidelity initial DOE. When inherited, the following methods should also be overridden: train() which defines how the model should be trained, evaluate() which defines how the model should be evaluated, evaluate_std() which defines how the model standard deviation should be computed when the model is of Bayesian nature. In addition, any MfModel based model will have access to two base methods: set_DOE() which updates the model DOEs, get_DOE() which returns the model DOEs. Except for Neural Network based models, most multi-fidelity models available in mf_models are single-output models, the MultiObjectiveModel class is implemented to turn any MfModel into a multi-objective model. To do so, MfModel objects are built for each objective and passed as a list when MultiObjectiveModel is initialized. This way, the use of MultiObjectiveModel is transparent to the user. The only difference occurs when the model DOEs are updated. For such models, the arrays of objectives must be passed as a list of 1D arrays via the set_DOE() method. Infill strategies The mf_infill module implements various sub-optimization problems related to both single- and bi-objective adaptive infill. The single-objective adaptive infill strategies are: the Lower Confidence Bound minimized via minimize_LCB , the Expected Improvement maximized via maximize_EI . The bi-objective infill strategies are: the Probability of Improvement maximized via maximize_PI_BO , the minimal Probability of Improvement maximized via maximize_MPI_BO . Note The multi-fidelity aspect of the surrogate model used to solve one of these sub-optimization problems only explicitly intervenes with bi-objective adaptive strategies which can use the Pareto front based on the current low- or high-fidelity DOE. Regardless of the number of objectives, the max-min Euclidean Distance sub-optimization problems provides samples that harmonize the coverage of the design space. It is solved via maximize_ED . Quick Experiments Surrogate models can be evaluated with 1D or multi-dimensional functions with the scripts contained in scripts/MF-SM . For instance, the SMT multi-fidelity co-kriging, can be evaluated on all four Brevault's 1D functions via the command below: # from aero-optim to scripts/MF-SM cd scripts/MF-SM python3 main_mf.py -c config/example.json -o mfsmt -m mfsmt -f 1d -n 1 where example.json is a configuration file specifying the parameters of the training and evaluation. If the configuration file contains a \"function nd\" entry, the model can be trained and evaluated with Brevault's multi-dimensional functions by simply changing the command line argument -f from 1d to nd : python3 main_mf.py -c config/example.json -o mfsmt -m mfsmt -f nd -n 1 Note For 1D functions, the \"parameter\" entry of the configuration file indicates Brevault's functions parameters while for multi-dimensional functions, it indicates their dimension. In addition to this script, two other notebooks designed for prototyping and validation purposes for single- and multi-objective infill strategies are available in scripts/MF-SM .","title":"Multi-Fidelity Surrogate Module"},{"location":"mfsm/#multi-fidelity-surrogate-module","text":"This module implements two major bricks required to perform multi-fidelity surrogate-assisted optimization: mf_models which defines model classes to be used for single- / multi-fidelity and single- / multi-objective prediction, mf_infill which defines sub-optimization problems to be minimized or maximized in the context of Bayesian or non-Bayesian infill strategies. All features related to surrogate models come with additional dependencies listed in requirements_sm.txt and recalled below: torch # Pytorch for deep learning based models (MFDNN) smt # for single- and multi-fidelity kriging (MfSMT) GPy # for co-kriging and other Gaussian processes models emukit # for co-kriging and other Gaussian processes models These dependencies can be added to the user's environment with the following command: # from aero-optim pip install -r requirements_sm.txt","title":"Multi-Fidelity Surrogate Module"},{"location":"mfsm/#multi-fidelity-models","text":"The MfModel abstract class defines how any multi-fidelity surrogate model can be wrapped. It is initialized with the following positional arguments: dim (int) which indicates the dimension of the problem, model_dict (dict) which contains model specific information, outdir (str) the directory where model parameters should be saved, seed (int) the random seed the model will be initialized with, x_lf_DOE (np.ndarray) and y_lf_DOE (np.ndarray) the low-fidelity initial DOE, x_hf_DOE (np.ndarray) and y_hf_DOE (np.ndarray) the high-fidelity initial DOE. When inherited, the following methods should also be overridden: train() which defines how the model should be trained, evaluate() which defines how the model should be evaluated, evaluate_std() which defines how the model standard deviation should be computed when the model is of Bayesian nature. In addition, any MfModel based model will have access to two base methods: set_DOE() which updates the model DOEs, get_DOE() which returns the model DOEs. Except for Neural Network based models, most multi-fidelity models available in mf_models are single-output models, the MultiObjectiveModel class is implemented to turn any MfModel into a multi-objective model. To do so, MfModel objects are built for each objective and passed as a list when MultiObjectiveModel is initialized. This way, the use of MultiObjectiveModel is transparent to the user. The only difference occurs when the model DOEs are updated. For such models, the arrays of objectives must be passed as a list of 1D arrays via the set_DOE() method.","title":"Multi-Fidelity Models"},{"location":"mfsm/#infill-strategies","text":"The mf_infill module implements various sub-optimization problems related to both single- and bi-objective adaptive infill. The single-objective adaptive infill strategies are: the Lower Confidence Bound minimized via minimize_LCB , the Expected Improvement maximized via maximize_EI . The bi-objective infill strategies are: the Probability of Improvement maximized via maximize_PI_BO , the minimal Probability of Improvement maximized via maximize_MPI_BO . Note The multi-fidelity aspect of the surrogate model used to solve one of these sub-optimization problems only explicitly intervenes with bi-objective adaptive strategies which can use the Pareto front based on the current low- or high-fidelity DOE. Regardless of the number of objectives, the max-min Euclidean Distance sub-optimization problems provides samples that harmonize the coverage of the design space. It is solved via maximize_ED .","title":"Infill strategies"},{"location":"mfsm/#quick-experiments","text":"Surrogate models can be evaluated with 1D or multi-dimensional functions with the scripts contained in scripts/MF-SM . For instance, the SMT multi-fidelity co-kriging, can be evaluated on all four Brevault's 1D functions via the command below: # from aero-optim to scripts/MF-SM cd scripts/MF-SM python3 main_mf.py -c config/example.json -o mfsmt -m mfsmt -f 1d -n 1 where example.json is a configuration file specifying the parameters of the training and evaluation. If the configuration file contains a \"function nd\" entry, the model can be trained and evaluated with Brevault's multi-dimensional functions by simply changing the command line argument -f from 1d to nd : python3 main_mf.py -c config/example.json -o mfsmt -m mfsmt -f nd -n 1 Note For 1D functions, the \"parameter\" entry of the configuration file indicates Brevault's functions parameters while for multi-dimensional functions, it indicates their dimension. In addition to this script, two other notebooks designed for prototyping and validation purposes for single- and multi-objective infill strategies are available in scripts/MF-SM .","title":"Quick Experiments"},{"location":"optimizer/","text":"Evolution and Optimizer Modules The evolution and optimizer modules are designed to define all components required by an evolution algorithm based on the inspyred logic: generator : a function used to sample an initial population, observer : a function executed after each evaluation, evaluator : a function used to evaluate the candidates of each generation, some additional optimization arguments. The framework currently supports two optimization libraries : inspyred and pymoo . The Evolution class is the upmost class in the optimization framework. It is used to define the optimizer, the evolution algorithm and how they should be executed together. Thus, the Optimizer required attributes and methods are passed to the evolutionary computation algorithm (see ec framework for inspyred and algorithms in pymoo ) and its optimization method (see ec.evolve for inspyred and optimize.minimize for pymoo ). To do so, the Evolution class ensures that the algorithm object and the optimization method are set and executed according to the chosen library requirements. Evolution The Evolution abstract class is initialized with the configuration dictionary that is used to instantiate its optimizer (Optimizer) attribute. In addition, it implements two base methods: set_ea : which sets the evolutionary algorithm, evolve : which defines how the optimization should be executed. When an optimization is launched, the InspyredEvolution or PymooEvolution class is selected based on the option passed to the optim command (see example below). From there, the evolution strategy is selected based on the optimizer and its strategy_name . By default, strategy_name = \"PSO\" but this can be changed by specifying \"strategy\" in the \"optim\" entry of the configuration file. Tip Only two single objective strategies are currently supported for each library: ES and PSO for inspyred , GA and PSO for pymoo . More advanced strategies must be specified by customizing the Evolution class (see Customized Optimization ). Note InspyredEvolution or PymooEvolution are briefly described in their respective class definition (see Evolution classes ). Optimizer The Optimizer abstract class extracts general arguments from the \"optim\" and \"study\" dictionaries of the configuration file such as: [optim] n_design (int) : the number of design points i.e. the dimension of the problem, [optim] doe_size (int) : the doe/population size i.e. the number of individuals per generation, [optim] max_generations (int) : the maximal number of generations to evaluate, [study] file (str) : the baseline geometry file, [study] outdir (str) : the optimization output directory, [study] study_type (str) : the type of study i.e. the meshing routine to use. It instantiates optimization related objects: generator (Generator) : object to sample the initial DOE, ffd (FFD_2D) : object to deform the baseline geometry, gmsh_mesh (Mesh) : object to mesh the deformed geometry. It also implements the following three base methods: process_config : which goes through the configuration file making sure expected entries are well defined, deform : which generates the deformed candidate, mesh : which meshes the deformed candidates. Regardless of the optimization library, the Optimizer class acts as an evaluator and must hence implement an _evaluate method that is used during the optimization. However since they both have their own specificities in terms of candidate management, typing and structure, the choice has been made to inherit the Optimizer class separately for each library. Tip The Generator class is based on scipy.qmc samplers. It supports three different sampling techniques: \"lhs\" , \"halton\" and \"sobol\" . The sampling technique is selected with the sampler_name entry of the \"optim\" dictionary in the configuration file. Note All optimizer parameters are described in their respective class definition (see Optimizer , WolfOptimizer (inspyred) , WolfOptimizer (pymoo) ). Wolf Optimizer The WolfOptimizer class illustrates how Optimizer can be inherited to perform a Wolf -based optimization. It is the default optimizer used when running optim . Regardless of the optimization library, it first instantiates a WolfSimulator attribute that is then used in the _evaluate method where for all candidates, the following steps are performed: 1) geometry deformation, 2) deformed geometry meshing, 3) simulation execution, 4) post-processing i.e. QoI extraction and constraint application. Note Design constraints penalizing inadequate geometries both in terms of area and lift coefficient are managed with apply_constraints for inspyred (see here ) and for pymoo (see here ). In the end, all simulations QoIs are returned either as a list of floats (with inspyred ) or as a numpy array (with pymoo ). In addition, after each evaluation the _observe method is called (automatically with inspyred , explicitly with pymoo ) to write or display the results of each generation candidates. The overall optimization progress is illustrated as the evolution of the generations statistics plotted and saved with the final_observe method. Debug Optimizer The DebugOptimizer class was introduced to facilitate prototyping and debugging. It is based on the DebugSimulator and follows a simplified structure of a classic optimizer without constraints, no geometry deformation nor meshing but where candidates are simply evaluation of the Ackley function . This optimizer is used when running optim with the --debug option . In addition, the _observe method does not generate any figure but only updates the optimization statistics which are finally plotted and saved with final_observe . Note For this class, candidates are not evaluated concurrently in distinct subprocesses but sequentially inside the _evaluate method. Quick Experiments The main_optim.py scripts is called with the optim command. It enable to launch a full optimization in accordance with the configuration file specifications: usage: optim [ -h ] -c CONFIG [ -o OUTDIR ] [ -f CUSTOM_FILE ] [ -d ] [ -v VERBOSE ] [ -p ] [ -i ] options: -h, --help show this help message and exit -c CONFIG, --config CONFIG /path/to/config.json ( default: None ) -o OUTDIR, --outdir OUTDIR optim output directory ( default: ) -f CUSTOM_FILE, --custom-file CUSTOM_FILE /path/to/custom_file.py ( default: ) -d, --debug use DEBUG mode ( default: False ) -v VERBOSE, --verbose VERBOSE logger verbosity level ( default: 3 ) -p, --pymoo use the pymoo library ( default: False ) -i, --inspyred use the inspyred library ( default: False ) For instance, setting doe_size and max_generations to 20 in naca_base.json and running the command below: # from aero-optim to naca_base cd examples/NACA12/naca_base optim -c naca_base.json --inspyred will perfom a 20 generations x 20 candidates optimization with inspyred and yield the following figure: Using the --pymoo option instead will yield the following graph: The main difference between these two results stems from the fact that, as opposed to pymoo which does not explicitly modify the fitness value of a penalized candidate, the inspyred optimizer does. Hence, any penalized candidate gets its fitness increased by one. Although this does not affect the optimization behavior, it does change the generations statistics. Note By default, the area penalization sanctions any candidate whose area is greater/smaller than the baseline area +/- 40%. This constraint can be altered for instance by setting area_margin to any other percentage value in the \"optim\" sub-dictionary of the configuration file. Tip In the configuration file, the budget entry should be adapted to the amount of resources available to the user.","title":"Evolution and Optimizer Modules"},{"location":"optimizer/#evolution-and-optimizer-modules","text":"The evolution and optimizer modules are designed to define all components required by an evolution algorithm based on the inspyred logic: generator : a function used to sample an initial population, observer : a function executed after each evaluation, evaluator : a function used to evaluate the candidates of each generation, some additional optimization arguments. The framework currently supports two optimization libraries : inspyred and pymoo . The Evolution class is the upmost class in the optimization framework. It is used to define the optimizer, the evolution algorithm and how they should be executed together. Thus, the Optimizer required attributes and methods are passed to the evolutionary computation algorithm (see ec framework for inspyred and algorithms in pymoo ) and its optimization method (see ec.evolve for inspyred and optimize.minimize for pymoo ). To do so, the Evolution class ensures that the algorithm object and the optimization method are set and executed according to the chosen library requirements.","title":"Evolution and Optimizer Modules"},{"location":"optimizer/#evolution","text":"The Evolution abstract class is initialized with the configuration dictionary that is used to instantiate its optimizer (Optimizer) attribute. In addition, it implements two base methods: set_ea : which sets the evolutionary algorithm, evolve : which defines how the optimization should be executed. When an optimization is launched, the InspyredEvolution or PymooEvolution class is selected based on the option passed to the optim command (see example below). From there, the evolution strategy is selected based on the optimizer and its strategy_name . By default, strategy_name = \"PSO\" but this can be changed by specifying \"strategy\" in the \"optim\" entry of the configuration file. Tip Only two single objective strategies are currently supported for each library: ES and PSO for inspyred , GA and PSO for pymoo . More advanced strategies must be specified by customizing the Evolution class (see Customized Optimization ). Note InspyredEvolution or PymooEvolution are briefly described in their respective class definition (see Evolution classes ).","title":"Evolution"},{"location":"optimizer/#optimizer","text":"The Optimizer abstract class extracts general arguments from the \"optim\" and \"study\" dictionaries of the configuration file such as: [optim] n_design (int) : the number of design points i.e. the dimension of the problem, [optim] doe_size (int) : the doe/population size i.e. the number of individuals per generation, [optim] max_generations (int) : the maximal number of generations to evaluate, [study] file (str) : the baseline geometry file, [study] outdir (str) : the optimization output directory, [study] study_type (str) : the type of study i.e. the meshing routine to use. It instantiates optimization related objects: generator (Generator) : object to sample the initial DOE, ffd (FFD_2D) : object to deform the baseline geometry, gmsh_mesh (Mesh) : object to mesh the deformed geometry. It also implements the following three base methods: process_config : which goes through the configuration file making sure expected entries are well defined, deform : which generates the deformed candidate, mesh : which meshes the deformed candidates. Regardless of the optimization library, the Optimizer class acts as an evaluator and must hence implement an _evaluate method that is used during the optimization. However since they both have their own specificities in terms of candidate management, typing and structure, the choice has been made to inherit the Optimizer class separately for each library. Tip The Generator class is based on scipy.qmc samplers. It supports three different sampling techniques: \"lhs\" , \"halton\" and \"sobol\" . The sampling technique is selected with the sampler_name entry of the \"optim\" dictionary in the configuration file. Note All optimizer parameters are described in their respective class definition (see Optimizer , WolfOptimizer (inspyred) , WolfOptimizer (pymoo) ).","title":"Optimizer"},{"location":"optimizer/#wolf-optimizer","text":"The WolfOptimizer class illustrates how Optimizer can be inherited to perform a Wolf -based optimization. It is the default optimizer used when running optim . Regardless of the optimization library, it first instantiates a WolfSimulator attribute that is then used in the _evaluate method where for all candidates, the following steps are performed: 1) geometry deformation, 2) deformed geometry meshing, 3) simulation execution, 4) post-processing i.e. QoI extraction and constraint application. Note Design constraints penalizing inadequate geometries both in terms of area and lift coefficient are managed with apply_constraints for inspyred (see here ) and for pymoo (see here ). In the end, all simulations QoIs are returned either as a list of floats (with inspyred ) or as a numpy array (with pymoo ). In addition, after each evaluation the _observe method is called (automatically with inspyred , explicitly with pymoo ) to write or display the results of each generation candidates. The overall optimization progress is illustrated as the evolution of the generations statistics plotted and saved with the final_observe method.","title":"Wolf Optimizer"},{"location":"optimizer/#debug-optimizer","text":"The DebugOptimizer class was introduced to facilitate prototyping and debugging. It is based on the DebugSimulator and follows a simplified structure of a classic optimizer without constraints, no geometry deformation nor meshing but where candidates are simply evaluation of the Ackley function . This optimizer is used when running optim with the --debug option . In addition, the _observe method does not generate any figure but only updates the optimization statistics which are finally plotted and saved with final_observe . Note For this class, candidates are not evaluated concurrently in distinct subprocesses but sequentially inside the _evaluate method.","title":"Debug Optimizer"},{"location":"optimizer/#quick-experiments","text":"The main_optim.py scripts is called with the optim command. It enable to launch a full optimization in accordance with the configuration file specifications: usage: optim [ -h ] -c CONFIG [ -o OUTDIR ] [ -f CUSTOM_FILE ] [ -d ] [ -v VERBOSE ] [ -p ] [ -i ] options: -h, --help show this help message and exit -c CONFIG, --config CONFIG /path/to/config.json ( default: None ) -o OUTDIR, --outdir OUTDIR optim output directory ( default: ) -f CUSTOM_FILE, --custom-file CUSTOM_FILE /path/to/custom_file.py ( default: ) -d, --debug use DEBUG mode ( default: False ) -v VERBOSE, --verbose VERBOSE logger verbosity level ( default: 3 ) -p, --pymoo use the pymoo library ( default: False ) -i, --inspyred use the inspyred library ( default: False ) For instance, setting doe_size and max_generations to 20 in naca_base.json and running the command below: # from aero-optim to naca_base cd examples/NACA12/naca_base optim -c naca_base.json --inspyred will perfom a 20 generations x 20 candidates optimization with inspyred and yield the following figure: Using the --pymoo option instead will yield the following graph: The main difference between these two results stems from the fact that, as opposed to pymoo which does not explicitly modify the fitness value of a penalized candidate, the inspyred optimizer does. Hence, any penalized candidate gets its fitness increased by one. Although this does not affect the optimization behavior, it does change the generations statistics. Note By default, the area penalization sanctions any candidate whose area is greater/smaller than the baseline area +/- 40%. This constraint can be altered for instance by setting area_margin to any other percentage value in the \"optim\" sub-dictionary of the configuration file. Tip In the configuration file, the budget entry should be adapted to the amount of resources available to the user.","title":"Quick Experiments"},{"location":"simulator/","text":"Simulator Module The simulator module is designed to orchestrate one or several simulation executions with a given solver. Hence, an Simulator abstract class extracts general arguments from the \"simulator\" dictionary of the configuration file such as: exec_cmd (str) : the solver execution command that is to be launched in the terminal, ref_input (str) : the path to the solver input template, sim_args (dict) : simulation arguments with which to customize the template, post_process (dict) : post-processing arguments to indicate which variables to extract from which result files. Then, any subclass inheriting from Simulator can be built by overriding two abstract methods: process_config : which goes through the configuration file making sure expected entries are well defined, execute_sim : which defines how a simulation should be executed. Note All simulator parameters are described in their respective class definition (see Simulator , WolfSimulator ). Wolf Simulator The WolfSimulator class illustrates how Simulator can be inherited to perform Wolf simulations. In addition to the mandatory methods, several others are introduced in order to facilitate the simulation progress monitoring (see sim_pro and monitor_sim_progress ) and the results post-processing (see post_process ). Finally, a mechanism of fault management is introduced with a kill_all method. The idea here is simply to provide a function to kill all active simulations in case something goes wrong in the main program. In the context of an optimization for instance, this feature is particularly important if the user wants to interrupt the main program without having to kill all simulations by hand. Debug Simulator The DebugSimulator class was introduced to facilitate prototyping and debugging. Instead of a real simulation execution, it directly evaluates the Ackley function for a given candidate. Quick Experiment The auto_simulator.py scripts is called with the simulator command. It enables basic testing and execution for a given configuration file: simulator --help usage: simulator [ -h ] [ -c CONFIG ] [ -f FILE ] [ -o OUTDIR ] options: -h, --help show this help message and exit -c CONFIG, --config CONFIG config: --config = /path/to/config.json ( default: None ) -f FILE, --file FILE input mesh file: --file = /path/to/file.mesh ( default: ) -o OUTDIR, --outdir OUTDIR simulation output directory ( default: ) For instance the commands below will generate a deformed profile, its associated mesh and perform a simulation with it: # from aero-optim to naca_base cd examples/NACA12/naca_base ffd -f ../data/naca12.dat -nc 2 -d \"0. 0. 1. 1.\" mesh --config = naca_base.json --file = output/naca12_g0_c0.dat simulator --config = naca_base.json --file = output/naca_base.mesh A zoomed view of the solution mach field plotted with vizir4 is illustrated below: Advanced Simulator Considering the variety of solvers, execution environment, etc., the Simulator class is theoretically adaptable to any use case. In general, it is good practice to keep track of any Python subprocess spawned by the application. However, depending on the user's situation, more sophisticated monitoring routines may need to be implemented. For a cluster using a slurm batch scheduler for instance, there are multiple ways to submit simulations whether they are submitted interactively (e.g. with srun ) or not (e.g. with sbatch ). In the latter case, progress monitoring cannot be made through simple subprocess tracking but by interacting with the batch scheduler database (e.g. with sacct ). Illustrative code on how to do so is available in the melissa repository (see scheduler ).","title":"Simulator Module"},{"location":"simulator/#simulator-module","text":"The simulator module is designed to orchestrate one or several simulation executions with a given solver. Hence, an Simulator abstract class extracts general arguments from the \"simulator\" dictionary of the configuration file such as: exec_cmd (str) : the solver execution command that is to be launched in the terminal, ref_input (str) : the path to the solver input template, sim_args (dict) : simulation arguments with which to customize the template, post_process (dict) : post-processing arguments to indicate which variables to extract from which result files. Then, any subclass inheriting from Simulator can be built by overriding two abstract methods: process_config : which goes through the configuration file making sure expected entries are well defined, execute_sim : which defines how a simulation should be executed. Note All simulator parameters are described in their respective class definition (see Simulator , WolfSimulator ).","title":"Simulator Module"},{"location":"simulator/#wolf-simulator","text":"The WolfSimulator class illustrates how Simulator can be inherited to perform Wolf simulations. In addition to the mandatory methods, several others are introduced in order to facilitate the simulation progress monitoring (see sim_pro and monitor_sim_progress ) and the results post-processing (see post_process ). Finally, a mechanism of fault management is introduced with a kill_all method. The idea here is simply to provide a function to kill all active simulations in case something goes wrong in the main program. In the context of an optimization for instance, this feature is particularly important if the user wants to interrupt the main program without having to kill all simulations by hand.","title":"Wolf Simulator"},{"location":"simulator/#debug-simulator","text":"The DebugSimulator class was introduced to facilitate prototyping and debugging. Instead of a real simulation execution, it directly evaluates the Ackley function for a given candidate.","title":"Debug Simulator"},{"location":"simulator/#quick-experiment","text":"The auto_simulator.py scripts is called with the simulator command. It enables basic testing and execution for a given configuration file: simulator --help usage: simulator [ -h ] [ -c CONFIG ] [ -f FILE ] [ -o OUTDIR ] options: -h, --help show this help message and exit -c CONFIG, --config CONFIG config: --config = /path/to/config.json ( default: None ) -f FILE, --file FILE input mesh file: --file = /path/to/file.mesh ( default: ) -o OUTDIR, --outdir OUTDIR simulation output directory ( default: ) For instance the commands below will generate a deformed profile, its associated mesh and perform a simulation with it: # from aero-optim to naca_base cd examples/NACA12/naca_base ffd -f ../data/naca12.dat -nc 2 -d \"0. 0. 1. 1.\" mesh --config = naca_base.json --file = output/naca12_g0_c0.dat simulator --config = naca_base.json --file = output/naca_base.mesh A zoomed view of the solution mach field plotted with vizir4 is illustrated below:","title":"Quick Experiment"},{"location":"simulator/#advanced-simulator","text":"Considering the variety of solvers, execution environment, etc., the Simulator class is theoretically adaptable to any use case. In general, it is good practice to keep track of any Python subprocess spawned by the application. However, depending on the user's situation, more sophisticated monitoring routines may need to be implemented. For a cluster using a slurm batch scheduler for instance, there are multiple ways to submit simulations whether they are submitted interactively (e.g. with srun ) or not (e.g. with sbatch ). In the latter case, progress monitoring cannot be made through simple subprocess tracking but by interacting with the batch scheduler database (e.g. with sacct ). Illustrative code on how to do so is available in the melissa repository (see scheduler ).","title":"Advanced Simulator"}]}